
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Provider
 * 
 */
export type Provider = $Result.DefaultSelection<Prisma.$ProviderPayload>
/**
 * Model Service
 * 
 */
export type Service = $Result.DefaultSelection<Prisma.$ServicePayload>
/**
 * Model Platform
 * 
 */
export type Platform = $Result.DefaultSelection<Prisma.$PlatformPayload>
/**
 * Model Contract
 * 
 */
export type Contract = $Result.DefaultSelection<Prisma.$ContractPayload>
/**
 * Model PlatformAccess
 * 
 */
export type PlatformAccess = $Result.DefaultSelection<Prisma.$PlatformAccessPayload>
/**
 * Model ContractPermission
 * 
 */
export type ContractPermission = $Result.DefaultSelection<Prisma.$ContractPermissionPayload>
/**
 * Model JWTToken
 * 
 */
export type JWTToken = $Result.DefaultSelection<Prisma.$JWTTokenPayload>
/**
 * Model ServiceSubscription
 * 
 */
export type ServiceSubscription = $Result.DefaultSelection<Prisma.$ServiceSubscriptionPayload>
/**
 * Model PlatformAccessToken
 * 
 */
export type PlatformAccessToken = $Result.DefaultSelection<Prisma.$PlatformAccessTokenPayload>
/**
 * Model ServicePermission
 * 
 */
export type ServicePermission = $Result.DefaultSelection<Prisma.$ServicePermissionPayload>
/**
 * Model AccessLog
 * 
 */
export type AccessLog = $Result.DefaultSelection<Prisma.$AccessLogPayload>
/**
 * Model UsageQuota
 * 
 */
export type UsageQuota = $Result.DefaultSelection<Prisma.$UsageQuotaPayload>
/**
 * Model ComplianceAudit
 * 
 */
export type ComplianceAudit = $Result.DefaultSelection<Prisma.$ComplianceAuditPayload>
/**
 * Model ZKProofVerification
 * 
 */
export type ZKProofVerification = $Result.DefaultSelection<Prisma.$ZKProofVerificationPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const ServiceType: {
  IDENTITY_VERIFICATION: 'IDENTITY_VERIFICATION',
  ASSET_TOKENIZATION: 'ASSET_TOKENIZATION',
  COMPLIANCE_ORACLE: 'COMPLIANCE_ORACLE',
  ZK_PROOF_SERVICE: 'ZK_PROOF_SERVICE',
  PRIVACY_BRIDGE: 'PRIVACY_BRIDGE',
  REGULATORY_REPORTING: 'REGULATORY_REPORTING',
  KYC_VERIFICATION: 'KYC_VERIFICATION',
  AML_MONITORING: 'AML_MONITORING',
  CROSS_CHAIN_BRIDGE: 'CROSS_CHAIN_BRIDGE',
  ATTESTATION_SERVICE: 'ATTESTATION_SERVICE'
};

export type ServiceType = (typeof ServiceType)[keyof typeof ServiceType]


export const RWAType: {
  REAL_ESTATE: 'REAL_ESTATE',
  COMMODITIES: 'COMMODITIES',
  SECURITIES: 'SECURITIES',
  INTELLECTUAL_PROPERTY: 'INTELLECTUAL_PROPERTY',
  CARBON_CREDITS: 'CARBON_CREDITS',
  SUPPLY_CHAIN_ASSETS: 'SUPPLY_CHAIN_ASSETS',
  ENERGY_CERTIFICATES: 'ENERGY_CERTIFICATES',
  INSURANCE_POLICIES: 'INSURANCE_POLICIES',
  TREASURY_BONDS: 'TREASURY_BONDS',
  PRIVATE_EQUITY: 'PRIVATE_EQUITY'
};

export type RWAType = (typeof RWAType)[keyof typeof RWAType]


export const VerificationLayer: {
  ZK_SNARKS: 'ZK_SNARKS',
  ZK_STARKS: 'ZK_STARKS',
  BULLETPROOFS: 'BULLETPROOFS',
  PLONK: 'PLONK',
  GROTH16: 'GROTH16',
  MARLIN: 'MARLIN',
  SONIC: 'SONIC',
  MULTI_PARTY_COMPUTATION: 'MULTI_PARTY_COMPUTATION',
  HOMOMORPHIC_ENCRYPTION: 'HOMOMORPHIC_ENCRYPTION',
  DIFFERENTIAL_PRIVACY: 'DIFFERENTIAL_PRIVACY',
  SECURE_ENCLAVES: 'SECURE_ENCLAVES',
  MERKLE_TREES: 'MERKLE_TREES',
  COMMITMENT_SCHEMES: 'COMMITMENT_SCHEMES',
  RING_SIGNATURES: 'RING_SIGNATURES'
};

export type VerificationLayer = (typeof VerificationLayer)[keyof typeof VerificationLayer]


export const InteractionLayer: {
  POLYGON_ZKEVM: 'POLYGON_ZKEVM',
  ARBITRUM_STYLUS: 'ARBITRUM_STYLUS',
  OPTIMISM_BEDROCK: 'OPTIMISM_BEDROCK',
  STARKNET: 'STARKNET',
  AZTEC_NOIR: 'AZTEC_NOIR',
  SCROLL: 'SCROLL',
  LINEA: 'LINEA',
  CHAINLINK_CCIP: 'CHAINLINK_CCIP',
  WORMHOLE: 'WORMHOLE',
  LAYERZERO: 'LAYERZERO',
  IBC_PROTOCOL: 'IBC_PROTOCOL',
  TORNADO_CASH: 'TORNADO_CASH',
  RAILGUN: 'RAILGUN',
  AZTEC_CONNECT: 'AZTEC_CONNECT'
};

export type InteractionLayer = (typeof InteractionLayer)[keyof typeof InteractionLayer]


export const ServiceVerificationType: {
  BIOMETRIC_ZK: 'BIOMETRIC_ZK',
  DOCUMENT_ZK_PROOF: 'DOCUMENT_ZK_PROOF',
  IDENTITY_NULLIFIER: 'IDENTITY_NULLIFIER',
  SELECTIVE_DISCLOSURE: 'SELECTIVE_DISCLOSURE',
  RANGE_PROOF: 'RANGE_PROOF',
  MEMBERSHIP_PROOF: 'MEMBERSHIP_PROOF',
  NON_MEMBERSHIP_PROOF: 'NON_MEMBERSHIP_PROOF',
  THRESHOLD_SIGNATURE: 'THRESHOLD_SIGNATURE',
  MULTI_SIG_ZK: 'MULTI_SIG_ZK',
  TIME_LOCK_PUZZLE: 'TIME_LOCK_PUZZLE'
};

export type ServiceVerificationType = (typeof ServiceVerificationType)[keyof typeof ServiceVerificationType]


export const InteropProtocol: {
  COSMOS_IBC: 'COSMOS_IBC',
  POLKADOT_XCMP: 'POLKADOT_XCMP',
  CHAINLINK_CCIP: 'CHAINLINK_CCIP',
  LAYERZERO_V2: 'LAYERZERO_V2',
  WORMHOLE_V3: 'WORMHOLE_V3',
  AXELAR_GMP: 'AXELAR_GMP',
  HYPERLANE: 'HYPERLANE',
  IBC_PROTOCOL: 'IBC_PROTOCOL'
};

export type InteropProtocol = (typeof InteropProtocol)[keyof typeof InteropProtocol]


export const ZKProofType: {
  IDENTITY_PROOF: 'IDENTITY_PROOF',
  ASSET_OWNERSHIP: 'ASSET_OWNERSHIP',
  COMPLIANCE_PROOF: 'COMPLIANCE_PROOF',
  SOLVENCY_PROOF: 'SOLVENCY_PROOF',
  RANGE_PROOF: 'RANGE_PROOF',
  SET_MEMBERSHIP: 'SET_MEMBERSHIP',
  NON_INCLUSION: 'NON_INCLUSION',
  COMPUTATION_INTEGRITY: 'COMPUTATION_INTEGRITY'
};

export type ZKProofType = (typeof ZKProofType)[keyof typeof ZKProofType]


export const PrivacyLevel: {
  PUBLIC: 'PUBLIC',
  PSEUDONYMOUS: 'PSEUDONYMOUS',
  ANONYMOUS: 'ANONYMOUS',
  ZERO_KNOWLEDGE: 'ZERO_KNOWLEDGE',
  PERFECT_PRIVACY: 'PERFECT_PRIVACY'
};

export type PrivacyLevel = (typeof PrivacyLevel)[keyof typeof PrivacyLevel]


export const ComplianceFramework: {
  GDPR: 'GDPR',
  CCPA: 'CCPA',
  SOX: 'SOX',
  MIFID_II: 'MIFID_II',
  BASEL_III: 'BASEL_III',
  FATCA: 'FATCA',
  CRS: 'CRS',
  PCI_DSS: 'PCI_DSS',
  ISO_27001: 'ISO_27001',
  NIST_FRAMEWORK: 'NIST_FRAMEWORK'
};

export type ComplianceFramework = (typeof ComplianceFramework)[keyof typeof ComplianceFramework]


export const AuthMethod: {
  JWT: 'JWT',
  OAUTH2: 'OAUTH2',
  API_KEY: 'API_KEY',
  ZK_PROOF: 'ZK_PROOF',
  MULTI_SIG: 'MULTI_SIG'
};

export type AuthMethod = (typeof AuthMethod)[keyof typeof AuthMethod]


export const AccessLevel: {
  READ: 'READ',
  WRITE: 'WRITE',
  ADMIN: 'ADMIN',
  ZK_VERIFY: 'ZK_VERIFY'
};

export type AccessLevel = (typeof AccessLevel)[keyof typeof AccessLevel]


export const JWTAlgorithm: {
  HS256: 'HS256',
  RS256: 'RS256',
  ES256: 'ES256',
  PS256: 'PS256'
};

export type JWTAlgorithm = (typeof JWTAlgorithm)[keyof typeof JWTAlgorithm]


export const ServiceCategory: {
  VERIFICATION: 'VERIFICATION',
  ORACLE: 'ORACLE',
  BRIDGE: 'BRIDGE',
  COMPLIANCE: 'COMPLIANCE'
};

export type ServiceCategory = (typeof ServiceCategory)[keyof typeof ServiceCategory]


export const ProofOfServiceType: {
  MERKLE_PROOF: 'MERKLE_PROOF',
  ZK_SNARK: 'ZK_SNARK',
  SIGNATURE: 'SIGNATURE',
  ATTESTATION: 'ATTESTATION'
};

export type ProofOfServiceType = (typeof ProofOfServiceType)[keyof typeof ProofOfServiceType]


export const PlatformType: {
  DEFI: 'DEFI',
  NFT: 'NFT',
  DAO: 'DAO',
  EXCHANGE: 'EXCHANGE',
  WALLET: 'WALLET'
};

export type PlatformType = (typeof PlatformType)[keyof typeof PlatformType]


export const PermissionLevel: {
  BASIC: 'BASIC',
  PREMIUM: 'PREMIUM',
  ENTERPRISE: 'ENTERPRISE'
};

export type PermissionLevel = (typeof PermissionLevel)[keyof typeof PermissionLevel]


export const ComplianceStatus: {
  COMPLIANT: 'COMPLIANT',
  PENDING: 'PENDING',
  NON_COMPLIANT: 'NON_COMPLIANT'
};

export type ComplianceStatus = (typeof ComplianceStatus)[keyof typeof ComplianceStatus]


export const AccessType: {
  ALL: 'ALL',
  SELECTED: 'SELECTED'
};

export type AccessType = (typeof AccessType)[keyof typeof AccessType]

}

export type ServiceType = $Enums.ServiceType

export const ServiceType: typeof $Enums.ServiceType

export type RWAType = $Enums.RWAType

export const RWAType: typeof $Enums.RWAType

export type VerificationLayer = $Enums.VerificationLayer

export const VerificationLayer: typeof $Enums.VerificationLayer

export type InteractionLayer = $Enums.InteractionLayer

export const InteractionLayer: typeof $Enums.InteractionLayer

export type ServiceVerificationType = $Enums.ServiceVerificationType

export const ServiceVerificationType: typeof $Enums.ServiceVerificationType

export type InteropProtocol = $Enums.InteropProtocol

export const InteropProtocol: typeof $Enums.InteropProtocol

export type ZKProofType = $Enums.ZKProofType

export const ZKProofType: typeof $Enums.ZKProofType

export type PrivacyLevel = $Enums.PrivacyLevel

export const PrivacyLevel: typeof $Enums.PrivacyLevel

export type ComplianceFramework = $Enums.ComplianceFramework

export const ComplianceFramework: typeof $Enums.ComplianceFramework

export type AuthMethod = $Enums.AuthMethod

export const AuthMethod: typeof $Enums.AuthMethod

export type AccessLevel = $Enums.AccessLevel

export const AccessLevel: typeof $Enums.AccessLevel

export type JWTAlgorithm = $Enums.JWTAlgorithm

export const JWTAlgorithm: typeof $Enums.JWTAlgorithm

export type ServiceCategory = $Enums.ServiceCategory

export const ServiceCategory: typeof $Enums.ServiceCategory

export type ProofOfServiceType = $Enums.ProofOfServiceType

export const ProofOfServiceType: typeof $Enums.ProofOfServiceType

export type PlatformType = $Enums.PlatformType

export const PlatformType: typeof $Enums.PlatformType

export type PermissionLevel = $Enums.PermissionLevel

export const PermissionLevel: typeof $Enums.PermissionLevel

export type ComplianceStatus = $Enums.ComplianceStatus

export const ComplianceStatus: typeof $Enums.ComplianceStatus

export type AccessType = $Enums.AccessType

export const AccessType: typeof $Enums.AccessType

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Providers
 * const providers = await prisma.provider.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Providers
   * const providers = await prisma.provider.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.provider`: Exposes CRUD operations for the **Provider** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.provider.findMany()
    * ```
    */
  get provider(): Prisma.ProviderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.service`: Exposes CRUD operations for the **Service** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Services
    * const services = await prisma.service.findMany()
    * ```
    */
  get service(): Prisma.ServiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platform`: Exposes CRUD operations for the **Platform** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Platforms
    * const platforms = await prisma.platform.findMany()
    * ```
    */
  get platform(): Prisma.PlatformDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contract`: Exposes CRUD operations for the **Contract** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Contracts
    * const contracts = await prisma.contract.findMany()
    * ```
    */
  get contract(): Prisma.ContractDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformAccess`: Exposes CRUD operations for the **PlatformAccess** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformAccesses
    * const platformAccesses = await prisma.platformAccess.findMany()
    * ```
    */
  get platformAccess(): Prisma.PlatformAccessDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.contractPermission`: Exposes CRUD operations for the **ContractPermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ContractPermissions
    * const contractPermissions = await prisma.contractPermission.findMany()
    * ```
    */
  get contractPermission(): Prisma.ContractPermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.jWTToken`: Exposes CRUD operations for the **JWTToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more JWTTokens
    * const jWTTokens = await prisma.jWTToken.findMany()
    * ```
    */
  get jWTToken(): Prisma.JWTTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.serviceSubscription`: Exposes CRUD operations for the **ServiceSubscription** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServiceSubscriptions
    * const serviceSubscriptions = await prisma.serviceSubscription.findMany()
    * ```
    */
  get serviceSubscription(): Prisma.ServiceSubscriptionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.platformAccessToken`: Exposes CRUD operations for the **PlatformAccessToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PlatformAccessTokens
    * const platformAccessTokens = await prisma.platformAccessToken.findMany()
    * ```
    */
  get platformAccessToken(): Prisma.PlatformAccessTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.servicePermission`: Exposes CRUD operations for the **ServicePermission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ServicePermissions
    * const servicePermissions = await prisma.servicePermission.findMany()
    * ```
    */
  get servicePermission(): Prisma.ServicePermissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.accessLog`: Exposes CRUD operations for the **AccessLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AccessLogs
    * const accessLogs = await prisma.accessLog.findMany()
    * ```
    */
  get accessLog(): Prisma.AccessLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.usageQuota`: Exposes CRUD operations for the **UsageQuota** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UsageQuotas
    * const usageQuotas = await prisma.usageQuota.findMany()
    * ```
    */
  get usageQuota(): Prisma.UsageQuotaDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complianceAudit`: Exposes CRUD operations for the **ComplianceAudit** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplianceAudits
    * const complianceAudits = await prisma.complianceAudit.findMany()
    * ```
    */
  get complianceAudit(): Prisma.ComplianceAuditDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.zKProofVerification`: Exposes CRUD operations for the **ZKProofVerification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ZKProofVerifications
    * const zKProofVerifications = await prisma.zKProofVerification.findMany()
    * ```
    */
  get zKProofVerification(): Prisma.ZKProofVerificationDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.8.2
   * Query Engine version: 2060c79ba17c6bb9f5823312b6f6b7f4a845738e
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Provider: 'Provider',
    Service: 'Service',
    Platform: 'Platform',
    Contract: 'Contract',
    PlatformAccess: 'PlatformAccess',
    ContractPermission: 'ContractPermission',
    JWTToken: 'JWTToken',
    ServiceSubscription: 'ServiceSubscription',
    PlatformAccessToken: 'PlatformAccessToken',
    ServicePermission: 'ServicePermission',
    AccessLog: 'AccessLog',
    UsageQuota: 'UsageQuota',
    ComplianceAudit: 'ComplianceAudit',
    ZKProofVerification: 'ZKProofVerification'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "provider" | "service" | "platform" | "contract" | "platformAccess" | "contractPermission" | "jWTToken" | "serviceSubscription" | "platformAccessToken" | "servicePermission" | "accessLog" | "usageQuota" | "complianceAudit" | "zKProofVerification"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Provider: {
        payload: Prisma.$ProviderPayload<ExtArgs>
        fields: Prisma.ProviderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findFirst: {
            args: Prisma.ProviderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          findMany: {
            args: Prisma.ProviderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          create: {
            args: Prisma.ProviderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          createMany: {
            args: Prisma.ProviderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          delete: {
            args: Prisma.ProviderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          update: {
            args: Prisma.ProviderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          deleteMany: {
            args: Prisma.ProviderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>[]
          }
          upsert: {
            args: Prisma.ProviderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderPayload>
          }
          aggregate: {
            args: Prisma.ProviderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProvider>
          }
          groupBy: {
            args: Prisma.ProviderGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderCountAggregateOutputType> | number
          }
        }
      }
      Service: {
        payload: Prisma.$ServicePayload<ExtArgs>
        fields: Prisma.ServiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findFirst: {
            args: Prisma.ServiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          findMany: {
            args: Prisma.ServiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          create: {
            args: Prisma.ServiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          createMany: {
            args: Prisma.ServiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          delete: {
            args: Prisma.ServiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          update: {
            args: Prisma.ServiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          deleteMany: {
            args: Prisma.ServiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>[]
          }
          upsert: {
            args: Prisma.ServiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePayload>
          }
          aggregate: {
            args: Prisma.ServiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateService>
          }
          groupBy: {
            args: Prisma.ServiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceCountAggregateOutputType> | number
          }
        }
      }
      Platform: {
        payload: Prisma.$PlatformPayload<ExtArgs>
        fields: Prisma.PlatformFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findFirst: {
            args: Prisma.PlatformFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          findMany: {
            args: Prisma.PlatformFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          create: {
            args: Prisma.PlatformCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          createMany: {
            args: Prisma.PlatformCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          delete: {
            args: Prisma.PlatformDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          update: {
            args: Prisma.PlatformUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          deleteMany: {
            args: Prisma.PlatformDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>[]
          }
          upsert: {
            args: Prisma.PlatformUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformPayload>
          }
          aggregate: {
            args: Prisma.PlatformAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatform>
          }
          groupBy: {
            args: Prisma.PlatformGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformCountAggregateOutputType> | number
          }
        }
      }
      Contract: {
        payload: Prisma.$ContractPayload<ExtArgs>
        fields: Prisma.ContractFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findFirst: {
            args: Prisma.ContractFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          findMany: {
            args: Prisma.ContractFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          create: {
            args: Prisma.ContractCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          createMany: {
            args: Prisma.ContractCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          delete: {
            args: Prisma.ContractDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          update: {
            args: Prisma.ContractUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          deleteMany: {
            args: Prisma.ContractDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>[]
          }
          upsert: {
            args: Prisma.ContractUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPayload>
          }
          aggregate: {
            args: Prisma.ContractAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContract>
          }
          groupBy: {
            args: Prisma.ContractGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractCountArgs<ExtArgs>
            result: $Utils.Optional<ContractCountAggregateOutputType> | number
          }
        }
      }
      PlatformAccess: {
        payload: Prisma.$PlatformAccessPayload<ExtArgs>
        fields: Prisma.PlatformAccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformAccessFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformAccessFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          findFirst: {
            args: Prisma.PlatformAccessFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformAccessFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          findMany: {
            args: Prisma.PlatformAccessFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>[]
          }
          create: {
            args: Prisma.PlatformAccessCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          createMany: {
            args: Prisma.PlatformAccessCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformAccessCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>[]
          }
          delete: {
            args: Prisma.PlatformAccessDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          update: {
            args: Prisma.PlatformAccessUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          deleteMany: {
            args: Prisma.PlatformAccessDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformAccessUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformAccessUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>[]
          }
          upsert: {
            args: Prisma.PlatformAccessUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessPayload>
          }
          aggregate: {
            args: Prisma.PlatformAccessAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformAccess>
          }
          groupBy: {
            args: Prisma.PlatformAccessGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformAccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformAccessCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformAccessCountAggregateOutputType> | number
          }
        }
      }
      ContractPermission: {
        payload: Prisma.$ContractPermissionPayload<ExtArgs>
        fields: Prisma.ContractPermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ContractPermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ContractPermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          findFirst: {
            args: Prisma.ContractPermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ContractPermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          findMany: {
            args: Prisma.ContractPermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>[]
          }
          create: {
            args: Prisma.ContractPermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          createMany: {
            args: Prisma.ContractPermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ContractPermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>[]
          }
          delete: {
            args: Prisma.ContractPermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          update: {
            args: Prisma.ContractPermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          deleteMany: {
            args: Prisma.ContractPermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ContractPermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ContractPermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>[]
          }
          upsert: {
            args: Prisma.ContractPermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ContractPermissionPayload>
          }
          aggregate: {
            args: Prisma.ContractPermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateContractPermission>
          }
          groupBy: {
            args: Prisma.ContractPermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ContractPermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ContractPermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ContractPermissionCountAggregateOutputType> | number
          }
        }
      }
      JWTToken: {
        payload: Prisma.$JWTTokenPayload<ExtArgs>
        fields: Prisma.JWTTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.JWTTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.JWTTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          findFirst: {
            args: Prisma.JWTTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.JWTTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          findMany: {
            args: Prisma.JWTTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>[]
          }
          create: {
            args: Prisma.JWTTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          createMany: {
            args: Prisma.JWTTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.JWTTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>[]
          }
          delete: {
            args: Prisma.JWTTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          update: {
            args: Prisma.JWTTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          deleteMany: {
            args: Prisma.JWTTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.JWTTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.JWTTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>[]
          }
          upsert: {
            args: Prisma.JWTTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$JWTTokenPayload>
          }
          aggregate: {
            args: Prisma.JWTTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateJWTToken>
          }
          groupBy: {
            args: Prisma.JWTTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<JWTTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.JWTTokenCountArgs<ExtArgs>
            result: $Utils.Optional<JWTTokenCountAggregateOutputType> | number
          }
        }
      }
      ServiceSubscription: {
        payload: Prisma.$ServiceSubscriptionPayload<ExtArgs>
        fields: Prisma.ServiceSubscriptionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServiceSubscriptionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServiceSubscriptionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          findFirst: {
            args: Prisma.ServiceSubscriptionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServiceSubscriptionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          findMany: {
            args: Prisma.ServiceSubscriptionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>[]
          }
          create: {
            args: Prisma.ServiceSubscriptionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          createMany: {
            args: Prisma.ServiceSubscriptionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServiceSubscriptionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>[]
          }
          delete: {
            args: Prisma.ServiceSubscriptionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          update: {
            args: Prisma.ServiceSubscriptionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          deleteMany: {
            args: Prisma.ServiceSubscriptionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServiceSubscriptionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServiceSubscriptionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>[]
          }
          upsert: {
            args: Prisma.ServiceSubscriptionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServiceSubscriptionPayload>
          }
          aggregate: {
            args: Prisma.ServiceSubscriptionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServiceSubscription>
          }
          groupBy: {
            args: Prisma.ServiceSubscriptionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServiceSubscriptionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServiceSubscriptionCountArgs<ExtArgs>
            result: $Utils.Optional<ServiceSubscriptionCountAggregateOutputType> | number
          }
        }
      }
      PlatformAccessToken: {
        payload: Prisma.$PlatformAccessTokenPayload<ExtArgs>
        fields: Prisma.PlatformAccessTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PlatformAccessTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PlatformAccessTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          findFirst: {
            args: Prisma.PlatformAccessTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PlatformAccessTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          findMany: {
            args: Prisma.PlatformAccessTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>[]
          }
          create: {
            args: Prisma.PlatformAccessTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          createMany: {
            args: Prisma.PlatformAccessTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PlatformAccessTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>[]
          }
          delete: {
            args: Prisma.PlatformAccessTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          update: {
            args: Prisma.PlatformAccessTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          deleteMany: {
            args: Prisma.PlatformAccessTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PlatformAccessTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PlatformAccessTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>[]
          }
          upsert: {
            args: Prisma.PlatformAccessTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PlatformAccessTokenPayload>
          }
          aggregate: {
            args: Prisma.PlatformAccessTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlatformAccessToken>
          }
          groupBy: {
            args: Prisma.PlatformAccessTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PlatformAccessTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PlatformAccessTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PlatformAccessTokenCountAggregateOutputType> | number
          }
        }
      }
      ServicePermission: {
        payload: Prisma.$ServicePermissionPayload<ExtArgs>
        fields: Prisma.ServicePermissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ServicePermissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ServicePermissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          findFirst: {
            args: Prisma.ServicePermissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ServicePermissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          findMany: {
            args: Prisma.ServicePermissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>[]
          }
          create: {
            args: Prisma.ServicePermissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          createMany: {
            args: Prisma.ServicePermissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ServicePermissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>[]
          }
          delete: {
            args: Prisma.ServicePermissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          update: {
            args: Prisma.ServicePermissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          deleteMany: {
            args: Prisma.ServicePermissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ServicePermissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ServicePermissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>[]
          }
          upsert: {
            args: Prisma.ServicePermissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ServicePermissionPayload>
          }
          aggregate: {
            args: Prisma.ServicePermissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateServicePermission>
          }
          groupBy: {
            args: Prisma.ServicePermissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ServicePermissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ServicePermissionCountArgs<ExtArgs>
            result: $Utils.Optional<ServicePermissionCountAggregateOutputType> | number
          }
        }
      }
      AccessLog: {
        payload: Prisma.$AccessLogPayload<ExtArgs>
        fields: Prisma.AccessLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findFirst: {
            args: Prisma.AccessLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          findMany: {
            args: Prisma.AccessLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          create: {
            args: Prisma.AccessLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          createMany: {
            args: Prisma.AccessLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccessLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          delete: {
            args: Prisma.AccessLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          update: {
            args: Prisma.AccessLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          deleteMany: {
            args: Prisma.AccessLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccessLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccessLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>[]
          }
          upsert: {
            args: Prisma.AccessLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccessLogPayload>
          }
          aggregate: {
            args: Prisma.AccessLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccessLog>
          }
          groupBy: {
            args: Prisma.AccessLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccessLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessLogCountArgs<ExtArgs>
            result: $Utils.Optional<AccessLogCountAggregateOutputType> | number
          }
        }
      }
      UsageQuota: {
        payload: Prisma.$UsageQuotaPayload<ExtArgs>
        fields: Prisma.UsageQuotaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsageQuotaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsageQuotaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          findFirst: {
            args: Prisma.UsageQuotaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsageQuotaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          findMany: {
            args: Prisma.UsageQuotaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>[]
          }
          create: {
            args: Prisma.UsageQuotaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          createMany: {
            args: Prisma.UsageQuotaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsageQuotaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>[]
          }
          delete: {
            args: Prisma.UsageQuotaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          update: {
            args: Prisma.UsageQuotaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          deleteMany: {
            args: Prisma.UsageQuotaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsageQuotaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UsageQuotaUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>[]
          }
          upsert: {
            args: Prisma.UsageQuotaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsageQuotaPayload>
          }
          aggregate: {
            args: Prisma.UsageQuotaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsageQuota>
          }
          groupBy: {
            args: Prisma.UsageQuotaGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsageQuotaGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsageQuotaCountArgs<ExtArgs>
            result: $Utils.Optional<UsageQuotaCountAggregateOutputType> | number
          }
        }
      }
      ComplianceAudit: {
        payload: Prisma.$ComplianceAuditPayload<ExtArgs>
        fields: Prisma.ComplianceAuditFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplianceAuditFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplianceAuditFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          findFirst: {
            args: Prisma.ComplianceAuditFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplianceAuditFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          findMany: {
            args: Prisma.ComplianceAuditFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>[]
          }
          create: {
            args: Prisma.ComplianceAuditCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          createMany: {
            args: Prisma.ComplianceAuditCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplianceAuditCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>[]
          }
          delete: {
            args: Prisma.ComplianceAuditDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          update: {
            args: Prisma.ComplianceAuditUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          deleteMany: {
            args: Prisma.ComplianceAuditDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplianceAuditUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplianceAuditUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>[]
          }
          upsert: {
            args: Prisma.ComplianceAuditUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplianceAuditPayload>
          }
          aggregate: {
            args: Prisma.ComplianceAuditAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplianceAudit>
          }
          groupBy: {
            args: Prisma.ComplianceAuditGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplianceAuditGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplianceAuditCountArgs<ExtArgs>
            result: $Utils.Optional<ComplianceAuditCountAggregateOutputType> | number
          }
        }
      }
      ZKProofVerification: {
        payload: Prisma.$ZKProofVerificationPayload<ExtArgs>
        fields: Prisma.ZKProofVerificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ZKProofVerificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ZKProofVerificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          findFirst: {
            args: Prisma.ZKProofVerificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ZKProofVerificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          findMany: {
            args: Prisma.ZKProofVerificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>[]
          }
          create: {
            args: Prisma.ZKProofVerificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          createMany: {
            args: Prisma.ZKProofVerificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ZKProofVerificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>[]
          }
          delete: {
            args: Prisma.ZKProofVerificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          update: {
            args: Prisma.ZKProofVerificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          deleteMany: {
            args: Prisma.ZKProofVerificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ZKProofVerificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ZKProofVerificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>[]
          }
          upsert: {
            args: Prisma.ZKProofVerificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ZKProofVerificationPayload>
          }
          aggregate: {
            args: Prisma.ZKProofVerificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateZKProofVerification>
          }
          groupBy: {
            args: Prisma.ZKProofVerificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ZKProofVerificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ZKProofVerificationCountArgs<ExtArgs>
            result: $Utils.Optional<ZKProofVerificationCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    provider?: ProviderOmit
    service?: ServiceOmit
    platform?: PlatformOmit
    contract?: ContractOmit
    platformAccess?: PlatformAccessOmit
    contractPermission?: ContractPermissionOmit
    jWTToken?: JWTTokenOmit
    serviceSubscription?: ServiceSubscriptionOmit
    platformAccessToken?: PlatformAccessTokenOmit
    servicePermission?: ServicePermissionOmit
    accessLog?: AccessLogOmit
    usageQuota?: UsageQuotaOmit
    complianceAudit?: ComplianceAuditOmit
    zKProofVerification?: ZKProofVerificationOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type ProviderCountOutputType
   */

  export type ProviderCountOutputType = {
    services: number
    platformAccess: number
    contractPermissions: number
    jwtTokens: number
    serviceSubscriptions: number
    platformAccessTokens: number
    complianceAudits: number
    accessLogs: number
    ServicePermission: number
  }

  export type ProviderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | ProviderCountOutputTypeCountServicesArgs
    platformAccess?: boolean | ProviderCountOutputTypeCountPlatformAccessArgs
    contractPermissions?: boolean | ProviderCountOutputTypeCountContractPermissionsArgs
    jwtTokens?: boolean | ProviderCountOutputTypeCountJwtTokensArgs
    serviceSubscriptions?: boolean | ProviderCountOutputTypeCountServiceSubscriptionsArgs
    platformAccessTokens?: boolean | ProviderCountOutputTypeCountPlatformAccessTokensArgs
    complianceAudits?: boolean | ProviderCountOutputTypeCountComplianceAuditsArgs
    accessLogs?: boolean | ProviderCountOutputTypeCountAccessLogsArgs
    ServicePermission?: boolean | ProviderCountOutputTypeCountServicePermissionArgs
  }

  // Custom InputTypes
  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderCountOutputType
     */
    select?: ProviderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountServicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountPlatformAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountContractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractPermissionWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountJwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JWTTokenWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountServiceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSubscriptionWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountPlatformAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessTokenWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountComplianceAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceAuditWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
  }

  /**
   * ProviderCountOutputType without action
   */
  export type ProviderCountOutputTypeCountServicePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePermissionWhereInput
  }


  /**
   * Count Type ServiceCountOutputType
   */

  export type ServiceCountOutputType = {
    contractPermissions: number
    jwtTokens: number
    serviceSubscriptions: number
    servicePermissions: number
    accessLogs: number
    complianceAudits: number
    zkProofVerifications: number
  }

  export type ServiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractPermissions?: boolean | ServiceCountOutputTypeCountContractPermissionsArgs
    jwtTokens?: boolean | ServiceCountOutputTypeCountJwtTokensArgs
    serviceSubscriptions?: boolean | ServiceCountOutputTypeCountServiceSubscriptionsArgs
    servicePermissions?: boolean | ServiceCountOutputTypeCountServicePermissionsArgs
    accessLogs?: boolean | ServiceCountOutputTypeCountAccessLogsArgs
    complianceAudits?: boolean | ServiceCountOutputTypeCountComplianceAuditsArgs
    zkProofVerifications?: boolean | ServiceCountOutputTypeCountZkProofVerificationsArgs
  }

  // Custom InputTypes
  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceCountOutputType
     */
    select?: ServiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountContractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractPermissionWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountJwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JWTTokenWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServiceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSubscriptionWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountServicePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePermissionWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountComplianceAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceAuditWhereInput
  }

  /**
   * ServiceCountOutputType without action
   */
  export type ServiceCountOutputTypeCountZkProofVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZKProofVerificationWhereInput
  }


  /**
   * Count Type PlatformCountOutputType
   */

  export type PlatformCountOutputType = {
    contracts: number
    serviceSubscriptions: number
    platformAccessTokens: number
    platformAccess: number
  }

  export type PlatformCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | PlatformCountOutputTypeCountContractsArgs
    serviceSubscriptions?: boolean | PlatformCountOutputTypeCountServiceSubscriptionsArgs
    platformAccessTokens?: boolean | PlatformCountOutputTypeCountPlatformAccessTokensArgs
    platformAccess?: boolean | PlatformCountOutputTypeCountPlatformAccessArgs
  }

  // Custom InputTypes
  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformCountOutputType
     */
    select?: PlatformCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountContractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountServiceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSubscriptionWhereInput
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountPlatformAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessTokenWhereInput
  }

  /**
   * PlatformCountOutputType without action
   */
  export type PlatformCountOutputTypeCountPlatformAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessWhereInput
  }


  /**
   * Count Type ContractCountOutputType
   */

  export type ContractCountOutputType = {
    contractPermissions: number
    jwtTokens: number
    servicePermissions: number
    accessLogs: number
    zkProofVerifications: number
  }

  export type ContractCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractPermissions?: boolean | ContractCountOutputTypeCountContractPermissionsArgs
    jwtTokens?: boolean | ContractCountOutputTypeCountJwtTokensArgs
    servicePermissions?: boolean | ContractCountOutputTypeCountServicePermissionsArgs
    accessLogs?: boolean | ContractCountOutputTypeCountAccessLogsArgs
    zkProofVerifications?: boolean | ContractCountOutputTypeCountZkProofVerificationsArgs
  }

  // Custom InputTypes
  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractCountOutputType
     */
    select?: ContractCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountContractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractPermissionWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountJwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JWTTokenWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountServicePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePermissionWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountAccessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
  }

  /**
   * ContractCountOutputType without action
   */
  export type ContractCountOutputTypeCountZkProofVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZKProofVerificationWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Provider
   */

  export type AggregateProvider = {
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  export type ProviderAvgAggregateOutputType = {
    id: number | null
  }

  export type ProviderSumAggregateOutputType = {
    id: number | null
  }

  export type ProviderMinAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: $Enums.ServiceType | null
    email: string | null
    rwaType: $Enums.RWAType | null
    verificationLayer: $Enums.VerificationLayer | null
    interactionLayer: $Enums.InteractionLayer | null
    logo: string | null
    coverImage: string | null
    serviceVerificationType: $Enums.ServiceVerificationType | null
    authMethod: $Enums.AuthMethod | null
    privacyLevel: $Enums.PrivacyLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderMaxAggregateOutputType = {
    id: number | null
    name: string | null
    serviceType: $Enums.ServiceType | null
    email: string | null
    rwaType: $Enums.RWAType | null
    verificationLayer: $Enums.VerificationLayer | null
    interactionLayer: $Enums.InteractionLayer | null
    logo: string | null
    coverImage: string | null
    serviceVerificationType: $Enums.ServiceVerificationType | null
    authMethod: $Enums.AuthMethod | null
    privacyLevel: $Enums.PrivacyLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProviderCountAggregateOutputType = {
    id: number
    name: number
    serviceType: number
    email: number
    rwaType: number
    verificationLayer: number
    interactionLayer: number
    logo: number
    coverImage: number
    serviceVerificationType: number
    chains: number
    interopProtocols: number
    serviceFee: number
    authMethod: number
    jwtSettings: number
    zkProofSupport: number
    privacyLevel: number
    complianceFramework: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProviderAvgAggregateInputType = {
    id?: true
  }

  export type ProviderSumAggregateInputType = {
    id?: true
  }

  export type ProviderMinAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    email?: true
    rwaType?: true
    verificationLayer?: true
    interactionLayer?: true
    logo?: true
    coverImage?: true
    serviceVerificationType?: true
    authMethod?: true
    privacyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderMaxAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    email?: true
    rwaType?: true
    verificationLayer?: true
    interactionLayer?: true
    logo?: true
    coverImage?: true
    serviceVerificationType?: true
    authMethod?: true
    privacyLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProviderCountAggregateInputType = {
    id?: true
    name?: true
    serviceType?: true
    email?: true
    rwaType?: true
    verificationLayer?: true
    interactionLayer?: true
    logo?: true
    coverImage?: true
    serviceVerificationType?: true
    chains?: true
    interopProtocols?: true
    serviceFee?: true
    authMethod?: true
    jwtSettings?: true
    zkProofSupport?: true
    privacyLevel?: true
    complianceFramework?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProviderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Provider to aggregate.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Providers
    **/
    _count?: true | ProviderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProviderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProviderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderMaxAggregateInputType
  }

  export type GetProviderAggregateType<T extends ProviderAggregateArgs> = {
        [P in keyof T & keyof AggregateProvider]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProvider[P]>
      : GetScalarType<T[P], AggregateProvider[P]>
  }




  export type ProviderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderWhereInput
    orderBy?: ProviderOrderByWithAggregationInput | ProviderOrderByWithAggregationInput[]
    by: ProviderScalarFieldEnum[] | ProviderScalarFieldEnum
    having?: ProviderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderCountAggregateInputType | true
    _avg?: ProviderAvgAggregateInputType
    _sum?: ProviderSumAggregateInputType
    _min?: ProviderMinAggregateInputType
    _max?: ProviderMaxAggregateInputType
  }

  export type ProviderGroupByOutputType = {
    id: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo: string | null
    coverImage: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains: string[]
    interopProtocols: $Enums.InteropProtocol[]
    serviceFee: JsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonValue
    zkProofSupport: $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework: $Enums.ComplianceFramework[]
    createdAt: Date
    updatedAt: Date
    _count: ProviderCountAggregateOutputType | null
    _avg: ProviderAvgAggregateOutputType | null
    _sum: ProviderSumAggregateOutputType | null
    _min: ProviderMinAggregateOutputType | null
    _max: ProviderMaxAggregateOutputType | null
  }

  type GetProviderGroupByPayload<T extends ProviderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderGroupByOutputType[P]>
        }
      >
    >


  export type ProviderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    email?: boolean
    rwaType?: boolean
    verificationLayer?: boolean
    interactionLayer?: boolean
    logo?: boolean
    coverImage?: boolean
    serviceVerificationType?: boolean
    chains?: boolean
    interopProtocols?: boolean
    serviceFee?: boolean
    authMethod?: boolean
    jwtSettings?: boolean
    zkProofSupport?: boolean
    privacyLevel?: boolean
    complianceFramework?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    services?: boolean | Provider$servicesArgs<ExtArgs>
    platformAccess?: boolean | Provider$platformAccessArgs<ExtArgs>
    contractPermissions?: boolean | Provider$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Provider$jwtTokensArgs<ExtArgs>
    serviceSubscriptions?: boolean | Provider$serviceSubscriptionsArgs<ExtArgs>
    platformAccessTokens?: boolean | Provider$platformAccessTokensArgs<ExtArgs>
    complianceAudits?: boolean | Provider$complianceAuditsArgs<ExtArgs>
    accessLogs?: boolean | Provider$accessLogsArgs<ExtArgs>
    ServicePermission?: boolean | Provider$ServicePermissionArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    email?: boolean
    rwaType?: boolean
    verificationLayer?: boolean
    interactionLayer?: boolean
    logo?: boolean
    coverImage?: boolean
    serviceVerificationType?: boolean
    chains?: boolean
    interopProtocols?: boolean
    serviceFee?: boolean
    authMethod?: boolean
    jwtSettings?: boolean
    zkProofSupport?: boolean
    privacyLevel?: boolean
    complianceFramework?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    serviceType?: boolean
    email?: boolean
    rwaType?: boolean
    verificationLayer?: boolean
    interactionLayer?: boolean
    logo?: boolean
    coverImage?: boolean
    serviceVerificationType?: boolean
    chains?: boolean
    interopProtocols?: boolean
    serviceFee?: boolean
    authMethod?: boolean
    jwtSettings?: boolean
    zkProofSupport?: boolean
    privacyLevel?: boolean
    complianceFramework?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["provider"]>

  export type ProviderSelectScalar = {
    id?: boolean
    name?: boolean
    serviceType?: boolean
    email?: boolean
    rwaType?: boolean
    verificationLayer?: boolean
    interactionLayer?: boolean
    logo?: boolean
    coverImage?: boolean
    serviceVerificationType?: boolean
    chains?: boolean
    interopProtocols?: boolean
    serviceFee?: boolean
    authMethod?: boolean
    jwtSettings?: boolean
    zkProofSupport?: boolean
    privacyLevel?: boolean
    complianceFramework?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProviderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "serviceType" | "email" | "rwaType" | "verificationLayer" | "interactionLayer" | "logo" | "coverImage" | "serviceVerificationType" | "chains" | "interopProtocols" | "serviceFee" | "authMethod" | "jwtSettings" | "zkProofSupport" | "privacyLevel" | "complianceFramework" | "createdAt" | "updatedAt", ExtArgs["result"]["provider"]>
  export type ProviderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    services?: boolean | Provider$servicesArgs<ExtArgs>
    platformAccess?: boolean | Provider$platformAccessArgs<ExtArgs>
    contractPermissions?: boolean | Provider$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Provider$jwtTokensArgs<ExtArgs>
    serviceSubscriptions?: boolean | Provider$serviceSubscriptionsArgs<ExtArgs>
    platformAccessTokens?: boolean | Provider$platformAccessTokensArgs<ExtArgs>
    complianceAudits?: boolean | Provider$complianceAuditsArgs<ExtArgs>
    accessLogs?: boolean | Provider$accessLogsArgs<ExtArgs>
    ServicePermission?: boolean | Provider$ServicePermissionArgs<ExtArgs>
    _count?: boolean | ProviderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ProviderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProviderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Provider"
    objects: {
      services: Prisma.$ServicePayload<ExtArgs>[]
      platformAccess: Prisma.$PlatformAccessPayload<ExtArgs>[]
      contractPermissions: Prisma.$ContractPermissionPayload<ExtArgs>[]
      jwtTokens: Prisma.$JWTTokenPayload<ExtArgs>[]
      serviceSubscriptions: Prisma.$ServiceSubscriptionPayload<ExtArgs>[]
      platformAccessTokens: Prisma.$PlatformAccessTokenPayload<ExtArgs>[]
      complianceAudits: Prisma.$ComplianceAuditPayload<ExtArgs>[]
      accessLogs: Prisma.$AccessLogPayload<ExtArgs>[]
      ServicePermission: Prisma.$ServicePermissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      serviceType: $Enums.ServiceType
      email: string
      rwaType: $Enums.RWAType
      verificationLayer: $Enums.VerificationLayer
      interactionLayer: $Enums.InteractionLayer
      logo: string | null
      coverImage: string | null
      serviceVerificationType: $Enums.ServiceVerificationType
      chains: string[]
      interopProtocols: $Enums.InteropProtocol[]
      serviceFee: Prisma.JsonValue
      authMethod: $Enums.AuthMethod
      jwtSettings: Prisma.JsonValue
      zkProofSupport: $Enums.ZKProofType[]
      privacyLevel: $Enums.PrivacyLevel
      complianceFramework: $Enums.ComplianceFramework[]
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["provider"]>
    composites: {}
  }

  type ProviderGetPayload<S extends boolean | null | undefined | ProviderDefaultArgs> = $Result.GetResult<Prisma.$ProviderPayload, S>

  type ProviderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderCountAggregateInputType | true
    }

  export interface ProviderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Provider'], meta: { name: 'Provider' } }
    /**
     * Find zero or one Provider that matches the filter.
     * @param {ProviderFindUniqueArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderFindUniqueArgs>(args: SelectSubset<T, ProviderFindUniqueArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Provider that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderFindUniqueOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderFindFirstArgs>(args?: SelectSubset<T, ProviderFindFirstArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Provider that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindFirstOrThrowArgs} args - Arguments to find a Provider
     * @example
     * // Get one Provider
     * const provider = await prisma.provider.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.provider.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.provider.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerWithIdOnly = await prisma.provider.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderFindManyArgs>(args?: SelectSubset<T, ProviderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Provider.
     * @param {ProviderCreateArgs} args - Arguments to create a Provider.
     * @example
     * // Create one Provider
     * const Provider = await prisma.provider.create({
     *   data: {
     *     // ... data to create a Provider
     *   }
     * })
     * 
     */
    create<T extends ProviderCreateArgs>(args: SelectSubset<T, ProviderCreateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {ProviderCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderCreateManyArgs>(args?: SelectSubset<T, ProviderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Providers and returns the data saved in the database.
     * @param {ProviderCreateManyAndReturnArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const provider = await prisma.provider.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Provider.
     * @param {ProviderDeleteArgs} args - Arguments to delete one Provider.
     * @example
     * // Delete one Provider
     * const Provider = await prisma.provider.delete({
     *   where: {
     *     // ... filter to delete one Provider
     *   }
     * })
     * 
     */
    delete<T extends ProviderDeleteArgs>(args: SelectSubset<T, ProviderDeleteArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Provider.
     * @param {ProviderUpdateArgs} args - Arguments to update one Provider.
     * @example
     * // Update one Provider
     * const provider = await prisma.provider.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderUpdateArgs>(args: SelectSubset<T, ProviderUpdateArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {ProviderDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.provider.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderDeleteManyArgs>(args?: SelectSubset<T, ProviderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderUpdateManyArgs>(args: SelectSubset<T, ProviderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers and returns the data updated in the database.
     * @param {ProviderUpdateManyAndReturnArgs} args - Arguments to update many Providers.
     * @example
     * // Update many Providers
     * const provider = await prisma.provider.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Providers and only return the `id`
     * const providerWithIdOnly = await prisma.provider.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Provider.
     * @param {ProviderUpsertArgs} args - Arguments to update or create a Provider.
     * @example
     * // Update or create a Provider
     * const provider = await prisma.provider.upsert({
     *   create: {
     *     // ... data to create a Provider
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Provider we want to update
     *   }
     * })
     */
    upsert<T extends ProviderUpsertArgs>(args: SelectSubset<T, ProviderUpsertArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.provider.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends ProviderCountArgs>(
      args?: Subset<T, ProviderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderAggregateArgs>(args: Subset<T, ProviderAggregateArgs>): Prisma.PrismaPromise<GetProviderAggregateType<T>>

    /**
     * Group by Provider.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderGroupByArgs['orderBy'] }
        : { orderBy?: ProviderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Provider model
   */
  readonly fields: ProviderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Provider.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    services<T extends Provider$servicesArgs<ExtArgs> = {}>(args?: Subset<T, Provider$servicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformAccess<T extends Provider$platformAccessArgs<ExtArgs> = {}>(args?: Subset<T, Provider$platformAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    contractPermissions<T extends Provider$contractPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$contractPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jwtTokens<T extends Provider$jwtTokensArgs<ExtArgs> = {}>(args?: Subset<T, Provider$jwtTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceSubscriptions<T extends Provider$serviceSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$serviceSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformAccessTokens<T extends Provider$platformAccessTokensArgs<ExtArgs> = {}>(args?: Subset<T, Provider$platformAccessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complianceAudits<T extends Provider$complianceAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$complianceAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accessLogs<T extends Provider$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, Provider$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    ServicePermission<T extends Provider$ServicePermissionArgs<ExtArgs> = {}>(args?: Subset<T, Provider$ServicePermissionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Provider model
   */
  interface ProviderFieldRefs {
    readonly id: FieldRef<"Provider", 'Int'>
    readonly name: FieldRef<"Provider", 'String'>
    readonly serviceType: FieldRef<"Provider", 'ServiceType'>
    readonly email: FieldRef<"Provider", 'String'>
    readonly rwaType: FieldRef<"Provider", 'RWAType'>
    readonly verificationLayer: FieldRef<"Provider", 'VerificationLayer'>
    readonly interactionLayer: FieldRef<"Provider", 'InteractionLayer'>
    readonly logo: FieldRef<"Provider", 'String'>
    readonly coverImage: FieldRef<"Provider", 'String'>
    readonly serviceVerificationType: FieldRef<"Provider", 'ServiceVerificationType'>
    readonly chains: FieldRef<"Provider", 'String[]'>
    readonly interopProtocols: FieldRef<"Provider", 'InteropProtocol[]'>
    readonly serviceFee: FieldRef<"Provider", 'Json'>
    readonly authMethod: FieldRef<"Provider", 'AuthMethod'>
    readonly jwtSettings: FieldRef<"Provider", 'Json'>
    readonly zkProofSupport: FieldRef<"Provider", 'ZKProofType[]'>
    readonly privacyLevel: FieldRef<"Provider", 'PrivacyLevel'>
    readonly complianceFramework: FieldRef<"Provider", 'ComplianceFramework[]'>
    readonly createdAt: FieldRef<"Provider", 'DateTime'>
    readonly updatedAt: FieldRef<"Provider", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Provider findUnique
   */
  export type ProviderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findUniqueOrThrow
   */
  export type ProviderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider findFirst
   */
  export type ProviderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findFirstOrThrow
   */
  export type ProviderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Provider to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Providers.
     */
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider findMany
   */
  export type ProviderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter, which Providers to fetch.
     */
    where?: ProviderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Providers to fetch.
     */
    orderBy?: ProviderOrderByWithRelationInput | ProviderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Providers.
     */
    cursor?: ProviderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Providers.
     */
    skip?: number
    distinct?: ProviderScalarFieldEnum | ProviderScalarFieldEnum[]
  }

  /**
   * Provider create
   */
  export type ProviderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to create a Provider.
     */
    data: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
  }

  /**
   * Provider createMany
   */
  export type ProviderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider createManyAndReturn
   */
  export type ProviderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to create many Providers.
     */
    data: ProviderCreateManyInput | ProviderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Provider update
   */
  export type ProviderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The data needed to update a Provider.
     */
    data: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
    /**
     * Choose, which Provider to update.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider updateMany
   */
  export type ProviderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider updateManyAndReturn
   */
  export type ProviderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * The data used to update Providers.
     */
    data: XOR<ProviderUpdateManyMutationInput, ProviderUncheckedUpdateManyInput>
    /**
     * Filter which Providers to update
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to update.
     */
    limit?: number
  }

  /**
   * Provider upsert
   */
  export type ProviderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * The filter to search for the Provider to update in case it exists.
     */
    where: ProviderWhereUniqueInput
    /**
     * In case the Provider found by the `where` argument doesn't exist, create a new Provider with this data.
     */
    create: XOR<ProviderCreateInput, ProviderUncheckedCreateInput>
    /**
     * In case the Provider was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderUpdateInput, ProviderUncheckedUpdateInput>
  }

  /**
   * Provider delete
   */
  export type ProviderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
    /**
     * Filter which Provider to delete.
     */
    where: ProviderWhereUniqueInput
  }

  /**
   * Provider deleteMany
   */
  export type ProviderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Providers to delete
     */
    where?: ProviderWhereInput
    /**
     * Limit how many Providers to delete.
     */
    limit?: number
  }

  /**
   * Provider.services
   */
  export type Provider$servicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    cursor?: ServiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Provider.platformAccess
   */
  export type Provider$platformAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    where?: PlatformAccessWhereInput
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    cursor?: PlatformAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformAccessScalarFieldEnum | PlatformAccessScalarFieldEnum[]
  }

  /**
   * Provider.contractPermissions
   */
  export type Provider$contractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    where?: ContractPermissionWhereInput
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    cursor?: ContractPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * Provider.jwtTokens
   */
  export type Provider$jwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    where?: JWTTokenWhereInput
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    cursor?: JWTTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * Provider.serviceSubscriptions
   */
  export type Provider$serviceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    where?: ServiceSubscriptionWhereInput
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    cursor?: ServiceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * Provider.platformAccessTokens
   */
  export type Provider$platformAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    where?: PlatformAccessTokenWhereInput
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    cursor?: PlatformAccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformAccessTokenScalarFieldEnum | PlatformAccessTokenScalarFieldEnum[]
  }

  /**
   * Provider.complianceAudits
   */
  export type Provider$complianceAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    where?: ComplianceAuditWhereInput
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    cursor?: ComplianceAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceAuditScalarFieldEnum | ComplianceAuditScalarFieldEnum[]
  }

  /**
   * Provider.accessLogs
   */
  export type Provider$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    cursor?: AccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * Provider.ServicePermission
   */
  export type Provider$ServicePermissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    where?: ServicePermissionWhereInput
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    cursor?: ServicePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * Provider without action
   */
  export type ProviderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Provider
     */
    select?: ProviderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Provider
     */
    omit?: ProviderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderInclude<ExtArgs> | null
  }


  /**
   * Model Service
   */

  export type AggregateService = {
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  export type ServiceAvgAggregateOutputType = {
    providerId: number | null
  }

  export type ServiceSumAggregateOutputType = {
    providerId: number | null
  }

  export type ServiceMinAggregateOutputType = {
    id: string | null
    providerId: number | null
    name: string | null
    description: string | null
    endpoint: string | null
    proofOfService: $Enums.ProofOfServiceType | null
    serviceCategory: $Enums.ServiceCategory | null
    authMethod: $Enums.AuthMethod | null
    accessLevel: $Enums.AccessLevel | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceMaxAggregateOutputType = {
    id: string | null
    providerId: number | null
    name: string | null
    description: string | null
    endpoint: string | null
    proofOfService: $Enums.ProofOfServiceType | null
    serviceCategory: $Enums.ServiceCategory | null
    authMethod: $Enums.AuthMethod | null
    accessLevel: $Enums.AccessLevel | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ServiceCountAggregateOutputType = {
    id: number
    providerId: number
    name: number
    description: number
    endpoint: number
    proofOfService: number
    serviceCategory: number
    authMethod: number
    accessLevel: number
    rateLimits: number
    zkRequirements: number
    complianceChecks: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ServiceAvgAggregateInputType = {
    providerId?: true
  }

  export type ServiceSumAggregateInputType = {
    providerId?: true
  }

  export type ServiceMinAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    endpoint?: true
    proofOfService?: true
    serviceCategory?: true
    authMethod?: true
    accessLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceMaxAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    endpoint?: true
    proofOfService?: true
    serviceCategory?: true
    authMethod?: true
    accessLevel?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ServiceCountAggregateInputType = {
    id?: true
    providerId?: true
    name?: true
    description?: true
    endpoint?: true
    proofOfService?: true
    serviceCategory?: true
    authMethod?: true
    accessLevel?: true
    rateLimits?: true
    zkRequirements?: true
    complianceChecks?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Service to aggregate.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Services
    **/
    _count?: true | ServiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceMaxAggregateInputType
  }

  export type GetServiceAggregateType<T extends ServiceAggregateArgs> = {
        [P in keyof T & keyof AggregateService]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateService[P]>
      : GetScalarType<T[P], AggregateService[P]>
  }




  export type ServiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceWhereInput
    orderBy?: ServiceOrderByWithAggregationInput | ServiceOrderByWithAggregationInput[]
    by: ServiceScalarFieldEnum[] | ServiceScalarFieldEnum
    having?: ServiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceCountAggregateInputType | true
    _avg?: ServiceAvgAggregateInputType
    _sum?: ServiceSumAggregateInputType
    _min?: ServiceMinAggregateInputType
    _max?: ServiceMaxAggregateInputType
  }

  export type ServiceGroupByOutputType = {
    id: string
    providerId: number
    name: string
    description: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonValue
    zkRequirements: JsonValue
    complianceChecks: JsonValue
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: ServiceCountAggregateOutputType | null
    _avg: ServiceAvgAggregateOutputType | null
    _sum: ServiceSumAggregateOutputType | null
    _min: ServiceMinAggregateOutputType | null
    _max: ServiceMaxAggregateOutputType | null
  }

  type GetServiceGroupByPayload<T extends ServiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    endpoint?: boolean
    proofOfService?: boolean
    serviceCategory?: boolean
    authMethod?: boolean
    accessLevel?: boolean
    rateLimits?: boolean
    zkRequirements?: boolean
    complianceChecks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contractPermissions?: boolean | Service$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Service$jwtTokensArgs<ExtArgs>
    serviceSubscriptions?: boolean | Service$serviceSubscriptionsArgs<ExtArgs>
    servicePermissions?: boolean | Service$servicePermissionsArgs<ExtArgs>
    accessLogs?: boolean | Service$accessLogsArgs<ExtArgs>
    complianceAudits?: boolean | Service$complianceAuditsArgs<ExtArgs>
    zkProofVerifications?: boolean | Service$zkProofVerificationsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    endpoint?: boolean
    proofOfService?: boolean
    serviceCategory?: boolean
    authMethod?: boolean
    accessLevel?: boolean
    rateLimits?: boolean
    zkRequirements?: boolean
    complianceChecks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    endpoint?: boolean
    proofOfService?: boolean
    serviceCategory?: boolean
    authMethod?: boolean
    accessLevel?: boolean
    rateLimits?: boolean
    zkRequirements?: boolean
    complianceChecks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["service"]>

  export type ServiceSelectScalar = {
    id?: boolean
    providerId?: boolean
    name?: boolean
    description?: boolean
    endpoint?: boolean
    proofOfService?: boolean
    serviceCategory?: boolean
    authMethod?: boolean
    accessLevel?: boolean
    rateLimits?: boolean
    zkRequirements?: boolean
    complianceChecks?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ServiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "name" | "description" | "endpoint" | "proofOfService" | "serviceCategory" | "authMethod" | "accessLevel" | "rateLimits" | "zkRequirements" | "complianceChecks" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["service"]>
  export type ServiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contractPermissions?: boolean | Service$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Service$jwtTokensArgs<ExtArgs>
    serviceSubscriptions?: boolean | Service$serviceSubscriptionsArgs<ExtArgs>
    servicePermissions?: boolean | Service$servicePermissionsArgs<ExtArgs>
    accessLogs?: boolean | Service$accessLogsArgs<ExtArgs>
    complianceAudits?: boolean | Service$complianceAuditsArgs<ExtArgs>
    zkProofVerifications?: boolean | Service$zkProofVerificationsArgs<ExtArgs>
    _count?: boolean | ServiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ServicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Service"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      contractPermissions: Prisma.$ContractPermissionPayload<ExtArgs>[]
      jwtTokens: Prisma.$JWTTokenPayload<ExtArgs>[]
      serviceSubscriptions: Prisma.$ServiceSubscriptionPayload<ExtArgs>[]
      servicePermissions: Prisma.$ServicePermissionPayload<ExtArgs>[]
      accessLogs: Prisma.$AccessLogPayload<ExtArgs>[]
      complianceAudits: Prisma.$ComplianceAuditPayload<ExtArgs>[]
      zkProofVerifications: Prisma.$ZKProofVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: number
      name: string
      description: string | null
      endpoint: string
      proofOfService: $Enums.ProofOfServiceType
      serviceCategory: $Enums.ServiceCategory
      authMethod: $Enums.AuthMethod
      accessLevel: $Enums.AccessLevel
      rateLimits: Prisma.JsonValue
      zkRequirements: Prisma.JsonValue
      complianceChecks: Prisma.JsonValue
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["service"]>
    composites: {}
  }

  type ServiceGetPayload<S extends boolean | null | undefined | ServiceDefaultArgs> = $Result.GetResult<Prisma.$ServicePayload, S>

  type ServiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceCountAggregateInputType | true
    }

  export interface ServiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Service'], meta: { name: 'Service' } }
    /**
     * Find zero or one Service that matches the filter.
     * @param {ServiceFindUniqueArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceFindUniqueArgs>(args: SelectSubset<T, ServiceFindUniqueArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Service that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceFindUniqueOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceFindFirstArgs>(args?: SelectSubset<T, ServiceFindFirstArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Service that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindFirstOrThrowArgs} args - Arguments to find a Service
     * @example
     * // Get one Service
     * const service = await prisma.service.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Services that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Services
     * const services = await prisma.service.findMany()
     * 
     * // Get first 10 Services
     * const services = await prisma.service.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceWithIdOnly = await prisma.service.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceFindManyArgs>(args?: SelectSubset<T, ServiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Service.
     * @param {ServiceCreateArgs} args - Arguments to create a Service.
     * @example
     * // Create one Service
     * const Service = await prisma.service.create({
     *   data: {
     *     // ... data to create a Service
     *   }
     * })
     * 
     */
    create<T extends ServiceCreateArgs>(args: SelectSubset<T, ServiceCreateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Services.
     * @param {ServiceCreateManyArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceCreateManyArgs>(args?: SelectSubset<T, ServiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Services and returns the data saved in the database.
     * @param {ServiceCreateManyAndReturnArgs} args - Arguments to create many Services.
     * @example
     * // Create many Services
     * const service = await prisma.service.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Service.
     * @param {ServiceDeleteArgs} args - Arguments to delete one Service.
     * @example
     * // Delete one Service
     * const Service = await prisma.service.delete({
     *   where: {
     *     // ... filter to delete one Service
     *   }
     * })
     * 
     */
    delete<T extends ServiceDeleteArgs>(args: SelectSubset<T, ServiceDeleteArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Service.
     * @param {ServiceUpdateArgs} args - Arguments to update one Service.
     * @example
     * // Update one Service
     * const service = await prisma.service.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceUpdateArgs>(args: SelectSubset<T, ServiceUpdateArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Services.
     * @param {ServiceDeleteManyArgs} args - Arguments to filter Services to delete.
     * @example
     * // Delete a few Services
     * const { count } = await prisma.service.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceDeleteManyArgs>(args?: SelectSubset<T, ServiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceUpdateManyArgs>(args: SelectSubset<T, ServiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Services and returns the data updated in the database.
     * @param {ServiceUpdateManyAndReturnArgs} args - Arguments to update many Services.
     * @example
     * // Update many Services
     * const service = await prisma.service.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Services and only return the `id`
     * const serviceWithIdOnly = await prisma.service.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Service.
     * @param {ServiceUpsertArgs} args - Arguments to update or create a Service.
     * @example
     * // Update or create a Service
     * const service = await prisma.service.upsert({
     *   create: {
     *     // ... data to create a Service
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Service we want to update
     *   }
     * })
     */
    upsert<T extends ServiceUpsertArgs>(args: SelectSubset<T, ServiceUpsertArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Services.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceCountArgs} args - Arguments to filter Services to count.
     * @example
     * // Count the number of Services
     * const count = await prisma.service.count({
     *   where: {
     *     // ... the filter for the Services we want to count
     *   }
     * })
    **/
    count<T extends ServiceCountArgs>(
      args?: Subset<T, ServiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceAggregateArgs>(args: Subset<T, ServiceAggregateArgs>): Prisma.PrismaPromise<GetServiceAggregateType<T>>

    /**
     * Group by Service.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceGroupByArgs['orderBy'] }
        : { orderBy?: ServiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Service model
   */
  readonly fields: ServiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Service.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contractPermissions<T extends Service$contractPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$contractPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jwtTokens<T extends Service$jwtTokensArgs<ExtArgs> = {}>(args?: Subset<T, Service$jwtTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceSubscriptions<T extends Service$serviceSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$serviceSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicePermissions<T extends Service$servicePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Service$servicePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accessLogs<T extends Service$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, Service$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    complianceAudits<T extends Service$complianceAuditsArgs<ExtArgs> = {}>(args?: Subset<T, Service$complianceAuditsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zkProofVerifications<T extends Service$zkProofVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, Service$zkProofVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Service model
   */
  interface ServiceFieldRefs {
    readonly id: FieldRef<"Service", 'String'>
    readonly providerId: FieldRef<"Service", 'Int'>
    readonly name: FieldRef<"Service", 'String'>
    readonly description: FieldRef<"Service", 'String'>
    readonly endpoint: FieldRef<"Service", 'String'>
    readonly proofOfService: FieldRef<"Service", 'ProofOfServiceType'>
    readonly serviceCategory: FieldRef<"Service", 'ServiceCategory'>
    readonly authMethod: FieldRef<"Service", 'AuthMethod'>
    readonly accessLevel: FieldRef<"Service", 'AccessLevel'>
    readonly rateLimits: FieldRef<"Service", 'Json'>
    readonly zkRequirements: FieldRef<"Service", 'Json'>
    readonly complianceChecks: FieldRef<"Service", 'Json'>
    readonly isActive: FieldRef<"Service", 'Boolean'>
    readonly createdAt: FieldRef<"Service", 'DateTime'>
    readonly updatedAt: FieldRef<"Service", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Service findUnique
   */
  export type ServiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findUniqueOrThrow
   */
  export type ServiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service findFirst
   */
  export type ServiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findFirstOrThrow
   */
  export type ServiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Service to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Services.
     */
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service findMany
   */
  export type ServiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter, which Services to fetch.
     */
    where?: ServiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Services to fetch.
     */
    orderBy?: ServiceOrderByWithRelationInput | ServiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Services.
     */
    cursor?: ServiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Services from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Services.
     */
    skip?: number
    distinct?: ServiceScalarFieldEnum | ServiceScalarFieldEnum[]
  }

  /**
   * Service create
   */
  export type ServiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Service.
     */
    data: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
  }

  /**
   * Service createMany
   */
  export type ServiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Service createManyAndReturn
   */
  export type ServiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to create many Services.
     */
    data: ServiceCreateManyInput | ServiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service update
   */
  export type ServiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Service.
     */
    data: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
    /**
     * Choose, which Service to update.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service updateMany
   */
  export type ServiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
  }

  /**
   * Service updateManyAndReturn
   */
  export type ServiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * The data used to update Services.
     */
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyInput>
    /**
     * Filter which Services to update
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Service upsert
   */
  export type ServiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Service to update in case it exists.
     */
    where: ServiceWhereUniqueInput
    /**
     * In case the Service found by the `where` argument doesn't exist, create a new Service with this data.
     */
    create: XOR<ServiceCreateInput, ServiceUncheckedCreateInput>
    /**
     * In case the Service was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceUpdateInput, ServiceUncheckedUpdateInput>
  }

  /**
   * Service delete
   */
  export type ServiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    /**
     * Filter which Service to delete.
     */
    where: ServiceWhereUniqueInput
  }

  /**
   * Service deleteMany
   */
  export type ServiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Services to delete
     */
    where?: ServiceWhereInput
    /**
     * Limit how many Services to delete.
     */
    limit?: number
  }

  /**
   * Service.contractPermissions
   */
  export type Service$contractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    where?: ContractPermissionWhereInput
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    cursor?: ContractPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * Service.jwtTokens
   */
  export type Service$jwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    where?: JWTTokenWhereInput
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    cursor?: JWTTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * Service.serviceSubscriptions
   */
  export type Service$serviceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    where?: ServiceSubscriptionWhereInput
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    cursor?: ServiceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * Service.servicePermissions
   */
  export type Service$servicePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    where?: ServicePermissionWhereInput
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    cursor?: ServicePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * Service.accessLogs
   */
  export type Service$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    cursor?: AccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * Service.complianceAudits
   */
  export type Service$complianceAuditsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    where?: ComplianceAuditWhereInput
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    cursor?: ComplianceAuditWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ComplianceAuditScalarFieldEnum | ComplianceAuditScalarFieldEnum[]
  }

  /**
   * Service.zkProofVerifications
   */
  export type Service$zkProofVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    where?: ZKProofVerificationWhereInput
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    cursor?: ZKProofVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZKProofVerificationScalarFieldEnum | ZKProofVerificationScalarFieldEnum[]
  }

  /**
   * Service without action
   */
  export type ServiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
  }


  /**
   * Model Platform
   */

  export type AggregatePlatform = {
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  export type PlatformMinAggregateOutputType = {
    id: string | null
    name: string | null
    platformType: $Enums.PlatformType | null
    email: string | null
    permissionLevel: $Enums.PermissionLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformMaxAggregateOutputType = {
    id: string | null
    name: string | null
    platformType: $Enums.PlatformType | null
    email: string | null
    permissionLevel: $Enums.PermissionLevel | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformCountAggregateOutputType = {
    id: number
    name: number
    platformType: number
    email: number
    permissionLevel: number
    zkCapabilities: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformMinAggregateInputType = {
    id?: true
    name?: true
    platformType?: true
    email?: true
    permissionLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformMaxAggregateInputType = {
    id?: true
    name?: true
    platformType?: true
    email?: true
    permissionLevel?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformCountAggregateInputType = {
    id?: true
    name?: true
    platformType?: true
    email?: true
    permissionLevel?: true
    zkCapabilities?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platform to aggregate.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Platforms
    **/
    _count?: true | PlatformCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformMaxAggregateInputType
  }

  export type GetPlatformAggregateType<T extends PlatformAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatform]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatform[P]>
      : GetScalarType<T[P], AggregatePlatform[P]>
  }




  export type PlatformGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformWhereInput
    orderBy?: PlatformOrderByWithAggregationInput | PlatformOrderByWithAggregationInput[]
    by: PlatformScalarFieldEnum[] | PlatformScalarFieldEnum
    having?: PlatformScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformCountAggregateInputType | true
    _min?: PlatformMinAggregateInputType
    _max?: PlatformMaxAggregateInputType
  }

  export type PlatformGroupByOutputType = {
    id: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonValue
    createdAt: Date
    updatedAt: Date
    _count: PlatformCountAggregateOutputType | null
    _min: PlatformMinAggregateOutputType | null
    _max: PlatformMaxAggregateOutputType | null
  }

  type GetPlatformGroupByPayload<T extends PlatformGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformGroupByOutputType[P]>
        }
      >
    >


  export type PlatformSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    platformType?: boolean
    email?: boolean
    permissionLevel?: boolean
    zkCapabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    contracts?: boolean | Platform$contractsArgs<ExtArgs>
    serviceSubscriptions?: boolean | Platform$serviceSubscriptionsArgs<ExtArgs>
    platformAccessTokens?: boolean | Platform$platformAccessTokensArgs<ExtArgs>
    platformAccess?: boolean | Platform$platformAccessArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    platformType?: boolean
    email?: boolean
    permissionLevel?: boolean
    zkCapabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    platformType?: boolean
    email?: boolean
    permissionLevel?: boolean
    zkCapabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["platform"]>

  export type PlatformSelectScalar = {
    id?: boolean
    name?: boolean
    platformType?: boolean
    email?: boolean
    permissionLevel?: boolean
    zkCapabilities?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "platformType" | "email" | "permissionLevel" | "zkCapabilities" | "createdAt" | "updatedAt", ExtArgs["result"]["platform"]>
  export type PlatformInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contracts?: boolean | Platform$contractsArgs<ExtArgs>
    serviceSubscriptions?: boolean | Platform$serviceSubscriptionsArgs<ExtArgs>
    platformAccessTokens?: boolean | Platform$platformAccessTokensArgs<ExtArgs>
    platformAccess?: boolean | Platform$platformAccessArgs<ExtArgs>
    _count?: boolean | PlatformCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PlatformIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PlatformIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PlatformPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Platform"
    objects: {
      contracts: Prisma.$ContractPayload<ExtArgs>[]
      serviceSubscriptions: Prisma.$ServiceSubscriptionPayload<ExtArgs>[]
      platformAccessTokens: Prisma.$PlatformAccessTokenPayload<ExtArgs>[]
      platformAccess: Prisma.$PlatformAccessPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      platformType: $Enums.PlatformType
      email: string
      permissionLevel: $Enums.PermissionLevel
      zkCapabilities: Prisma.JsonValue
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platform"]>
    composites: {}
  }

  type PlatformGetPayload<S extends boolean | null | undefined | PlatformDefaultArgs> = $Result.GetResult<Prisma.$PlatformPayload, S>

  type PlatformCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformCountAggregateInputType | true
    }

  export interface PlatformDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Platform'], meta: { name: 'Platform' } }
    /**
     * Find zero or one Platform that matches the filter.
     * @param {PlatformFindUniqueArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformFindUniqueArgs>(args: SelectSubset<T, PlatformFindUniqueArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Platform that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformFindUniqueOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformFindFirstArgs>(args?: SelectSubset<T, PlatformFindFirstArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Platform that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindFirstOrThrowArgs} args - Arguments to find a Platform
     * @example
     * // Get one Platform
     * const platform = await prisma.platform.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Platforms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Platforms
     * const platforms = await prisma.platform.findMany()
     * 
     * // Get first 10 Platforms
     * const platforms = await prisma.platform.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformWithIdOnly = await prisma.platform.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformFindManyArgs>(args?: SelectSubset<T, PlatformFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Platform.
     * @param {PlatformCreateArgs} args - Arguments to create a Platform.
     * @example
     * // Create one Platform
     * const Platform = await prisma.platform.create({
     *   data: {
     *     // ... data to create a Platform
     *   }
     * })
     * 
     */
    create<T extends PlatformCreateArgs>(args: SelectSubset<T, PlatformCreateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Platforms.
     * @param {PlatformCreateManyArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformCreateManyArgs>(args?: SelectSubset<T, PlatformCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Platforms and returns the data saved in the database.
     * @param {PlatformCreateManyAndReturnArgs} args - Arguments to create many Platforms.
     * @example
     * // Create many Platforms
     * const platform = await prisma.platform.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Platform.
     * @param {PlatformDeleteArgs} args - Arguments to delete one Platform.
     * @example
     * // Delete one Platform
     * const Platform = await prisma.platform.delete({
     *   where: {
     *     // ... filter to delete one Platform
     *   }
     * })
     * 
     */
    delete<T extends PlatformDeleteArgs>(args: SelectSubset<T, PlatformDeleteArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Platform.
     * @param {PlatformUpdateArgs} args - Arguments to update one Platform.
     * @example
     * // Update one Platform
     * const platform = await prisma.platform.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformUpdateArgs>(args: SelectSubset<T, PlatformUpdateArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Platforms.
     * @param {PlatformDeleteManyArgs} args - Arguments to filter Platforms to delete.
     * @example
     * // Delete a few Platforms
     * const { count } = await prisma.platform.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformDeleteManyArgs>(args?: SelectSubset<T, PlatformDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformUpdateManyArgs>(args: SelectSubset<T, PlatformUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Platforms and returns the data updated in the database.
     * @param {PlatformUpdateManyAndReturnArgs} args - Arguments to update many Platforms.
     * @example
     * // Update many Platforms
     * const platform = await prisma.platform.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Platforms and only return the `id`
     * const platformWithIdOnly = await prisma.platform.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Platform.
     * @param {PlatformUpsertArgs} args - Arguments to update or create a Platform.
     * @example
     * // Update or create a Platform
     * const platform = await prisma.platform.upsert({
     *   create: {
     *     // ... data to create a Platform
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Platform we want to update
     *   }
     * })
     */
    upsert<T extends PlatformUpsertArgs>(args: SelectSubset<T, PlatformUpsertArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Platforms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformCountArgs} args - Arguments to filter Platforms to count.
     * @example
     * // Count the number of Platforms
     * const count = await prisma.platform.count({
     *   where: {
     *     // ... the filter for the Platforms we want to count
     *   }
     * })
    **/
    count<T extends PlatformCountArgs>(
      args?: Subset<T, PlatformCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAggregateArgs>(args: Subset<T, PlatformAggregateArgs>): Prisma.PrismaPromise<GetPlatformAggregateType<T>>

    /**
     * Group by Platform.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformGroupByArgs['orderBy'] }
        : { orderBy?: PlatformGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Platform model
   */
  readonly fields: PlatformFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Platform.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contracts<T extends Platform$contractsArgs<ExtArgs> = {}>(args?: Subset<T, Platform$contractsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    serviceSubscriptions<T extends Platform$serviceSubscriptionsArgs<ExtArgs> = {}>(args?: Subset<T, Platform$serviceSubscriptionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformAccessTokens<T extends Platform$platformAccessTokensArgs<ExtArgs> = {}>(args?: Subset<T, Platform$platformAccessTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    platformAccess<T extends Platform$platformAccessArgs<ExtArgs> = {}>(args?: Subset<T, Platform$platformAccessArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Platform model
   */
  interface PlatformFieldRefs {
    readonly id: FieldRef<"Platform", 'String'>
    readonly name: FieldRef<"Platform", 'String'>
    readonly platformType: FieldRef<"Platform", 'PlatformType'>
    readonly email: FieldRef<"Platform", 'String'>
    readonly permissionLevel: FieldRef<"Platform", 'PermissionLevel'>
    readonly zkCapabilities: FieldRef<"Platform", 'Json'>
    readonly createdAt: FieldRef<"Platform", 'DateTime'>
    readonly updatedAt: FieldRef<"Platform", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Platform findUnique
   */
  export type PlatformFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findUniqueOrThrow
   */
  export type PlatformFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform findFirst
   */
  export type PlatformFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findFirstOrThrow
   */
  export type PlatformFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platform to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Platforms.
     */
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform findMany
   */
  export type PlatformFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter, which Platforms to fetch.
     */
    where?: PlatformWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Platforms to fetch.
     */
    orderBy?: PlatformOrderByWithRelationInput | PlatformOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Platforms.
     */
    cursor?: PlatformWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Platforms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Platforms.
     */
    skip?: number
    distinct?: PlatformScalarFieldEnum | PlatformScalarFieldEnum[]
  }

  /**
   * Platform create
   */
  export type PlatformCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to create a Platform.
     */
    data: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
  }

  /**
   * Platform createMany
   */
  export type PlatformCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform createManyAndReturn
   */
  export type PlatformCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to create many Platforms.
     */
    data: PlatformCreateManyInput | PlatformCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Platform update
   */
  export type PlatformUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The data needed to update a Platform.
     */
    data: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
    /**
     * Choose, which Platform to update.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform updateMany
   */
  export type PlatformUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform updateManyAndReturn
   */
  export type PlatformUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * The data used to update Platforms.
     */
    data: XOR<PlatformUpdateManyMutationInput, PlatformUncheckedUpdateManyInput>
    /**
     * Filter which Platforms to update
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to update.
     */
    limit?: number
  }

  /**
   * Platform upsert
   */
  export type PlatformUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * The filter to search for the Platform to update in case it exists.
     */
    where: PlatformWhereUniqueInput
    /**
     * In case the Platform found by the `where` argument doesn't exist, create a new Platform with this data.
     */
    create: XOR<PlatformCreateInput, PlatformUncheckedCreateInput>
    /**
     * In case the Platform was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformUpdateInput, PlatformUncheckedUpdateInput>
  }

  /**
   * Platform delete
   */
  export type PlatformDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
    /**
     * Filter which Platform to delete.
     */
    where: PlatformWhereUniqueInput
  }

  /**
   * Platform deleteMany
   */
  export type PlatformDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Platforms to delete
     */
    where?: PlatformWhereInput
    /**
     * Limit how many Platforms to delete.
     */
    limit?: number
  }

  /**
   * Platform.contracts
   */
  export type Platform$contractsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    cursor?: ContractWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Platform.serviceSubscriptions
   */
  export type Platform$serviceSubscriptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    where?: ServiceSubscriptionWhereInput
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    cursor?: ServiceSubscriptionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * Platform.platformAccessTokens
   */
  export type Platform$platformAccessTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    where?: PlatformAccessTokenWhereInput
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    cursor?: PlatformAccessTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformAccessTokenScalarFieldEnum | PlatformAccessTokenScalarFieldEnum[]
  }

  /**
   * Platform.platformAccess
   */
  export type Platform$platformAccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    where?: PlatformAccessWhereInput
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    cursor?: PlatformAccessWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PlatformAccessScalarFieldEnum | PlatformAccessScalarFieldEnum[]
  }

  /**
   * Platform without action
   */
  export type PlatformDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Platform
     */
    select?: PlatformSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Platform
     */
    omit?: PlatformOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformInclude<ExtArgs> | null
  }


  /**
   * Model Contract
   */

  export type AggregateContract = {
    _count: ContractCountAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  export type ContractMinAggregateOutputType = {
    id: string | null
    platformId: string | null
    name: string | null
    chain: string | null
    address: string | null
    complianceStatus: $Enums.ComplianceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractMaxAggregateOutputType = {
    id: string | null
    platformId: string | null
    name: string | null
    chain: string | null
    address: string | null
    complianceStatus: $Enums.ComplianceStatus | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ContractCountAggregateOutputType = {
    id: number
    platformId: number
    name: number
    chain: number
    address: number
    abi: number
    zkProofRequirements: number
    complianceStatus: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ContractMinAggregateInputType = {
    id?: true
    platformId?: true
    name?: true
    chain?: true
    address?: true
    complianceStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractMaxAggregateInputType = {
    id?: true
    platformId?: true
    name?: true
    chain?: true
    address?: true
    complianceStatus?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ContractCountAggregateInputType = {
    id?: true
    platformId?: true
    name?: true
    chain?: true
    address?: true
    abi?: true
    zkProofRequirements?: true
    complianceStatus?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ContractAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contract to aggregate.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Contracts
    **/
    _count?: true | ContractCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractMaxAggregateInputType
  }

  export type GetContractAggregateType<T extends ContractAggregateArgs> = {
        [P in keyof T & keyof AggregateContract]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContract[P]>
      : GetScalarType<T[P], AggregateContract[P]>
  }




  export type ContractGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractWhereInput
    orderBy?: ContractOrderByWithAggregationInput | ContractOrderByWithAggregationInput[]
    by: ContractScalarFieldEnum[] | ContractScalarFieldEnum
    having?: ContractScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractCountAggregateInputType | true
    _min?: ContractMinAggregateInputType
    _max?: ContractMaxAggregateInputType
  }

  export type ContractGroupByOutputType = {
    id: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonValue
    zkProofRequirements: JsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt: Date
    updatedAt: Date
    _count: ContractCountAggregateOutputType | null
    _min: ContractMinAggregateOutputType | null
    _max: ContractMaxAggregateOutputType | null
  }

  type GetContractGroupByPayload<T extends ContractGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractGroupByOutputType[P]>
            : GetScalarType<T[P], ContractGroupByOutputType[P]>
        }
      >
    >


  export type ContractSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    name?: boolean
    chain?: boolean
    address?: boolean
    abi?: boolean
    zkProofRequirements?: boolean
    complianceStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    contractPermissions?: boolean | Contract$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Contract$jwtTokensArgs<ExtArgs>
    servicePermissions?: boolean | Contract$servicePermissionsArgs<ExtArgs>
    accessLogs?: boolean | Contract$accessLogsArgs<ExtArgs>
    zkProofVerifications?: boolean | Contract$zkProofVerificationsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    name?: boolean
    chain?: boolean
    address?: boolean
    abi?: boolean
    zkProofRequirements?: boolean
    complianceStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    name?: boolean
    chain?: boolean
    address?: boolean
    abi?: boolean
    zkProofRequirements?: boolean
    complianceStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contract"]>

  export type ContractSelectScalar = {
    id?: boolean
    platformId?: boolean
    name?: boolean
    chain?: boolean
    address?: boolean
    abi?: boolean
    zkProofRequirements?: boolean
    complianceStatus?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ContractOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platformId" | "name" | "chain" | "address" | "abi" | "zkProofRequirements" | "complianceStatus" | "createdAt" | "updatedAt", ExtArgs["result"]["contract"]>
  export type ContractInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    contractPermissions?: boolean | Contract$contractPermissionsArgs<ExtArgs>
    jwtTokens?: boolean | Contract$jwtTokensArgs<ExtArgs>
    servicePermissions?: boolean | Contract$servicePermissionsArgs<ExtArgs>
    accessLogs?: boolean | Contract$accessLogsArgs<ExtArgs>
    zkProofVerifications?: boolean | Contract$zkProofVerificationsArgs<ExtArgs>
    _count?: boolean | ContractCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ContractIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }
  export type ContractIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }

  export type $ContractPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Contract"
    objects: {
      platform: Prisma.$PlatformPayload<ExtArgs>
      contractPermissions: Prisma.$ContractPermissionPayload<ExtArgs>[]
      jwtTokens: Prisma.$JWTTokenPayload<ExtArgs>[]
      servicePermissions: Prisma.$ServicePermissionPayload<ExtArgs>[]
      accessLogs: Prisma.$AccessLogPayload<ExtArgs>[]
      zkProofVerifications: Prisma.$ZKProofVerificationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platformId: string
      name: string
      chain: string
      address: string
      abi: Prisma.JsonValue
      zkProofRequirements: Prisma.JsonValue
      complianceStatus: $Enums.ComplianceStatus
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["contract"]>
    composites: {}
  }

  type ContractGetPayload<S extends boolean | null | undefined | ContractDefaultArgs> = $Result.GetResult<Prisma.$ContractPayload, S>

  type ContractCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractCountAggregateInputType | true
    }

  export interface ContractDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Contract'], meta: { name: 'Contract' } }
    /**
     * Find zero or one Contract that matches the filter.
     * @param {ContractFindUniqueArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractFindUniqueArgs>(args: SelectSubset<T, ContractFindUniqueArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Contract that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractFindUniqueOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractFindFirstArgs>(args?: SelectSubset<T, ContractFindFirstArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Contract that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindFirstOrThrowArgs} args - Arguments to find a Contract
     * @example
     * // Get one Contract
     * const contract = await prisma.contract.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Contracts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Contracts
     * const contracts = await prisma.contract.findMany()
     * 
     * // Get first 10 Contracts
     * const contracts = await prisma.contract.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractWithIdOnly = await prisma.contract.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractFindManyArgs>(args?: SelectSubset<T, ContractFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Contract.
     * @param {ContractCreateArgs} args - Arguments to create a Contract.
     * @example
     * // Create one Contract
     * const Contract = await prisma.contract.create({
     *   data: {
     *     // ... data to create a Contract
     *   }
     * })
     * 
     */
    create<T extends ContractCreateArgs>(args: SelectSubset<T, ContractCreateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Contracts.
     * @param {ContractCreateManyArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractCreateManyArgs>(args?: SelectSubset<T, ContractCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Contracts and returns the data saved in the database.
     * @param {ContractCreateManyAndReturnArgs} args - Arguments to create many Contracts.
     * @example
     * // Create many Contracts
     * const contract = await prisma.contract.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Contract.
     * @param {ContractDeleteArgs} args - Arguments to delete one Contract.
     * @example
     * // Delete one Contract
     * const Contract = await prisma.contract.delete({
     *   where: {
     *     // ... filter to delete one Contract
     *   }
     * })
     * 
     */
    delete<T extends ContractDeleteArgs>(args: SelectSubset<T, ContractDeleteArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Contract.
     * @param {ContractUpdateArgs} args - Arguments to update one Contract.
     * @example
     * // Update one Contract
     * const contract = await prisma.contract.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractUpdateArgs>(args: SelectSubset<T, ContractUpdateArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Contracts.
     * @param {ContractDeleteManyArgs} args - Arguments to filter Contracts to delete.
     * @example
     * // Delete a few Contracts
     * const { count } = await prisma.contract.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractDeleteManyArgs>(args?: SelectSubset<T, ContractDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractUpdateManyArgs>(args: SelectSubset<T, ContractUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Contracts and returns the data updated in the database.
     * @param {ContractUpdateManyAndReturnArgs} args - Arguments to update many Contracts.
     * @example
     * // Update many Contracts
     * const contract = await prisma.contract.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Contracts and only return the `id`
     * const contractWithIdOnly = await prisma.contract.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Contract.
     * @param {ContractUpsertArgs} args - Arguments to update or create a Contract.
     * @example
     * // Update or create a Contract
     * const contract = await prisma.contract.upsert({
     *   create: {
     *     // ... data to create a Contract
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Contract we want to update
     *   }
     * })
     */
    upsert<T extends ContractUpsertArgs>(args: SelectSubset<T, ContractUpsertArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Contracts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractCountArgs} args - Arguments to filter Contracts to count.
     * @example
     * // Count the number of Contracts
     * const count = await prisma.contract.count({
     *   where: {
     *     // ... the filter for the Contracts we want to count
     *   }
     * })
    **/
    count<T extends ContractCountArgs>(
      args?: Subset<T, ContractCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractAggregateArgs>(args: Subset<T, ContractAggregateArgs>): Prisma.PrismaPromise<GetContractAggregateType<T>>

    /**
     * Group by Contract.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractGroupByArgs['orderBy'] }
        : { orderBy?: ContractGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Contract model
   */
  readonly fields: ContractFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Contract.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contractPermissions<T extends Contract$contractPermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$contractPermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    jwtTokens<T extends Contract$jwtTokensArgs<ExtArgs> = {}>(args?: Subset<T, Contract$jwtTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    servicePermissions<T extends Contract$servicePermissionsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$servicePermissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    accessLogs<T extends Contract$accessLogsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$accessLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    zkProofVerifications<T extends Contract$zkProofVerificationsArgs<ExtArgs> = {}>(args?: Subset<T, Contract$zkProofVerificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Contract model
   */
  interface ContractFieldRefs {
    readonly id: FieldRef<"Contract", 'String'>
    readonly platformId: FieldRef<"Contract", 'String'>
    readonly name: FieldRef<"Contract", 'String'>
    readonly chain: FieldRef<"Contract", 'String'>
    readonly address: FieldRef<"Contract", 'String'>
    readonly abi: FieldRef<"Contract", 'Json'>
    readonly zkProofRequirements: FieldRef<"Contract", 'Json'>
    readonly complianceStatus: FieldRef<"Contract", 'ComplianceStatus'>
    readonly createdAt: FieldRef<"Contract", 'DateTime'>
    readonly updatedAt: FieldRef<"Contract", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Contract findUnique
   */
  export type ContractFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findUniqueOrThrow
   */
  export type ContractFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract findFirst
   */
  export type ContractFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findFirstOrThrow
   */
  export type ContractFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contract to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Contracts.
     */
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract findMany
   */
  export type ContractFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter, which Contracts to fetch.
     */
    where?: ContractWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Contracts to fetch.
     */
    orderBy?: ContractOrderByWithRelationInput | ContractOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Contracts.
     */
    cursor?: ContractWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Contracts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Contracts.
     */
    skip?: number
    distinct?: ContractScalarFieldEnum | ContractScalarFieldEnum[]
  }

  /**
   * Contract create
   */
  export type ContractCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to create a Contract.
     */
    data: XOR<ContractCreateInput, ContractUncheckedCreateInput>
  }

  /**
   * Contract createMany
   */
  export type ContractCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Contract createManyAndReturn
   */
  export type ContractCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to create many Contracts.
     */
    data: ContractCreateManyInput | ContractCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract update
   */
  export type ContractUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The data needed to update a Contract.
     */
    data: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
    /**
     * Choose, which Contract to update.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract updateMany
   */
  export type ContractUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
  }

  /**
   * Contract updateManyAndReturn
   */
  export type ContractUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * The data used to update Contracts.
     */
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyInput>
    /**
     * Filter which Contracts to update
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Contract upsert
   */
  export type ContractUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * The filter to search for the Contract to update in case it exists.
     */
    where: ContractWhereUniqueInput
    /**
     * In case the Contract found by the `where` argument doesn't exist, create a new Contract with this data.
     */
    create: XOR<ContractCreateInput, ContractUncheckedCreateInput>
    /**
     * In case the Contract was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractUpdateInput, ContractUncheckedUpdateInput>
  }

  /**
   * Contract delete
   */
  export type ContractDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    /**
     * Filter which Contract to delete.
     */
    where: ContractWhereUniqueInput
  }

  /**
   * Contract deleteMany
   */
  export type ContractDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Contracts to delete
     */
    where?: ContractWhereInput
    /**
     * Limit how many Contracts to delete.
     */
    limit?: number
  }

  /**
   * Contract.contractPermissions
   */
  export type Contract$contractPermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    where?: ContractPermissionWhereInput
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    cursor?: ContractPermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * Contract.jwtTokens
   */
  export type Contract$jwtTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    where?: JWTTokenWhereInput
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    cursor?: JWTTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * Contract.servicePermissions
   */
  export type Contract$servicePermissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    where?: ServicePermissionWhereInput
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    cursor?: ServicePermissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * Contract.accessLogs
   */
  export type Contract$accessLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    cursor?: AccessLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * Contract.zkProofVerifications
   */
  export type Contract$zkProofVerificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    where?: ZKProofVerificationWhereInput
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    cursor?: ZKProofVerificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ZKProofVerificationScalarFieldEnum | ZKProofVerificationScalarFieldEnum[]
  }

  /**
   * Contract without action
   */
  export type ContractDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
  }


  /**
   * Model PlatformAccess
   */

  export type AggregatePlatformAccess = {
    _count: PlatformAccessCountAggregateOutputType | null
    _avg: PlatformAccessAvgAggregateOutputType | null
    _sum: PlatformAccessSumAggregateOutputType | null
    _min: PlatformAccessMinAggregateOutputType | null
    _max: PlatformAccessMaxAggregateOutputType | null
  }

  export type PlatformAccessAvgAggregateOutputType = {
    providerId: number | null
  }

  export type PlatformAccessSumAggregateOutputType = {
    providerId: number | null
  }

  export type PlatformAccessMinAggregateOutputType = {
    id: string | null
    providerId: number | null
    platformId: string | null
    accessType: $Enums.AccessType | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformAccessMaxAggregateOutputType = {
    id: string | null
    providerId: number | null
    platformId: string | null
    accessType: $Enums.AccessType | null
    expiresAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PlatformAccessCountAggregateOutputType = {
    id: number
    providerId: number
    platformId: number
    grantedServices: number
    accessType: number
    permissions: number
    expiresAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PlatformAccessAvgAggregateInputType = {
    providerId?: true
  }

  export type PlatformAccessSumAggregateInputType = {
    providerId?: true
  }

  export type PlatformAccessMinAggregateInputType = {
    id?: true
    providerId?: true
    platformId?: true
    accessType?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformAccessMaxAggregateInputType = {
    id?: true
    providerId?: true
    platformId?: true
    accessType?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PlatformAccessCountAggregateInputType = {
    id?: true
    providerId?: true
    platformId?: true
    grantedServices?: true
    accessType?: true
    permissions?: true
    expiresAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PlatformAccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAccess to aggregate.
     */
    where?: PlatformAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccesses to fetch.
     */
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformAccesses
    **/
    _count?: true | PlatformAccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformAccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformAccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformAccessMaxAggregateInputType
  }

  export type GetPlatformAccessAggregateType<T extends PlatformAccessAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformAccess[P]>
      : GetScalarType<T[P], AggregatePlatformAccess[P]>
  }




  export type PlatformAccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessWhereInput
    orderBy?: PlatformAccessOrderByWithAggregationInput | PlatformAccessOrderByWithAggregationInput[]
    by: PlatformAccessScalarFieldEnum[] | PlatformAccessScalarFieldEnum
    having?: PlatformAccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformAccessCountAggregateInputType | true
    _avg?: PlatformAccessAvgAggregateInputType
    _sum?: PlatformAccessSumAggregateInputType
    _min?: PlatformAccessMinAggregateInputType
    _max?: PlatformAccessMaxAggregateInputType
  }

  export type PlatformAccessGroupByOutputType = {
    id: string
    providerId: number
    platformId: string
    grantedServices: string[]
    accessType: $Enums.AccessType
    permissions: JsonValue
    expiresAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: PlatformAccessCountAggregateOutputType | null
    _avg: PlatformAccessAvgAggregateOutputType | null
    _sum: PlatformAccessSumAggregateOutputType | null
    _min: PlatformAccessMinAggregateOutputType | null
    _max: PlatformAccessMaxAggregateOutputType | null
  }

  type GetPlatformAccessGroupByPayload<T extends PlatformAccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformAccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformAccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformAccessGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformAccessGroupByOutputType[P]>
        }
      >
    >


  export type PlatformAccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    platformId?: boolean
    grantedServices?: boolean
    accessType?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccess"]>

  export type PlatformAccessSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    platformId?: boolean
    grantedServices?: boolean
    accessType?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccess"]>

  export type PlatformAccessSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    platformId?: boolean
    grantedServices?: boolean
    accessType?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccess"]>

  export type PlatformAccessSelectScalar = {
    id?: boolean
    providerId?: boolean
    platformId?: boolean
    grantedServices?: boolean
    accessType?: boolean
    permissions?: boolean
    expiresAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PlatformAccessOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "platformId" | "grantedServices" | "accessType" | "permissions" | "expiresAt" | "isActive" | "createdAt" | "updatedAt", ExtArgs["result"]["platformAccess"]>
  export type PlatformAccessInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }
  export type PlatformAccessIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }
  export type PlatformAccessIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
  }

  export type $PlatformAccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformAccess"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      platform: Prisma.$PlatformPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: number
      platformId: string
      grantedServices: string[]
      accessType: $Enums.AccessType
      permissions: Prisma.JsonValue
      expiresAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["platformAccess"]>
    composites: {}
  }

  type PlatformAccessGetPayload<S extends boolean | null | undefined | PlatformAccessDefaultArgs> = $Result.GetResult<Prisma.$PlatformAccessPayload, S>

  type PlatformAccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformAccessFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformAccessCountAggregateInputType | true
    }

  export interface PlatformAccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformAccess'], meta: { name: 'PlatformAccess' } }
    /**
     * Find zero or one PlatformAccess that matches the filter.
     * @param {PlatformAccessFindUniqueArgs} args - Arguments to find a PlatformAccess
     * @example
     * // Get one PlatformAccess
     * const platformAccess = await prisma.platformAccess.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformAccessFindUniqueArgs>(args: SelectSubset<T, PlatformAccessFindUniqueArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformAccess that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformAccessFindUniqueOrThrowArgs} args - Arguments to find a PlatformAccess
     * @example
     * // Get one PlatformAccess
     * const platformAccess = await prisma.platformAccess.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformAccessFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformAccessFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAccess that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessFindFirstArgs} args - Arguments to find a PlatformAccess
     * @example
     * // Get one PlatformAccess
     * const platformAccess = await prisma.platformAccess.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformAccessFindFirstArgs>(args?: SelectSubset<T, PlatformAccessFindFirstArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAccess that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessFindFirstOrThrowArgs} args - Arguments to find a PlatformAccess
     * @example
     * // Get one PlatformAccess
     * const platformAccess = await prisma.platformAccess.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformAccessFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformAccessFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformAccesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformAccesses
     * const platformAccesses = await prisma.platformAccess.findMany()
     * 
     * // Get first 10 PlatformAccesses
     * const platformAccesses = await prisma.platformAccess.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformAccessWithIdOnly = await prisma.platformAccess.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformAccessFindManyArgs>(args?: SelectSubset<T, PlatformAccessFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformAccess.
     * @param {PlatformAccessCreateArgs} args - Arguments to create a PlatformAccess.
     * @example
     * // Create one PlatformAccess
     * const PlatformAccess = await prisma.platformAccess.create({
     *   data: {
     *     // ... data to create a PlatformAccess
     *   }
     * })
     * 
     */
    create<T extends PlatformAccessCreateArgs>(args: SelectSubset<T, PlatformAccessCreateArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformAccesses.
     * @param {PlatformAccessCreateManyArgs} args - Arguments to create many PlatformAccesses.
     * @example
     * // Create many PlatformAccesses
     * const platformAccess = await prisma.platformAccess.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformAccessCreateManyArgs>(args?: SelectSubset<T, PlatformAccessCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformAccesses and returns the data saved in the database.
     * @param {PlatformAccessCreateManyAndReturnArgs} args - Arguments to create many PlatformAccesses.
     * @example
     * // Create many PlatformAccesses
     * const platformAccess = await prisma.platformAccess.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformAccesses and only return the `id`
     * const platformAccessWithIdOnly = await prisma.platformAccess.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformAccessCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformAccessCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformAccess.
     * @param {PlatformAccessDeleteArgs} args - Arguments to delete one PlatformAccess.
     * @example
     * // Delete one PlatformAccess
     * const PlatformAccess = await prisma.platformAccess.delete({
     *   where: {
     *     // ... filter to delete one PlatformAccess
     *   }
     * })
     * 
     */
    delete<T extends PlatformAccessDeleteArgs>(args: SelectSubset<T, PlatformAccessDeleteArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformAccess.
     * @param {PlatformAccessUpdateArgs} args - Arguments to update one PlatformAccess.
     * @example
     * // Update one PlatformAccess
     * const platformAccess = await prisma.platformAccess.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformAccessUpdateArgs>(args: SelectSubset<T, PlatformAccessUpdateArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformAccesses.
     * @param {PlatformAccessDeleteManyArgs} args - Arguments to filter PlatformAccesses to delete.
     * @example
     * // Delete a few PlatformAccesses
     * const { count } = await prisma.platformAccess.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformAccessDeleteManyArgs>(args?: SelectSubset<T, PlatformAccessDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformAccesses
     * const platformAccess = await prisma.platformAccess.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformAccessUpdateManyArgs>(args: SelectSubset<T, PlatformAccessUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAccesses and returns the data updated in the database.
     * @param {PlatformAccessUpdateManyAndReturnArgs} args - Arguments to update many PlatformAccesses.
     * @example
     * // Update many PlatformAccesses
     * const platformAccess = await prisma.platformAccess.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformAccesses and only return the `id`
     * const platformAccessWithIdOnly = await prisma.platformAccess.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformAccessUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformAccessUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformAccess.
     * @param {PlatformAccessUpsertArgs} args - Arguments to update or create a PlatformAccess.
     * @example
     * // Update or create a PlatformAccess
     * const platformAccess = await prisma.platformAccess.upsert({
     *   create: {
     *     // ... data to create a PlatformAccess
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformAccess we want to update
     *   }
     * })
     */
    upsert<T extends PlatformAccessUpsertArgs>(args: SelectSubset<T, PlatformAccessUpsertArgs<ExtArgs>>): Prisma__PlatformAccessClient<$Result.GetResult<Prisma.$PlatformAccessPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformAccesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessCountArgs} args - Arguments to filter PlatformAccesses to count.
     * @example
     * // Count the number of PlatformAccesses
     * const count = await prisma.platformAccess.count({
     *   where: {
     *     // ... the filter for the PlatformAccesses we want to count
     *   }
     * })
    **/
    count<T extends PlatformAccessCountArgs>(
      args?: Subset<T, PlatformAccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformAccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAccessAggregateArgs>(args: Subset<T, PlatformAccessAggregateArgs>): Prisma.PrismaPromise<GetPlatformAccessAggregateType<T>>

    /**
     * Group by PlatformAccess.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformAccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformAccessGroupByArgs['orderBy'] }
        : { orderBy?: PlatformAccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformAccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformAccess model
   */
  readonly fields: PlatformAccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformAccess.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformAccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformAccess model
   */
  interface PlatformAccessFieldRefs {
    readonly id: FieldRef<"PlatformAccess", 'String'>
    readonly providerId: FieldRef<"PlatformAccess", 'Int'>
    readonly platformId: FieldRef<"PlatformAccess", 'String'>
    readonly grantedServices: FieldRef<"PlatformAccess", 'String[]'>
    readonly accessType: FieldRef<"PlatformAccess", 'AccessType'>
    readonly permissions: FieldRef<"PlatformAccess", 'Json'>
    readonly expiresAt: FieldRef<"PlatformAccess", 'DateTime'>
    readonly isActive: FieldRef<"PlatformAccess", 'Boolean'>
    readonly createdAt: FieldRef<"PlatformAccess", 'DateTime'>
    readonly updatedAt: FieldRef<"PlatformAccess", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PlatformAccess findUnique
   */
  export type PlatformAccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccess to fetch.
     */
    where: PlatformAccessWhereUniqueInput
  }

  /**
   * PlatformAccess findUniqueOrThrow
   */
  export type PlatformAccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccess to fetch.
     */
    where: PlatformAccessWhereUniqueInput
  }

  /**
   * PlatformAccess findFirst
   */
  export type PlatformAccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccess to fetch.
     */
    where?: PlatformAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccesses to fetch.
     */
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAccesses.
     */
    cursor?: PlatformAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAccesses.
     */
    distinct?: PlatformAccessScalarFieldEnum | PlatformAccessScalarFieldEnum[]
  }

  /**
   * PlatformAccess findFirstOrThrow
   */
  export type PlatformAccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccess to fetch.
     */
    where?: PlatformAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccesses to fetch.
     */
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAccesses.
     */
    cursor?: PlatformAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAccesses.
     */
    distinct?: PlatformAccessScalarFieldEnum | PlatformAccessScalarFieldEnum[]
  }

  /**
   * PlatformAccess findMany
   */
  export type PlatformAccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccesses to fetch.
     */
    where?: PlatformAccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccesses to fetch.
     */
    orderBy?: PlatformAccessOrderByWithRelationInput | PlatformAccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformAccesses.
     */
    cursor?: PlatformAccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccesses.
     */
    skip?: number
    distinct?: PlatformAccessScalarFieldEnum | PlatformAccessScalarFieldEnum[]
  }

  /**
   * PlatformAccess create
   */
  export type PlatformAccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformAccess.
     */
    data: XOR<PlatformAccessCreateInput, PlatformAccessUncheckedCreateInput>
  }

  /**
   * PlatformAccess createMany
   */
  export type PlatformAccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformAccesses.
     */
    data: PlatformAccessCreateManyInput | PlatformAccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformAccess createManyAndReturn
   */
  export type PlatformAccessCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformAccesses.
     */
    data: PlatformAccessCreateManyInput | PlatformAccessCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAccess update
   */
  export type PlatformAccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformAccess.
     */
    data: XOR<PlatformAccessUpdateInput, PlatformAccessUncheckedUpdateInput>
    /**
     * Choose, which PlatformAccess to update.
     */
    where: PlatformAccessWhereUniqueInput
  }

  /**
   * PlatformAccess updateMany
   */
  export type PlatformAccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformAccesses.
     */
    data: XOR<PlatformAccessUpdateManyMutationInput, PlatformAccessUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAccesses to update
     */
    where?: PlatformAccessWhereInput
    /**
     * Limit how many PlatformAccesses to update.
     */
    limit?: number
  }

  /**
   * PlatformAccess updateManyAndReturn
   */
  export type PlatformAccessUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * The data used to update PlatformAccesses.
     */
    data: XOR<PlatformAccessUpdateManyMutationInput, PlatformAccessUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAccesses to update
     */
    where?: PlatformAccessWhereInput
    /**
     * Limit how many PlatformAccesses to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAccess upsert
   */
  export type PlatformAccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformAccess to update in case it exists.
     */
    where: PlatformAccessWhereUniqueInput
    /**
     * In case the PlatformAccess found by the `where` argument doesn't exist, create a new PlatformAccess with this data.
     */
    create: XOR<PlatformAccessCreateInput, PlatformAccessUncheckedCreateInput>
    /**
     * In case the PlatformAccess was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformAccessUpdateInput, PlatformAccessUncheckedUpdateInput>
  }

  /**
   * PlatformAccess delete
   */
  export type PlatformAccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
    /**
     * Filter which PlatformAccess to delete.
     */
    where: PlatformAccessWhereUniqueInput
  }

  /**
   * PlatformAccess deleteMany
   */
  export type PlatformAccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAccesses to delete
     */
    where?: PlatformAccessWhereInput
    /**
     * Limit how many PlatformAccesses to delete.
     */
    limit?: number
  }

  /**
   * PlatformAccess without action
   */
  export type PlatformAccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccess
     */
    select?: PlatformAccessSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccess
     */
    omit?: PlatformAccessOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessInclude<ExtArgs> | null
  }


  /**
   * Model ContractPermission
   */

  export type AggregateContractPermission = {
    _count: ContractPermissionCountAggregateOutputType | null
    _avg: ContractPermissionAvgAggregateOutputType | null
    _sum: ContractPermissionSumAggregateOutputType | null
    _min: ContractPermissionMinAggregateOutputType | null
    _max: ContractPermissionMaxAggregateOutputType | null
  }

  export type ContractPermissionAvgAggregateOutputType = {
    providerId: number | null
  }

  export type ContractPermissionSumAggregateOutputType = {
    providerId: number | null
  }

  export type ContractPermissionMinAggregateOutputType = {
    id: string | null
    providerId: number | null
    contractId: string | null
    serviceId: string | null
    jwtToken: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ContractPermissionMaxAggregateOutputType = {
    id: string | null
    providerId: number | null
    contractId: string | null
    serviceId: string | null
    jwtToken: string | null
    grantedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ContractPermissionCountAggregateOutputType = {
    id: number
    providerId: number
    contractId: number
    serviceId: number
    jwtToken: number
    permissions: number
    grantedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type ContractPermissionAvgAggregateInputType = {
    providerId?: true
  }

  export type ContractPermissionSumAggregateInputType = {
    providerId?: true
  }

  export type ContractPermissionMinAggregateInputType = {
    id?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    jwtToken?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ContractPermissionMaxAggregateInputType = {
    id?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    jwtToken?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ContractPermissionCountAggregateInputType = {
    id?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    jwtToken?: true
    permissions?: true
    grantedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type ContractPermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractPermission to aggregate.
     */
    where?: ContractPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractPermissions to fetch.
     */
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ContractPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ContractPermissions
    **/
    _count?: true | ContractPermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ContractPermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ContractPermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ContractPermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ContractPermissionMaxAggregateInputType
  }

  export type GetContractPermissionAggregateType<T extends ContractPermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateContractPermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateContractPermission[P]>
      : GetScalarType<T[P], AggregateContractPermission[P]>
  }




  export type ContractPermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ContractPermissionWhereInput
    orderBy?: ContractPermissionOrderByWithAggregationInput | ContractPermissionOrderByWithAggregationInput[]
    by: ContractPermissionScalarFieldEnum[] | ContractPermissionScalarFieldEnum
    having?: ContractPermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ContractPermissionCountAggregateInputType | true
    _avg?: ContractPermissionAvgAggregateInputType
    _sum?: ContractPermissionSumAggregateInputType
    _min?: ContractPermissionMinAggregateInputType
    _max?: ContractPermissionMaxAggregateInputType
  }

  export type ContractPermissionGroupByOutputType = {
    id: string
    providerId: number
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonValue
    grantedAt: Date
    expiresAt: Date
    isActive: boolean
    _count: ContractPermissionCountAggregateOutputType | null
    _avg: ContractPermissionAvgAggregateOutputType | null
    _sum: ContractPermissionSumAggregateOutputType | null
    _min: ContractPermissionMinAggregateOutputType | null
    _max: ContractPermissionMaxAggregateOutputType | null
  }

  type GetContractPermissionGroupByPayload<T extends ContractPermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ContractPermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ContractPermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ContractPermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ContractPermissionGroupByOutputType[P]>
        }
      >
    >


  export type ContractPermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    jwtToken?: boolean
    permissions?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    usageQuota?: boolean | ContractPermission$usageQuotaArgs<ExtArgs>
  }, ExtArgs["result"]["contractPermission"]>

  export type ContractPermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    jwtToken?: boolean
    permissions?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractPermission"]>

  export type ContractPermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    jwtToken?: boolean
    permissions?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["contractPermission"]>

  export type ContractPermissionSelectScalar = {
    id?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    jwtToken?: boolean
    permissions?: boolean
    grantedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type ContractPermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "contractId" | "serviceId" | "jwtToken" | "permissions" | "grantedAt" | "expiresAt" | "isActive", ExtArgs["result"]["contractPermission"]>
  export type ContractPermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    usageQuota?: boolean | ContractPermission$usageQuotaArgs<ExtArgs>
  }
  export type ContractPermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ContractPermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ContractPermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ContractPermission"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      usageQuota: Prisma.$UsageQuotaPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: number
      contractId: string
      serviceId: string
      jwtToken: string
      permissions: Prisma.JsonValue
      grantedAt: Date
      expiresAt: Date
      isActive: boolean
    }, ExtArgs["result"]["contractPermission"]>
    composites: {}
  }

  type ContractPermissionGetPayload<S extends boolean | null | undefined | ContractPermissionDefaultArgs> = $Result.GetResult<Prisma.$ContractPermissionPayload, S>

  type ContractPermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ContractPermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ContractPermissionCountAggregateInputType | true
    }

  export interface ContractPermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ContractPermission'], meta: { name: 'ContractPermission' } }
    /**
     * Find zero or one ContractPermission that matches the filter.
     * @param {ContractPermissionFindUniqueArgs} args - Arguments to find a ContractPermission
     * @example
     * // Get one ContractPermission
     * const contractPermission = await prisma.contractPermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ContractPermissionFindUniqueArgs>(args: SelectSubset<T, ContractPermissionFindUniqueArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ContractPermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ContractPermissionFindUniqueOrThrowArgs} args - Arguments to find a ContractPermission
     * @example
     * // Get one ContractPermission
     * const contractPermission = await prisma.contractPermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ContractPermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ContractPermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractPermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionFindFirstArgs} args - Arguments to find a ContractPermission
     * @example
     * // Get one ContractPermission
     * const contractPermission = await prisma.contractPermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ContractPermissionFindFirstArgs>(args?: SelectSubset<T, ContractPermissionFindFirstArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ContractPermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionFindFirstOrThrowArgs} args - Arguments to find a ContractPermission
     * @example
     * // Get one ContractPermission
     * const contractPermission = await prisma.contractPermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ContractPermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ContractPermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ContractPermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ContractPermissions
     * const contractPermissions = await prisma.contractPermission.findMany()
     * 
     * // Get first 10 ContractPermissions
     * const contractPermissions = await prisma.contractPermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const contractPermissionWithIdOnly = await prisma.contractPermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ContractPermissionFindManyArgs>(args?: SelectSubset<T, ContractPermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ContractPermission.
     * @param {ContractPermissionCreateArgs} args - Arguments to create a ContractPermission.
     * @example
     * // Create one ContractPermission
     * const ContractPermission = await prisma.contractPermission.create({
     *   data: {
     *     // ... data to create a ContractPermission
     *   }
     * })
     * 
     */
    create<T extends ContractPermissionCreateArgs>(args: SelectSubset<T, ContractPermissionCreateArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ContractPermissions.
     * @param {ContractPermissionCreateManyArgs} args - Arguments to create many ContractPermissions.
     * @example
     * // Create many ContractPermissions
     * const contractPermission = await prisma.contractPermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ContractPermissionCreateManyArgs>(args?: SelectSubset<T, ContractPermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ContractPermissions and returns the data saved in the database.
     * @param {ContractPermissionCreateManyAndReturnArgs} args - Arguments to create many ContractPermissions.
     * @example
     * // Create many ContractPermissions
     * const contractPermission = await prisma.contractPermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ContractPermissions and only return the `id`
     * const contractPermissionWithIdOnly = await prisma.contractPermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ContractPermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ContractPermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ContractPermission.
     * @param {ContractPermissionDeleteArgs} args - Arguments to delete one ContractPermission.
     * @example
     * // Delete one ContractPermission
     * const ContractPermission = await prisma.contractPermission.delete({
     *   where: {
     *     // ... filter to delete one ContractPermission
     *   }
     * })
     * 
     */
    delete<T extends ContractPermissionDeleteArgs>(args: SelectSubset<T, ContractPermissionDeleteArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ContractPermission.
     * @param {ContractPermissionUpdateArgs} args - Arguments to update one ContractPermission.
     * @example
     * // Update one ContractPermission
     * const contractPermission = await prisma.contractPermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ContractPermissionUpdateArgs>(args: SelectSubset<T, ContractPermissionUpdateArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ContractPermissions.
     * @param {ContractPermissionDeleteManyArgs} args - Arguments to filter ContractPermissions to delete.
     * @example
     * // Delete a few ContractPermissions
     * const { count } = await prisma.contractPermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ContractPermissionDeleteManyArgs>(args?: SelectSubset<T, ContractPermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ContractPermissions
     * const contractPermission = await prisma.contractPermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ContractPermissionUpdateManyArgs>(args: SelectSubset<T, ContractPermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ContractPermissions and returns the data updated in the database.
     * @param {ContractPermissionUpdateManyAndReturnArgs} args - Arguments to update many ContractPermissions.
     * @example
     * // Update many ContractPermissions
     * const contractPermission = await prisma.contractPermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ContractPermissions and only return the `id`
     * const contractPermissionWithIdOnly = await prisma.contractPermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ContractPermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ContractPermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ContractPermission.
     * @param {ContractPermissionUpsertArgs} args - Arguments to update or create a ContractPermission.
     * @example
     * // Update or create a ContractPermission
     * const contractPermission = await prisma.contractPermission.upsert({
     *   create: {
     *     // ... data to create a ContractPermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ContractPermission we want to update
     *   }
     * })
     */
    upsert<T extends ContractPermissionUpsertArgs>(args: SelectSubset<T, ContractPermissionUpsertArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ContractPermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionCountArgs} args - Arguments to filter ContractPermissions to count.
     * @example
     * // Count the number of ContractPermissions
     * const count = await prisma.contractPermission.count({
     *   where: {
     *     // ... the filter for the ContractPermissions we want to count
     *   }
     * })
    **/
    count<T extends ContractPermissionCountArgs>(
      args?: Subset<T, ContractPermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ContractPermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ContractPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ContractPermissionAggregateArgs>(args: Subset<T, ContractPermissionAggregateArgs>): Prisma.PrismaPromise<GetContractPermissionAggregateType<T>>

    /**
     * Group by ContractPermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ContractPermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ContractPermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ContractPermissionGroupByArgs['orderBy'] }
        : { orderBy?: ContractPermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ContractPermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetContractPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ContractPermission model
   */
  readonly fields: ContractPermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ContractPermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ContractPermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    usageQuota<T extends ContractPermission$usageQuotaArgs<ExtArgs> = {}>(args?: Subset<T, ContractPermission$usageQuotaArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ContractPermission model
   */
  interface ContractPermissionFieldRefs {
    readonly id: FieldRef<"ContractPermission", 'String'>
    readonly providerId: FieldRef<"ContractPermission", 'Int'>
    readonly contractId: FieldRef<"ContractPermission", 'String'>
    readonly serviceId: FieldRef<"ContractPermission", 'String'>
    readonly jwtToken: FieldRef<"ContractPermission", 'String'>
    readonly permissions: FieldRef<"ContractPermission", 'Json'>
    readonly grantedAt: FieldRef<"ContractPermission", 'DateTime'>
    readonly expiresAt: FieldRef<"ContractPermission", 'DateTime'>
    readonly isActive: FieldRef<"ContractPermission", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ContractPermission findUnique
   */
  export type ContractPermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ContractPermission to fetch.
     */
    where: ContractPermissionWhereUniqueInput
  }

  /**
   * ContractPermission findUniqueOrThrow
   */
  export type ContractPermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ContractPermission to fetch.
     */
    where: ContractPermissionWhereUniqueInput
  }

  /**
   * ContractPermission findFirst
   */
  export type ContractPermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ContractPermission to fetch.
     */
    where?: ContractPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractPermissions to fetch.
     */
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractPermissions.
     */
    cursor?: ContractPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractPermissions.
     */
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * ContractPermission findFirstOrThrow
   */
  export type ContractPermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ContractPermission to fetch.
     */
    where?: ContractPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractPermissions to fetch.
     */
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ContractPermissions.
     */
    cursor?: ContractPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractPermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ContractPermissions.
     */
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * ContractPermission findMany
   */
  export type ContractPermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter, which ContractPermissions to fetch.
     */
    where?: ContractPermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ContractPermissions to fetch.
     */
    orderBy?: ContractPermissionOrderByWithRelationInput | ContractPermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ContractPermissions.
     */
    cursor?: ContractPermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ContractPermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ContractPermissions.
     */
    skip?: number
    distinct?: ContractPermissionScalarFieldEnum | ContractPermissionScalarFieldEnum[]
  }

  /**
   * ContractPermission create
   */
  export type ContractPermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ContractPermission.
     */
    data: XOR<ContractPermissionCreateInput, ContractPermissionUncheckedCreateInput>
  }

  /**
   * ContractPermission createMany
   */
  export type ContractPermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ContractPermissions.
     */
    data: ContractPermissionCreateManyInput | ContractPermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ContractPermission createManyAndReturn
   */
  export type ContractPermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * The data used to create many ContractPermissions.
     */
    data: ContractPermissionCreateManyInput | ContractPermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractPermission update
   */
  export type ContractPermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ContractPermission.
     */
    data: XOR<ContractPermissionUpdateInput, ContractPermissionUncheckedUpdateInput>
    /**
     * Choose, which ContractPermission to update.
     */
    where: ContractPermissionWhereUniqueInput
  }

  /**
   * ContractPermission updateMany
   */
  export type ContractPermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ContractPermissions.
     */
    data: XOR<ContractPermissionUpdateManyMutationInput, ContractPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ContractPermissions to update
     */
    where?: ContractPermissionWhereInput
    /**
     * Limit how many ContractPermissions to update.
     */
    limit?: number
  }

  /**
   * ContractPermission updateManyAndReturn
   */
  export type ContractPermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * The data used to update ContractPermissions.
     */
    data: XOR<ContractPermissionUpdateManyMutationInput, ContractPermissionUncheckedUpdateManyInput>
    /**
     * Filter which ContractPermissions to update
     */
    where?: ContractPermissionWhereInput
    /**
     * Limit how many ContractPermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ContractPermission upsert
   */
  export type ContractPermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ContractPermission to update in case it exists.
     */
    where: ContractPermissionWhereUniqueInput
    /**
     * In case the ContractPermission found by the `where` argument doesn't exist, create a new ContractPermission with this data.
     */
    create: XOR<ContractPermissionCreateInput, ContractPermissionUncheckedCreateInput>
    /**
     * In case the ContractPermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ContractPermissionUpdateInput, ContractPermissionUncheckedUpdateInput>
  }

  /**
   * ContractPermission delete
   */
  export type ContractPermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
    /**
     * Filter which ContractPermission to delete.
     */
    where: ContractPermissionWhereUniqueInput
  }

  /**
   * ContractPermission deleteMany
   */
  export type ContractPermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ContractPermissions to delete
     */
    where?: ContractPermissionWhereInput
    /**
     * Limit how many ContractPermissions to delete.
     */
    limit?: number
  }

  /**
   * ContractPermission.usageQuota
   */
  export type ContractPermission$usageQuotaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    where?: UsageQuotaWhereInput
  }

  /**
   * ContractPermission without action
   */
  export type ContractPermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ContractPermission
     */
    select?: ContractPermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ContractPermission
     */
    omit?: ContractPermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractPermissionInclude<ExtArgs> | null
  }


  /**
   * Model JWTToken
   */

  export type AggregateJWTToken = {
    _count: JWTTokenCountAggregateOutputType | null
    _avg: JWTTokenAvgAggregateOutputType | null
    _sum: JWTTokenSumAggregateOutputType | null
    _min: JWTTokenMinAggregateOutputType | null
    _max: JWTTokenMaxAggregateOutputType | null
  }

  export type JWTTokenAvgAggregateOutputType = {
    providerId: number | null
  }

  export type JWTTokenSumAggregateOutputType = {
    providerId: number | null
  }

  export type JWTTokenMinAggregateOutputType = {
    id: string | null
    token: string | null
    providerId: number | null
    contractId: string | null
    serviceId: string | null
    zkProofHash: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    isRevoked: boolean | null
  }

  export type JWTTokenMaxAggregateOutputType = {
    id: string | null
    token: string | null
    providerId: number | null
    contractId: string | null
    serviceId: string | null
    zkProofHash: string | null
    issuedAt: Date | null
    expiresAt: Date | null
    isRevoked: boolean | null
  }

  export type JWTTokenCountAggregateOutputType = {
    id: number
    token: number
    providerId: number
    contractId: number
    serviceId: number
    permissions: number
    zkProofHash: number
    issuedAt: number
    expiresAt: number
    isRevoked: number
    _all: number
  }


  export type JWTTokenAvgAggregateInputType = {
    providerId?: true
  }

  export type JWTTokenSumAggregateInputType = {
    providerId?: true
  }

  export type JWTTokenMinAggregateInputType = {
    id?: true
    token?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    zkProofHash?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
  }

  export type JWTTokenMaxAggregateInputType = {
    id?: true
    token?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    zkProofHash?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
  }

  export type JWTTokenCountAggregateInputType = {
    id?: true
    token?: true
    providerId?: true
    contractId?: true
    serviceId?: true
    permissions?: true
    zkProofHash?: true
    issuedAt?: true
    expiresAt?: true
    isRevoked?: true
    _all?: true
  }

  export type JWTTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JWTToken to aggregate.
     */
    where?: JWTTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JWTTokens to fetch.
     */
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: JWTTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JWTTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JWTTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned JWTTokens
    **/
    _count?: true | JWTTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: JWTTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: JWTTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: JWTTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: JWTTokenMaxAggregateInputType
  }

  export type GetJWTTokenAggregateType<T extends JWTTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateJWTToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateJWTToken[P]>
      : GetScalarType<T[P], AggregateJWTToken[P]>
  }




  export type JWTTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: JWTTokenWhereInput
    orderBy?: JWTTokenOrderByWithAggregationInput | JWTTokenOrderByWithAggregationInput[]
    by: JWTTokenScalarFieldEnum[] | JWTTokenScalarFieldEnum
    having?: JWTTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: JWTTokenCountAggregateInputType | true
    _avg?: JWTTokenAvgAggregateInputType
    _sum?: JWTTokenSumAggregateInputType
    _min?: JWTTokenMinAggregateInputType
    _max?: JWTTokenMaxAggregateInputType
  }

  export type JWTTokenGroupByOutputType = {
    id: string
    token: string
    providerId: number
    contractId: string | null
    serviceId: string
    permissions: JsonValue
    zkProofHash: string | null
    issuedAt: Date
    expiresAt: Date
    isRevoked: boolean
    _count: JWTTokenCountAggregateOutputType | null
    _avg: JWTTokenAvgAggregateOutputType | null
    _sum: JWTTokenSumAggregateOutputType | null
    _min: JWTTokenMinAggregateOutputType | null
    _max: JWTTokenMaxAggregateOutputType | null
  }

  type GetJWTTokenGroupByPayload<T extends JWTTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<JWTTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof JWTTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], JWTTokenGroupByOutputType[P]>
            : GetScalarType<T[P], JWTTokenGroupByOutputType[P]>
        }
      >
    >


  export type JWTTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    permissions?: boolean
    zkProofHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jWTToken"]>

  export type JWTTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    permissions?: boolean
    zkProofHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jWTToken"]>

  export type JWTTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    token?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    permissions?: boolean
    zkProofHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["jWTToken"]>

  export type JWTTokenSelectScalar = {
    id?: boolean
    token?: boolean
    providerId?: boolean
    contractId?: boolean
    serviceId?: boolean
    permissions?: boolean
    zkProofHash?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isRevoked?: boolean
  }

  export type JWTTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "token" | "providerId" | "contractId" | "serviceId" | "permissions" | "zkProofHash" | "issuedAt" | "expiresAt" | "isRevoked", ExtArgs["result"]["jWTToken"]>
  export type JWTTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type JWTTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type JWTTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    contract?: boolean | JWTToken$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $JWTTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "JWTToken"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      contract: Prisma.$ContractPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      token: string
      providerId: number
      contractId: string | null
      serviceId: string
      permissions: Prisma.JsonValue
      zkProofHash: string | null
      issuedAt: Date
      expiresAt: Date
      isRevoked: boolean
    }, ExtArgs["result"]["jWTToken"]>
    composites: {}
  }

  type JWTTokenGetPayload<S extends boolean | null | undefined | JWTTokenDefaultArgs> = $Result.GetResult<Prisma.$JWTTokenPayload, S>

  type JWTTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<JWTTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: JWTTokenCountAggregateInputType | true
    }

  export interface JWTTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['JWTToken'], meta: { name: 'JWTToken' } }
    /**
     * Find zero or one JWTToken that matches the filter.
     * @param {JWTTokenFindUniqueArgs} args - Arguments to find a JWTToken
     * @example
     * // Get one JWTToken
     * const jWTToken = await prisma.jWTToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends JWTTokenFindUniqueArgs>(args: SelectSubset<T, JWTTokenFindUniqueArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one JWTToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {JWTTokenFindUniqueOrThrowArgs} args - Arguments to find a JWTToken
     * @example
     * // Get one JWTToken
     * const jWTToken = await prisma.jWTToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends JWTTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, JWTTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JWTToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenFindFirstArgs} args - Arguments to find a JWTToken
     * @example
     * // Get one JWTToken
     * const jWTToken = await prisma.jWTToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends JWTTokenFindFirstArgs>(args?: SelectSubset<T, JWTTokenFindFirstArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first JWTToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenFindFirstOrThrowArgs} args - Arguments to find a JWTToken
     * @example
     * // Get one JWTToken
     * const jWTToken = await prisma.jWTToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends JWTTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, JWTTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more JWTTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all JWTTokens
     * const jWTTokens = await prisma.jWTToken.findMany()
     * 
     * // Get first 10 JWTTokens
     * const jWTTokens = await prisma.jWTToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const jWTTokenWithIdOnly = await prisma.jWTToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends JWTTokenFindManyArgs>(args?: SelectSubset<T, JWTTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a JWTToken.
     * @param {JWTTokenCreateArgs} args - Arguments to create a JWTToken.
     * @example
     * // Create one JWTToken
     * const JWTToken = await prisma.jWTToken.create({
     *   data: {
     *     // ... data to create a JWTToken
     *   }
     * })
     * 
     */
    create<T extends JWTTokenCreateArgs>(args: SelectSubset<T, JWTTokenCreateArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many JWTTokens.
     * @param {JWTTokenCreateManyArgs} args - Arguments to create many JWTTokens.
     * @example
     * // Create many JWTTokens
     * const jWTToken = await prisma.jWTToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends JWTTokenCreateManyArgs>(args?: SelectSubset<T, JWTTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many JWTTokens and returns the data saved in the database.
     * @param {JWTTokenCreateManyAndReturnArgs} args - Arguments to create many JWTTokens.
     * @example
     * // Create many JWTTokens
     * const jWTToken = await prisma.jWTToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many JWTTokens and only return the `id`
     * const jWTTokenWithIdOnly = await prisma.jWTToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends JWTTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, JWTTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a JWTToken.
     * @param {JWTTokenDeleteArgs} args - Arguments to delete one JWTToken.
     * @example
     * // Delete one JWTToken
     * const JWTToken = await prisma.jWTToken.delete({
     *   where: {
     *     // ... filter to delete one JWTToken
     *   }
     * })
     * 
     */
    delete<T extends JWTTokenDeleteArgs>(args: SelectSubset<T, JWTTokenDeleteArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one JWTToken.
     * @param {JWTTokenUpdateArgs} args - Arguments to update one JWTToken.
     * @example
     * // Update one JWTToken
     * const jWTToken = await prisma.jWTToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends JWTTokenUpdateArgs>(args: SelectSubset<T, JWTTokenUpdateArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more JWTTokens.
     * @param {JWTTokenDeleteManyArgs} args - Arguments to filter JWTTokens to delete.
     * @example
     * // Delete a few JWTTokens
     * const { count } = await prisma.jWTToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends JWTTokenDeleteManyArgs>(args?: SelectSubset<T, JWTTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JWTTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many JWTTokens
     * const jWTToken = await prisma.jWTToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends JWTTokenUpdateManyArgs>(args: SelectSubset<T, JWTTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more JWTTokens and returns the data updated in the database.
     * @param {JWTTokenUpdateManyAndReturnArgs} args - Arguments to update many JWTTokens.
     * @example
     * // Update many JWTTokens
     * const jWTToken = await prisma.jWTToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more JWTTokens and only return the `id`
     * const jWTTokenWithIdOnly = await prisma.jWTToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends JWTTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, JWTTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one JWTToken.
     * @param {JWTTokenUpsertArgs} args - Arguments to update or create a JWTToken.
     * @example
     * // Update or create a JWTToken
     * const jWTToken = await prisma.jWTToken.upsert({
     *   create: {
     *     // ... data to create a JWTToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the JWTToken we want to update
     *   }
     * })
     */
    upsert<T extends JWTTokenUpsertArgs>(args: SelectSubset<T, JWTTokenUpsertArgs<ExtArgs>>): Prisma__JWTTokenClient<$Result.GetResult<Prisma.$JWTTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of JWTTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenCountArgs} args - Arguments to filter JWTTokens to count.
     * @example
     * // Count the number of JWTTokens
     * const count = await prisma.jWTToken.count({
     *   where: {
     *     // ... the filter for the JWTTokens we want to count
     *   }
     * })
    **/
    count<T extends JWTTokenCountArgs>(
      args?: Subset<T, JWTTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], JWTTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a JWTToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends JWTTokenAggregateArgs>(args: Subset<T, JWTTokenAggregateArgs>): Prisma.PrismaPromise<GetJWTTokenAggregateType<T>>

    /**
     * Group by JWTToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {JWTTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends JWTTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: JWTTokenGroupByArgs['orderBy'] }
        : { orderBy?: JWTTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, JWTTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetJWTTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the JWTToken model
   */
  readonly fields: JWTTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for JWTToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__JWTTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    contract<T extends JWTToken$contractArgs<ExtArgs> = {}>(args?: Subset<T, JWTToken$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the JWTToken model
   */
  interface JWTTokenFieldRefs {
    readonly id: FieldRef<"JWTToken", 'String'>
    readonly token: FieldRef<"JWTToken", 'String'>
    readonly providerId: FieldRef<"JWTToken", 'Int'>
    readonly contractId: FieldRef<"JWTToken", 'String'>
    readonly serviceId: FieldRef<"JWTToken", 'String'>
    readonly permissions: FieldRef<"JWTToken", 'Json'>
    readonly zkProofHash: FieldRef<"JWTToken", 'String'>
    readonly issuedAt: FieldRef<"JWTToken", 'DateTime'>
    readonly expiresAt: FieldRef<"JWTToken", 'DateTime'>
    readonly isRevoked: FieldRef<"JWTToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * JWTToken findUnique
   */
  export type JWTTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter, which JWTToken to fetch.
     */
    where: JWTTokenWhereUniqueInput
  }

  /**
   * JWTToken findUniqueOrThrow
   */
  export type JWTTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter, which JWTToken to fetch.
     */
    where: JWTTokenWhereUniqueInput
  }

  /**
   * JWTToken findFirst
   */
  export type JWTTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter, which JWTToken to fetch.
     */
    where?: JWTTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JWTTokens to fetch.
     */
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JWTTokens.
     */
    cursor?: JWTTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JWTTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JWTTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JWTTokens.
     */
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * JWTToken findFirstOrThrow
   */
  export type JWTTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter, which JWTToken to fetch.
     */
    where?: JWTTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JWTTokens to fetch.
     */
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for JWTTokens.
     */
    cursor?: JWTTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JWTTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JWTTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of JWTTokens.
     */
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * JWTToken findMany
   */
  export type JWTTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter, which JWTTokens to fetch.
     */
    where?: JWTTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of JWTTokens to fetch.
     */
    orderBy?: JWTTokenOrderByWithRelationInput | JWTTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing JWTTokens.
     */
    cursor?: JWTTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` JWTTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` JWTTokens.
     */
    skip?: number
    distinct?: JWTTokenScalarFieldEnum | JWTTokenScalarFieldEnum[]
  }

  /**
   * JWTToken create
   */
  export type JWTTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a JWTToken.
     */
    data: XOR<JWTTokenCreateInput, JWTTokenUncheckedCreateInput>
  }

  /**
   * JWTToken createMany
   */
  export type JWTTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many JWTTokens.
     */
    data: JWTTokenCreateManyInput | JWTTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * JWTToken createManyAndReturn
   */
  export type JWTTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * The data used to create many JWTTokens.
     */
    data: JWTTokenCreateManyInput | JWTTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * JWTToken update
   */
  export type JWTTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a JWTToken.
     */
    data: XOR<JWTTokenUpdateInput, JWTTokenUncheckedUpdateInput>
    /**
     * Choose, which JWTToken to update.
     */
    where: JWTTokenWhereUniqueInput
  }

  /**
   * JWTToken updateMany
   */
  export type JWTTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update JWTTokens.
     */
    data: XOR<JWTTokenUpdateManyMutationInput, JWTTokenUncheckedUpdateManyInput>
    /**
     * Filter which JWTTokens to update
     */
    where?: JWTTokenWhereInput
    /**
     * Limit how many JWTTokens to update.
     */
    limit?: number
  }

  /**
   * JWTToken updateManyAndReturn
   */
  export type JWTTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * The data used to update JWTTokens.
     */
    data: XOR<JWTTokenUpdateManyMutationInput, JWTTokenUncheckedUpdateManyInput>
    /**
     * Filter which JWTTokens to update
     */
    where?: JWTTokenWhereInput
    /**
     * Limit how many JWTTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * JWTToken upsert
   */
  export type JWTTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the JWTToken to update in case it exists.
     */
    where: JWTTokenWhereUniqueInput
    /**
     * In case the JWTToken found by the `where` argument doesn't exist, create a new JWTToken with this data.
     */
    create: XOR<JWTTokenCreateInput, JWTTokenUncheckedCreateInput>
    /**
     * In case the JWTToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<JWTTokenUpdateInput, JWTTokenUncheckedUpdateInput>
  }

  /**
   * JWTToken delete
   */
  export type JWTTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
    /**
     * Filter which JWTToken to delete.
     */
    where: JWTTokenWhereUniqueInput
  }

  /**
   * JWTToken deleteMany
   */
  export type JWTTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which JWTTokens to delete
     */
    where?: JWTTokenWhereInput
    /**
     * Limit how many JWTTokens to delete.
     */
    limit?: number
  }

  /**
   * JWTToken.contract
   */
  export type JWTToken$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * JWTToken without action
   */
  export type JWTTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the JWTToken
     */
    select?: JWTTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the JWTToken
     */
    omit?: JWTTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: JWTTokenInclude<ExtArgs> | null
  }


  /**
   * Model ServiceSubscription
   */

  export type AggregateServiceSubscription = {
    _count: ServiceSubscriptionCountAggregateOutputType | null
    _avg: ServiceSubscriptionAvgAggregateOutputType | null
    _sum: ServiceSubscriptionSumAggregateOutputType | null
    _min: ServiceSubscriptionMinAggregateOutputType | null
    _max: ServiceSubscriptionMaxAggregateOutputType | null
  }

  export type ServiceSubscriptionAvgAggregateOutputType = {
    providerId: number | null
  }

  export type ServiceSubscriptionSumAggregateOutputType = {
    providerId: number | null
  }

  export type ServiceSubscriptionMinAggregateOutputType = {
    id: string | null
    platformId: string | null
    serviceId: string | null
    providerId: number | null
    accessLevel: $Enums.AccessLevel | null
    subscribedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ServiceSubscriptionMaxAggregateOutputType = {
    id: string | null
    platformId: string | null
    serviceId: string | null
    providerId: number | null
    accessLevel: $Enums.AccessLevel | null
    subscribedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type ServiceSubscriptionCountAggregateOutputType = {
    id: number
    platformId: number
    serviceId: number
    providerId: number
    accessLevel: number
    contractAccess: number
    subscribedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type ServiceSubscriptionAvgAggregateInputType = {
    providerId?: true
  }

  export type ServiceSubscriptionSumAggregateInputType = {
    providerId?: true
  }

  export type ServiceSubscriptionMinAggregateInputType = {
    id?: true
    platformId?: true
    serviceId?: true
    providerId?: true
    accessLevel?: true
    subscribedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ServiceSubscriptionMaxAggregateInputType = {
    id?: true
    platformId?: true
    serviceId?: true
    providerId?: true
    accessLevel?: true
    subscribedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type ServiceSubscriptionCountAggregateInputType = {
    id?: true
    platformId?: true
    serviceId?: true
    providerId?: true
    accessLevel?: true
    contractAccess?: true
    subscribedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type ServiceSubscriptionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubscription to aggregate.
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubscriptions to fetch.
     */
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServiceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServiceSubscriptions
    **/
    _count?: true | ServiceSubscriptionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServiceSubscriptionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServiceSubscriptionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServiceSubscriptionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServiceSubscriptionMaxAggregateInputType
  }

  export type GetServiceSubscriptionAggregateType<T extends ServiceSubscriptionAggregateArgs> = {
        [P in keyof T & keyof AggregateServiceSubscription]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServiceSubscription[P]>
      : GetScalarType<T[P], AggregateServiceSubscription[P]>
  }




  export type ServiceSubscriptionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServiceSubscriptionWhereInput
    orderBy?: ServiceSubscriptionOrderByWithAggregationInput | ServiceSubscriptionOrderByWithAggregationInput[]
    by: ServiceSubscriptionScalarFieldEnum[] | ServiceSubscriptionScalarFieldEnum
    having?: ServiceSubscriptionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServiceSubscriptionCountAggregateInputType | true
    _avg?: ServiceSubscriptionAvgAggregateInputType
    _sum?: ServiceSubscriptionSumAggregateInputType
    _min?: ServiceSubscriptionMinAggregateInputType
    _max?: ServiceSubscriptionMaxAggregateInputType
  }

  export type ServiceSubscriptionGroupByOutputType = {
    id: string
    platformId: string
    serviceId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonValue
    subscribedAt: Date
    expiresAt: Date | null
    isActive: boolean
    _count: ServiceSubscriptionCountAggregateOutputType | null
    _avg: ServiceSubscriptionAvgAggregateOutputType | null
    _sum: ServiceSubscriptionSumAggregateOutputType | null
    _min: ServiceSubscriptionMinAggregateOutputType | null
    _max: ServiceSubscriptionMaxAggregateOutputType | null
  }

  type GetServiceSubscriptionGroupByPayload<T extends ServiceSubscriptionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServiceSubscriptionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServiceSubscriptionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServiceSubscriptionGroupByOutputType[P]>
            : GetScalarType<T[P], ServiceSubscriptionGroupByOutputType[P]>
        }
      >
    >


  export type ServiceSubscriptionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessLevel?: boolean
    contractAccess?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubscription"]>

  export type ServiceSubscriptionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessLevel?: boolean
    contractAccess?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubscription"]>

  export type ServiceSubscriptionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessLevel?: boolean
    contractAccess?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["serviceSubscription"]>

  export type ServiceSubscriptionSelectScalar = {
    id?: boolean
    platformId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessLevel?: boolean
    contractAccess?: boolean
    subscribedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type ServiceSubscriptionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platformId" | "serviceId" | "providerId" | "accessLevel" | "contractAccess" | "subscribedAt" | "expiresAt" | "isActive", ExtArgs["result"]["serviceSubscription"]>
  export type ServiceSubscriptionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServiceSubscriptionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServiceSubscriptionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ServiceSubscriptionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServiceSubscription"
    objects: {
      platform: Prisma.$PlatformPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platformId: string
      serviceId: string
      providerId: number
      accessLevel: $Enums.AccessLevel
      contractAccess: Prisma.JsonValue
      subscribedAt: Date
      expiresAt: Date | null
      isActive: boolean
    }, ExtArgs["result"]["serviceSubscription"]>
    composites: {}
  }

  type ServiceSubscriptionGetPayload<S extends boolean | null | undefined | ServiceSubscriptionDefaultArgs> = $Result.GetResult<Prisma.$ServiceSubscriptionPayload, S>

  type ServiceSubscriptionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServiceSubscriptionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServiceSubscriptionCountAggregateInputType | true
    }

  export interface ServiceSubscriptionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServiceSubscription'], meta: { name: 'ServiceSubscription' } }
    /**
     * Find zero or one ServiceSubscription that matches the filter.
     * @param {ServiceSubscriptionFindUniqueArgs} args - Arguments to find a ServiceSubscription
     * @example
     * // Get one ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServiceSubscriptionFindUniqueArgs>(args: SelectSubset<T, ServiceSubscriptionFindUniqueArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServiceSubscription that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServiceSubscriptionFindUniqueOrThrowArgs} args - Arguments to find a ServiceSubscription
     * @example
     * // Get one ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServiceSubscriptionFindUniqueOrThrowArgs>(args: SelectSubset<T, ServiceSubscriptionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSubscription that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionFindFirstArgs} args - Arguments to find a ServiceSubscription
     * @example
     * // Get one ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServiceSubscriptionFindFirstArgs>(args?: SelectSubset<T, ServiceSubscriptionFindFirstArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServiceSubscription that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionFindFirstOrThrowArgs} args - Arguments to find a ServiceSubscription
     * @example
     * // Get one ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServiceSubscriptionFindFirstOrThrowArgs>(args?: SelectSubset<T, ServiceSubscriptionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServiceSubscriptions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServiceSubscriptions
     * const serviceSubscriptions = await prisma.serviceSubscription.findMany()
     * 
     * // Get first 10 ServiceSubscriptions
     * const serviceSubscriptions = await prisma.serviceSubscription.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const serviceSubscriptionWithIdOnly = await prisma.serviceSubscription.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServiceSubscriptionFindManyArgs>(args?: SelectSubset<T, ServiceSubscriptionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServiceSubscription.
     * @param {ServiceSubscriptionCreateArgs} args - Arguments to create a ServiceSubscription.
     * @example
     * // Create one ServiceSubscription
     * const ServiceSubscription = await prisma.serviceSubscription.create({
     *   data: {
     *     // ... data to create a ServiceSubscription
     *   }
     * })
     * 
     */
    create<T extends ServiceSubscriptionCreateArgs>(args: SelectSubset<T, ServiceSubscriptionCreateArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServiceSubscriptions.
     * @param {ServiceSubscriptionCreateManyArgs} args - Arguments to create many ServiceSubscriptions.
     * @example
     * // Create many ServiceSubscriptions
     * const serviceSubscription = await prisma.serviceSubscription.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServiceSubscriptionCreateManyArgs>(args?: SelectSubset<T, ServiceSubscriptionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServiceSubscriptions and returns the data saved in the database.
     * @param {ServiceSubscriptionCreateManyAndReturnArgs} args - Arguments to create many ServiceSubscriptions.
     * @example
     * // Create many ServiceSubscriptions
     * const serviceSubscription = await prisma.serviceSubscription.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServiceSubscriptions and only return the `id`
     * const serviceSubscriptionWithIdOnly = await prisma.serviceSubscription.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServiceSubscriptionCreateManyAndReturnArgs>(args?: SelectSubset<T, ServiceSubscriptionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServiceSubscription.
     * @param {ServiceSubscriptionDeleteArgs} args - Arguments to delete one ServiceSubscription.
     * @example
     * // Delete one ServiceSubscription
     * const ServiceSubscription = await prisma.serviceSubscription.delete({
     *   where: {
     *     // ... filter to delete one ServiceSubscription
     *   }
     * })
     * 
     */
    delete<T extends ServiceSubscriptionDeleteArgs>(args: SelectSubset<T, ServiceSubscriptionDeleteArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServiceSubscription.
     * @param {ServiceSubscriptionUpdateArgs} args - Arguments to update one ServiceSubscription.
     * @example
     * // Update one ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServiceSubscriptionUpdateArgs>(args: SelectSubset<T, ServiceSubscriptionUpdateArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServiceSubscriptions.
     * @param {ServiceSubscriptionDeleteManyArgs} args - Arguments to filter ServiceSubscriptions to delete.
     * @example
     * // Delete a few ServiceSubscriptions
     * const { count } = await prisma.serviceSubscription.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServiceSubscriptionDeleteManyArgs>(args?: SelectSubset<T, ServiceSubscriptionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServiceSubscriptions
     * const serviceSubscription = await prisma.serviceSubscription.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServiceSubscriptionUpdateManyArgs>(args: SelectSubset<T, ServiceSubscriptionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServiceSubscriptions and returns the data updated in the database.
     * @param {ServiceSubscriptionUpdateManyAndReturnArgs} args - Arguments to update many ServiceSubscriptions.
     * @example
     * // Update many ServiceSubscriptions
     * const serviceSubscription = await prisma.serviceSubscription.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServiceSubscriptions and only return the `id`
     * const serviceSubscriptionWithIdOnly = await prisma.serviceSubscription.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServiceSubscriptionUpdateManyAndReturnArgs>(args: SelectSubset<T, ServiceSubscriptionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServiceSubscription.
     * @param {ServiceSubscriptionUpsertArgs} args - Arguments to update or create a ServiceSubscription.
     * @example
     * // Update or create a ServiceSubscription
     * const serviceSubscription = await prisma.serviceSubscription.upsert({
     *   create: {
     *     // ... data to create a ServiceSubscription
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServiceSubscription we want to update
     *   }
     * })
     */
    upsert<T extends ServiceSubscriptionUpsertArgs>(args: SelectSubset<T, ServiceSubscriptionUpsertArgs<ExtArgs>>): Prisma__ServiceSubscriptionClient<$Result.GetResult<Prisma.$ServiceSubscriptionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServiceSubscriptions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionCountArgs} args - Arguments to filter ServiceSubscriptions to count.
     * @example
     * // Count the number of ServiceSubscriptions
     * const count = await prisma.serviceSubscription.count({
     *   where: {
     *     // ... the filter for the ServiceSubscriptions we want to count
     *   }
     * })
    **/
    count<T extends ServiceSubscriptionCountArgs>(
      args?: Subset<T, ServiceSubscriptionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServiceSubscriptionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServiceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServiceSubscriptionAggregateArgs>(args: Subset<T, ServiceSubscriptionAggregateArgs>): Prisma.PrismaPromise<GetServiceSubscriptionAggregateType<T>>

    /**
     * Group by ServiceSubscription.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServiceSubscriptionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServiceSubscriptionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServiceSubscriptionGroupByArgs['orderBy'] }
        : { orderBy?: ServiceSubscriptionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServiceSubscriptionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServiceSubscriptionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServiceSubscription model
   */
  readonly fields: ServiceSubscriptionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServiceSubscription.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServiceSubscriptionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServiceSubscription model
   */
  interface ServiceSubscriptionFieldRefs {
    readonly id: FieldRef<"ServiceSubscription", 'String'>
    readonly platformId: FieldRef<"ServiceSubscription", 'String'>
    readonly serviceId: FieldRef<"ServiceSubscription", 'String'>
    readonly providerId: FieldRef<"ServiceSubscription", 'Int'>
    readonly accessLevel: FieldRef<"ServiceSubscription", 'AccessLevel'>
    readonly contractAccess: FieldRef<"ServiceSubscription", 'Json'>
    readonly subscribedAt: FieldRef<"ServiceSubscription", 'DateTime'>
    readonly expiresAt: FieldRef<"ServiceSubscription", 'DateTime'>
    readonly isActive: FieldRef<"ServiceSubscription", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * ServiceSubscription findUnique
   */
  export type ServiceSubscriptionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubscription to fetch.
     */
    where: ServiceSubscriptionWhereUniqueInput
  }

  /**
   * ServiceSubscription findUniqueOrThrow
   */
  export type ServiceSubscriptionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubscription to fetch.
     */
    where: ServiceSubscriptionWhereUniqueInput
  }

  /**
   * ServiceSubscription findFirst
   */
  export type ServiceSubscriptionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubscription to fetch.
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubscriptions to fetch.
     */
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubscriptions.
     */
    cursor?: ServiceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubscriptions.
     */
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * ServiceSubscription findFirstOrThrow
   */
  export type ServiceSubscriptionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubscription to fetch.
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubscriptions to fetch.
     */
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServiceSubscriptions.
     */
    cursor?: ServiceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubscriptions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServiceSubscriptions.
     */
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * ServiceSubscription findMany
   */
  export type ServiceSubscriptionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter, which ServiceSubscriptions to fetch.
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServiceSubscriptions to fetch.
     */
    orderBy?: ServiceSubscriptionOrderByWithRelationInput | ServiceSubscriptionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServiceSubscriptions.
     */
    cursor?: ServiceSubscriptionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServiceSubscriptions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServiceSubscriptions.
     */
    skip?: number
    distinct?: ServiceSubscriptionScalarFieldEnum | ServiceSubscriptionScalarFieldEnum[]
  }

  /**
   * ServiceSubscription create
   */
  export type ServiceSubscriptionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to create a ServiceSubscription.
     */
    data: XOR<ServiceSubscriptionCreateInput, ServiceSubscriptionUncheckedCreateInput>
  }

  /**
   * ServiceSubscription createMany
   */
  export type ServiceSubscriptionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServiceSubscriptions.
     */
    data: ServiceSubscriptionCreateManyInput | ServiceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServiceSubscription createManyAndReturn
   */
  export type ServiceSubscriptionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to create many ServiceSubscriptions.
     */
    data: ServiceSubscriptionCreateManyInput | ServiceSubscriptionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceSubscription update
   */
  export type ServiceSubscriptionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * The data needed to update a ServiceSubscription.
     */
    data: XOR<ServiceSubscriptionUpdateInput, ServiceSubscriptionUncheckedUpdateInput>
    /**
     * Choose, which ServiceSubscription to update.
     */
    where: ServiceSubscriptionWhereUniqueInput
  }

  /**
   * ServiceSubscription updateMany
   */
  export type ServiceSubscriptionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServiceSubscriptions.
     */
    data: XOR<ServiceSubscriptionUpdateManyMutationInput, ServiceSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubscriptions to update
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * Limit how many ServiceSubscriptions to update.
     */
    limit?: number
  }

  /**
   * ServiceSubscription updateManyAndReturn
   */
  export type ServiceSubscriptionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * The data used to update ServiceSubscriptions.
     */
    data: XOR<ServiceSubscriptionUpdateManyMutationInput, ServiceSubscriptionUncheckedUpdateManyInput>
    /**
     * Filter which ServiceSubscriptions to update
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * Limit how many ServiceSubscriptions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServiceSubscription upsert
   */
  export type ServiceSubscriptionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * The filter to search for the ServiceSubscription to update in case it exists.
     */
    where: ServiceSubscriptionWhereUniqueInput
    /**
     * In case the ServiceSubscription found by the `where` argument doesn't exist, create a new ServiceSubscription with this data.
     */
    create: XOR<ServiceSubscriptionCreateInput, ServiceSubscriptionUncheckedCreateInput>
    /**
     * In case the ServiceSubscription was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServiceSubscriptionUpdateInput, ServiceSubscriptionUncheckedUpdateInput>
  }

  /**
   * ServiceSubscription delete
   */
  export type ServiceSubscriptionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
    /**
     * Filter which ServiceSubscription to delete.
     */
    where: ServiceSubscriptionWhereUniqueInput
  }

  /**
   * ServiceSubscription deleteMany
   */
  export type ServiceSubscriptionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServiceSubscriptions to delete
     */
    where?: ServiceSubscriptionWhereInput
    /**
     * Limit how many ServiceSubscriptions to delete.
     */
    limit?: number
  }

  /**
   * ServiceSubscription without action
   */
  export type ServiceSubscriptionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServiceSubscription
     */
    select?: ServiceSubscriptionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServiceSubscription
     */
    omit?: ServiceSubscriptionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceSubscriptionInclude<ExtArgs> | null
  }


  /**
   * Model PlatformAccessToken
   */

  export type AggregatePlatformAccessToken = {
    _count: PlatformAccessTokenCountAggregateOutputType | null
    _avg: PlatformAccessTokenAvgAggregateOutputType | null
    _sum: PlatformAccessTokenSumAggregateOutputType | null
    _min: PlatformAccessTokenMinAggregateOutputType | null
    _max: PlatformAccessTokenMaxAggregateOutputType | null
  }

  export type PlatformAccessTokenAvgAggregateOutputType = {
    providerId: number | null
  }

  export type PlatformAccessTokenSumAggregateOutputType = {
    providerId: number | null
  }

  export type PlatformAccessTokenMinAggregateOutputType = {
    id: string | null
    platformId: string | null
    providerId: number | null
    token: string | null
    zkProofRequired: boolean | null
    issuedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type PlatformAccessTokenMaxAggregateOutputType = {
    id: string | null
    platformId: string | null
    providerId: number | null
    token: string | null
    zkProofRequired: boolean | null
    issuedAt: Date | null
    expiresAt: Date | null
    isActive: boolean | null
  }

  export type PlatformAccessTokenCountAggregateOutputType = {
    id: number
    platformId: number
    providerId: number
    token: number
    serviceIds: number
    permissions: number
    zkProofRequired: number
    issuedAt: number
    expiresAt: number
    isActive: number
    _all: number
  }


  export type PlatformAccessTokenAvgAggregateInputType = {
    providerId?: true
  }

  export type PlatformAccessTokenSumAggregateInputType = {
    providerId?: true
  }

  export type PlatformAccessTokenMinAggregateInputType = {
    id?: true
    platformId?: true
    providerId?: true
    token?: true
    zkProofRequired?: true
    issuedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type PlatformAccessTokenMaxAggregateInputType = {
    id?: true
    platformId?: true
    providerId?: true
    token?: true
    zkProofRequired?: true
    issuedAt?: true
    expiresAt?: true
    isActive?: true
  }

  export type PlatformAccessTokenCountAggregateInputType = {
    id?: true
    platformId?: true
    providerId?: true
    token?: true
    serviceIds?: true
    permissions?: true
    zkProofRequired?: true
    issuedAt?: true
    expiresAt?: true
    isActive?: true
    _all?: true
  }

  export type PlatformAccessTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAccessToken to aggregate.
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccessTokens to fetch.
     */
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PlatformAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PlatformAccessTokens
    **/
    _count?: true | PlatformAccessTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PlatformAccessTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PlatformAccessTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PlatformAccessTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PlatformAccessTokenMaxAggregateInputType
  }

  export type GetPlatformAccessTokenAggregateType<T extends PlatformAccessTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePlatformAccessToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlatformAccessToken[P]>
      : GetScalarType<T[P], AggregatePlatformAccessToken[P]>
  }




  export type PlatformAccessTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PlatformAccessTokenWhereInput
    orderBy?: PlatformAccessTokenOrderByWithAggregationInput | PlatformAccessTokenOrderByWithAggregationInput[]
    by: PlatformAccessTokenScalarFieldEnum[] | PlatformAccessTokenScalarFieldEnum
    having?: PlatformAccessTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PlatformAccessTokenCountAggregateInputType | true
    _avg?: PlatformAccessTokenAvgAggregateInputType
    _sum?: PlatformAccessTokenSumAggregateInputType
    _min?: PlatformAccessTokenMinAggregateInputType
    _max?: PlatformAccessTokenMaxAggregateInputType
  }

  export type PlatformAccessTokenGroupByOutputType = {
    id: string
    platformId: string
    providerId: number
    token: string
    serviceIds: string[]
    permissions: JsonValue
    zkProofRequired: boolean
    issuedAt: Date
    expiresAt: Date
    isActive: boolean
    _count: PlatformAccessTokenCountAggregateOutputType | null
    _avg: PlatformAccessTokenAvgAggregateOutputType | null
    _sum: PlatformAccessTokenSumAggregateOutputType | null
    _min: PlatformAccessTokenMinAggregateOutputType | null
    _max: PlatformAccessTokenMaxAggregateOutputType | null
  }

  type GetPlatformAccessTokenGroupByPayload<T extends PlatformAccessTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PlatformAccessTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PlatformAccessTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PlatformAccessTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PlatformAccessTokenGroupByOutputType[P]>
        }
      >
    >


  export type PlatformAccessTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    providerId?: boolean
    token?: boolean
    serviceIds?: boolean
    permissions?: boolean
    zkProofRequired?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccessToken"]>

  export type PlatformAccessTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    providerId?: boolean
    token?: boolean
    serviceIds?: boolean
    permissions?: boolean
    zkProofRequired?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccessToken"]>

  export type PlatformAccessTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    platformId?: boolean
    providerId?: boolean
    token?: boolean
    serviceIds?: boolean
    permissions?: boolean
    zkProofRequired?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["platformAccessToken"]>

  export type PlatformAccessTokenSelectScalar = {
    id?: boolean
    platformId?: boolean
    providerId?: boolean
    token?: boolean
    serviceIds?: boolean
    permissions?: boolean
    zkProofRequired?: boolean
    issuedAt?: boolean
    expiresAt?: boolean
    isActive?: boolean
  }

  export type PlatformAccessTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "platformId" | "providerId" | "token" | "serviceIds" | "permissions" | "zkProofRequired" | "issuedAt" | "expiresAt" | "isActive", ExtArgs["result"]["platformAccessToken"]>
  export type PlatformAccessTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type PlatformAccessTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type PlatformAccessTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    platform?: boolean | PlatformDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $PlatformAccessTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PlatformAccessToken"
    objects: {
      platform: Prisma.$PlatformPayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      platformId: string
      providerId: number
      token: string
      serviceIds: string[]
      permissions: Prisma.JsonValue
      zkProofRequired: boolean
      issuedAt: Date
      expiresAt: Date
      isActive: boolean
    }, ExtArgs["result"]["platformAccessToken"]>
    composites: {}
  }

  type PlatformAccessTokenGetPayload<S extends boolean | null | undefined | PlatformAccessTokenDefaultArgs> = $Result.GetResult<Prisma.$PlatformAccessTokenPayload, S>

  type PlatformAccessTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PlatformAccessTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PlatformAccessTokenCountAggregateInputType | true
    }

  export interface PlatformAccessTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PlatformAccessToken'], meta: { name: 'PlatformAccessToken' } }
    /**
     * Find zero or one PlatformAccessToken that matches the filter.
     * @param {PlatformAccessTokenFindUniqueArgs} args - Arguments to find a PlatformAccessToken
     * @example
     * // Get one PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PlatformAccessTokenFindUniqueArgs>(args: SelectSubset<T, PlatformAccessTokenFindUniqueArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PlatformAccessToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PlatformAccessTokenFindUniqueOrThrowArgs} args - Arguments to find a PlatformAccessToken
     * @example
     * // Get one PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PlatformAccessTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PlatformAccessTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAccessToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenFindFirstArgs} args - Arguments to find a PlatformAccessToken
     * @example
     * // Get one PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PlatformAccessTokenFindFirstArgs>(args?: SelectSubset<T, PlatformAccessTokenFindFirstArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PlatformAccessToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenFindFirstOrThrowArgs} args - Arguments to find a PlatformAccessToken
     * @example
     * // Get one PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PlatformAccessTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PlatformAccessTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PlatformAccessTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PlatformAccessTokens
     * const platformAccessTokens = await prisma.platformAccessToken.findMany()
     * 
     * // Get first 10 PlatformAccessTokens
     * const platformAccessTokens = await prisma.platformAccessToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const platformAccessTokenWithIdOnly = await prisma.platformAccessToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PlatformAccessTokenFindManyArgs>(args?: SelectSubset<T, PlatformAccessTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PlatformAccessToken.
     * @param {PlatformAccessTokenCreateArgs} args - Arguments to create a PlatformAccessToken.
     * @example
     * // Create one PlatformAccessToken
     * const PlatformAccessToken = await prisma.platformAccessToken.create({
     *   data: {
     *     // ... data to create a PlatformAccessToken
     *   }
     * })
     * 
     */
    create<T extends PlatformAccessTokenCreateArgs>(args: SelectSubset<T, PlatformAccessTokenCreateArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PlatformAccessTokens.
     * @param {PlatformAccessTokenCreateManyArgs} args - Arguments to create many PlatformAccessTokens.
     * @example
     * // Create many PlatformAccessTokens
     * const platformAccessToken = await prisma.platformAccessToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PlatformAccessTokenCreateManyArgs>(args?: SelectSubset<T, PlatformAccessTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PlatformAccessTokens and returns the data saved in the database.
     * @param {PlatformAccessTokenCreateManyAndReturnArgs} args - Arguments to create many PlatformAccessTokens.
     * @example
     * // Create many PlatformAccessTokens
     * const platformAccessToken = await prisma.platformAccessToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PlatformAccessTokens and only return the `id`
     * const platformAccessTokenWithIdOnly = await prisma.platformAccessToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PlatformAccessTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PlatformAccessTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PlatformAccessToken.
     * @param {PlatformAccessTokenDeleteArgs} args - Arguments to delete one PlatformAccessToken.
     * @example
     * // Delete one PlatformAccessToken
     * const PlatformAccessToken = await prisma.platformAccessToken.delete({
     *   where: {
     *     // ... filter to delete one PlatformAccessToken
     *   }
     * })
     * 
     */
    delete<T extends PlatformAccessTokenDeleteArgs>(args: SelectSubset<T, PlatformAccessTokenDeleteArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PlatformAccessToken.
     * @param {PlatformAccessTokenUpdateArgs} args - Arguments to update one PlatformAccessToken.
     * @example
     * // Update one PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PlatformAccessTokenUpdateArgs>(args: SelectSubset<T, PlatformAccessTokenUpdateArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PlatformAccessTokens.
     * @param {PlatformAccessTokenDeleteManyArgs} args - Arguments to filter PlatformAccessTokens to delete.
     * @example
     * // Delete a few PlatformAccessTokens
     * const { count } = await prisma.platformAccessToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PlatformAccessTokenDeleteManyArgs>(args?: SelectSubset<T, PlatformAccessTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PlatformAccessTokens
     * const platformAccessToken = await prisma.platformAccessToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PlatformAccessTokenUpdateManyArgs>(args: SelectSubset<T, PlatformAccessTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PlatformAccessTokens and returns the data updated in the database.
     * @param {PlatformAccessTokenUpdateManyAndReturnArgs} args - Arguments to update many PlatformAccessTokens.
     * @example
     * // Update many PlatformAccessTokens
     * const platformAccessToken = await prisma.platformAccessToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PlatformAccessTokens and only return the `id`
     * const platformAccessTokenWithIdOnly = await prisma.platformAccessToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PlatformAccessTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PlatformAccessTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PlatformAccessToken.
     * @param {PlatformAccessTokenUpsertArgs} args - Arguments to update or create a PlatformAccessToken.
     * @example
     * // Update or create a PlatformAccessToken
     * const platformAccessToken = await prisma.platformAccessToken.upsert({
     *   create: {
     *     // ... data to create a PlatformAccessToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PlatformAccessToken we want to update
     *   }
     * })
     */
    upsert<T extends PlatformAccessTokenUpsertArgs>(args: SelectSubset<T, PlatformAccessTokenUpsertArgs<ExtArgs>>): Prisma__PlatformAccessTokenClient<$Result.GetResult<Prisma.$PlatformAccessTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PlatformAccessTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenCountArgs} args - Arguments to filter PlatformAccessTokens to count.
     * @example
     * // Count the number of PlatformAccessTokens
     * const count = await prisma.platformAccessToken.count({
     *   where: {
     *     // ... the filter for the PlatformAccessTokens we want to count
     *   }
     * })
    **/
    count<T extends PlatformAccessTokenCountArgs>(
      args?: Subset<T, PlatformAccessTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PlatformAccessTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PlatformAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PlatformAccessTokenAggregateArgs>(args: Subset<T, PlatformAccessTokenAggregateArgs>): Prisma.PrismaPromise<GetPlatformAccessTokenAggregateType<T>>

    /**
     * Group by PlatformAccessToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PlatformAccessTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PlatformAccessTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PlatformAccessTokenGroupByArgs['orderBy'] }
        : { orderBy?: PlatformAccessTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PlatformAccessTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlatformAccessTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PlatformAccessToken model
   */
  readonly fields: PlatformAccessTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PlatformAccessToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PlatformAccessTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    platform<T extends PlatformDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PlatformDefaultArgs<ExtArgs>>): Prisma__PlatformClient<$Result.GetResult<Prisma.$PlatformPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PlatformAccessToken model
   */
  interface PlatformAccessTokenFieldRefs {
    readonly id: FieldRef<"PlatformAccessToken", 'String'>
    readonly platformId: FieldRef<"PlatformAccessToken", 'String'>
    readonly providerId: FieldRef<"PlatformAccessToken", 'Int'>
    readonly token: FieldRef<"PlatformAccessToken", 'String'>
    readonly serviceIds: FieldRef<"PlatformAccessToken", 'String[]'>
    readonly permissions: FieldRef<"PlatformAccessToken", 'Json'>
    readonly zkProofRequired: FieldRef<"PlatformAccessToken", 'Boolean'>
    readonly issuedAt: FieldRef<"PlatformAccessToken", 'DateTime'>
    readonly expiresAt: FieldRef<"PlatformAccessToken", 'DateTime'>
    readonly isActive: FieldRef<"PlatformAccessToken", 'Boolean'>
  }
    

  // Custom InputTypes
  /**
   * PlatformAccessToken findUnique
   */
  export type PlatformAccessTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccessToken to fetch.
     */
    where: PlatformAccessTokenWhereUniqueInput
  }

  /**
   * PlatformAccessToken findUniqueOrThrow
   */
  export type PlatformAccessTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccessToken to fetch.
     */
    where: PlatformAccessTokenWhereUniqueInput
  }

  /**
   * PlatformAccessToken findFirst
   */
  export type PlatformAccessTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccessToken to fetch.
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccessTokens to fetch.
     */
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAccessTokens.
     */
    cursor?: PlatformAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAccessTokens.
     */
    distinct?: PlatformAccessTokenScalarFieldEnum | PlatformAccessTokenScalarFieldEnum[]
  }

  /**
   * PlatformAccessToken findFirstOrThrow
   */
  export type PlatformAccessTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccessToken to fetch.
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccessTokens to fetch.
     */
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PlatformAccessTokens.
     */
    cursor?: PlatformAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccessTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PlatformAccessTokens.
     */
    distinct?: PlatformAccessTokenScalarFieldEnum | PlatformAccessTokenScalarFieldEnum[]
  }

  /**
   * PlatformAccessToken findMany
   */
  export type PlatformAccessTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter, which PlatformAccessTokens to fetch.
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PlatformAccessTokens to fetch.
     */
    orderBy?: PlatformAccessTokenOrderByWithRelationInput | PlatformAccessTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PlatformAccessTokens.
     */
    cursor?: PlatformAccessTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PlatformAccessTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PlatformAccessTokens.
     */
    skip?: number
    distinct?: PlatformAccessTokenScalarFieldEnum | PlatformAccessTokenScalarFieldEnum[]
  }

  /**
   * PlatformAccessToken create
   */
  export type PlatformAccessTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a PlatformAccessToken.
     */
    data: XOR<PlatformAccessTokenCreateInput, PlatformAccessTokenUncheckedCreateInput>
  }

  /**
   * PlatformAccessToken createMany
   */
  export type PlatformAccessTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PlatformAccessTokens.
     */
    data: PlatformAccessTokenCreateManyInput | PlatformAccessTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PlatformAccessToken createManyAndReturn
   */
  export type PlatformAccessTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PlatformAccessTokens.
     */
    data: PlatformAccessTokenCreateManyInput | PlatformAccessTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAccessToken update
   */
  export type PlatformAccessTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a PlatformAccessToken.
     */
    data: XOR<PlatformAccessTokenUpdateInput, PlatformAccessTokenUncheckedUpdateInput>
    /**
     * Choose, which PlatformAccessToken to update.
     */
    where: PlatformAccessTokenWhereUniqueInput
  }

  /**
   * PlatformAccessToken updateMany
   */
  export type PlatformAccessTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PlatformAccessTokens.
     */
    data: XOR<PlatformAccessTokenUpdateManyMutationInput, PlatformAccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAccessTokens to update
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * Limit how many PlatformAccessTokens to update.
     */
    limit?: number
  }

  /**
   * PlatformAccessToken updateManyAndReturn
   */
  export type PlatformAccessTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * The data used to update PlatformAccessTokens.
     */
    data: XOR<PlatformAccessTokenUpdateManyMutationInput, PlatformAccessTokenUncheckedUpdateManyInput>
    /**
     * Filter which PlatformAccessTokens to update
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * Limit how many PlatformAccessTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PlatformAccessToken upsert
   */
  export type PlatformAccessTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the PlatformAccessToken to update in case it exists.
     */
    where: PlatformAccessTokenWhereUniqueInput
    /**
     * In case the PlatformAccessToken found by the `where` argument doesn't exist, create a new PlatformAccessToken with this data.
     */
    create: XOR<PlatformAccessTokenCreateInput, PlatformAccessTokenUncheckedCreateInput>
    /**
     * In case the PlatformAccessToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PlatformAccessTokenUpdateInput, PlatformAccessTokenUncheckedUpdateInput>
  }

  /**
   * PlatformAccessToken delete
   */
  export type PlatformAccessTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
    /**
     * Filter which PlatformAccessToken to delete.
     */
    where: PlatformAccessTokenWhereUniqueInput
  }

  /**
   * PlatformAccessToken deleteMany
   */
  export type PlatformAccessTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PlatformAccessTokens to delete
     */
    where?: PlatformAccessTokenWhereInput
    /**
     * Limit how many PlatformAccessTokens to delete.
     */
    limit?: number
  }

  /**
   * PlatformAccessToken without action
   */
  export type PlatformAccessTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PlatformAccessToken
     */
    select?: PlatformAccessTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PlatformAccessToken
     */
    omit?: PlatformAccessTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PlatformAccessTokenInclude<ExtArgs> | null
  }


  /**
   * Model ServicePermission
   */

  export type AggregateServicePermission = {
    _count: ServicePermissionCountAggregateOutputType | null
    _avg: ServicePermissionAvgAggregateOutputType | null
    _sum: ServicePermissionSumAggregateOutputType | null
    _min: ServicePermissionMinAggregateOutputType | null
    _max: ServicePermissionMaxAggregateOutputType | null
  }

  export type ServicePermissionAvgAggregateOutputType = {
    providerId: number | null
  }

  export type ServicePermissionSumAggregateOutputType = {
    providerId: number | null
  }

  export type ServicePermissionMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    providerId: number | null
    accessGranted: boolean | null
    jwtToken: string | null
    grantedAt: Date | null
    updatedAt: Date | null
  }

  export type ServicePermissionMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    providerId: number | null
    accessGranted: boolean | null
    jwtToken: string | null
    grantedAt: Date | null
    updatedAt: Date | null
  }

  export type ServicePermissionCountAggregateOutputType = {
    id: number
    contractId: number
    serviceId: number
    providerId: number
    accessGranted: number
    jwtToken: number
    grantedAt: number
    updatedAt: number
    _all: number
  }


  export type ServicePermissionAvgAggregateInputType = {
    providerId?: true
  }

  export type ServicePermissionSumAggregateInputType = {
    providerId?: true
  }

  export type ServicePermissionMinAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    accessGranted?: true
    jwtToken?: true
    grantedAt?: true
    updatedAt?: true
  }

  export type ServicePermissionMaxAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    accessGranted?: true
    jwtToken?: true
    grantedAt?: true
    updatedAt?: true
  }

  export type ServicePermissionCountAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    accessGranted?: true
    jwtToken?: true
    grantedAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ServicePermissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePermission to aggregate.
     */
    where?: ServicePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePermissions to fetch.
     */
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ServicePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ServicePermissions
    **/
    _count?: true | ServicePermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ServicePermissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ServicePermissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ServicePermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ServicePermissionMaxAggregateInputType
  }

  export type GetServicePermissionAggregateType<T extends ServicePermissionAggregateArgs> = {
        [P in keyof T & keyof AggregateServicePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateServicePermission[P]>
      : GetScalarType<T[P], AggregateServicePermission[P]>
  }




  export type ServicePermissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ServicePermissionWhereInput
    orderBy?: ServicePermissionOrderByWithAggregationInput | ServicePermissionOrderByWithAggregationInput[]
    by: ServicePermissionScalarFieldEnum[] | ServicePermissionScalarFieldEnum
    having?: ServicePermissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ServicePermissionCountAggregateInputType | true
    _avg?: ServicePermissionAvgAggregateInputType
    _sum?: ServicePermissionSumAggregateInputType
    _min?: ServicePermissionMinAggregateInputType
    _max?: ServicePermissionMaxAggregateInputType
  }

  export type ServicePermissionGroupByOutputType = {
    id: string
    contractId: string
    serviceId: string
    providerId: number
    accessGranted: boolean
    jwtToken: string | null
    grantedAt: Date
    updatedAt: Date
    _count: ServicePermissionCountAggregateOutputType | null
    _avg: ServicePermissionAvgAggregateOutputType | null
    _sum: ServicePermissionSumAggregateOutputType | null
    _min: ServicePermissionMinAggregateOutputType | null
    _max: ServicePermissionMaxAggregateOutputType | null
  }

  type GetServicePermissionGroupByPayload<T extends ServicePermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ServicePermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ServicePermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ServicePermissionGroupByOutputType[P]>
            : GetScalarType<T[P], ServicePermissionGroupByOutputType[P]>
        }
      >
    >


  export type ServicePermissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessGranted?: boolean
    jwtToken?: boolean
    grantedAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePermission"]>

  export type ServicePermissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessGranted?: boolean
    jwtToken?: boolean
    grantedAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePermission"]>

  export type ServicePermissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessGranted?: boolean
    jwtToken?: boolean
    grantedAt?: boolean
    updatedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["servicePermission"]>

  export type ServicePermissionSelectScalar = {
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    accessGranted?: boolean
    jwtToken?: boolean
    grantedAt?: boolean
    updatedAt?: boolean
  }

  export type ServicePermissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "serviceId" | "providerId" | "accessGranted" | "jwtToken" | "grantedAt" | "updatedAt", ExtArgs["result"]["servicePermission"]>
  export type ServicePermissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServicePermissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type ServicePermissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $ServicePermissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ServicePermission"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      serviceId: string
      providerId: number
      accessGranted: boolean
      jwtToken: string | null
      grantedAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["servicePermission"]>
    composites: {}
  }

  type ServicePermissionGetPayload<S extends boolean | null | undefined | ServicePermissionDefaultArgs> = $Result.GetResult<Prisma.$ServicePermissionPayload, S>

  type ServicePermissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ServicePermissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ServicePermissionCountAggregateInputType | true
    }

  export interface ServicePermissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ServicePermission'], meta: { name: 'ServicePermission' } }
    /**
     * Find zero or one ServicePermission that matches the filter.
     * @param {ServicePermissionFindUniqueArgs} args - Arguments to find a ServicePermission
     * @example
     * // Get one ServicePermission
     * const servicePermission = await prisma.servicePermission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ServicePermissionFindUniqueArgs>(args: SelectSubset<T, ServicePermissionFindUniqueArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ServicePermission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ServicePermissionFindUniqueOrThrowArgs} args - Arguments to find a ServicePermission
     * @example
     * // Get one ServicePermission
     * const servicePermission = await prisma.servicePermission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ServicePermissionFindUniqueOrThrowArgs>(args: SelectSubset<T, ServicePermissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePermission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionFindFirstArgs} args - Arguments to find a ServicePermission
     * @example
     * // Get one ServicePermission
     * const servicePermission = await prisma.servicePermission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ServicePermissionFindFirstArgs>(args?: SelectSubset<T, ServicePermissionFindFirstArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ServicePermission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionFindFirstOrThrowArgs} args - Arguments to find a ServicePermission
     * @example
     * // Get one ServicePermission
     * const servicePermission = await prisma.servicePermission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ServicePermissionFindFirstOrThrowArgs>(args?: SelectSubset<T, ServicePermissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ServicePermissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ServicePermissions
     * const servicePermissions = await prisma.servicePermission.findMany()
     * 
     * // Get first 10 ServicePermissions
     * const servicePermissions = await prisma.servicePermission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const servicePermissionWithIdOnly = await prisma.servicePermission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ServicePermissionFindManyArgs>(args?: SelectSubset<T, ServicePermissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ServicePermission.
     * @param {ServicePermissionCreateArgs} args - Arguments to create a ServicePermission.
     * @example
     * // Create one ServicePermission
     * const ServicePermission = await prisma.servicePermission.create({
     *   data: {
     *     // ... data to create a ServicePermission
     *   }
     * })
     * 
     */
    create<T extends ServicePermissionCreateArgs>(args: SelectSubset<T, ServicePermissionCreateArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ServicePermissions.
     * @param {ServicePermissionCreateManyArgs} args - Arguments to create many ServicePermissions.
     * @example
     * // Create many ServicePermissions
     * const servicePermission = await prisma.servicePermission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ServicePermissionCreateManyArgs>(args?: SelectSubset<T, ServicePermissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ServicePermissions and returns the data saved in the database.
     * @param {ServicePermissionCreateManyAndReturnArgs} args - Arguments to create many ServicePermissions.
     * @example
     * // Create many ServicePermissions
     * const servicePermission = await prisma.servicePermission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ServicePermissions and only return the `id`
     * const servicePermissionWithIdOnly = await prisma.servicePermission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ServicePermissionCreateManyAndReturnArgs>(args?: SelectSubset<T, ServicePermissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ServicePermission.
     * @param {ServicePermissionDeleteArgs} args - Arguments to delete one ServicePermission.
     * @example
     * // Delete one ServicePermission
     * const ServicePermission = await prisma.servicePermission.delete({
     *   where: {
     *     // ... filter to delete one ServicePermission
     *   }
     * })
     * 
     */
    delete<T extends ServicePermissionDeleteArgs>(args: SelectSubset<T, ServicePermissionDeleteArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ServicePermission.
     * @param {ServicePermissionUpdateArgs} args - Arguments to update one ServicePermission.
     * @example
     * // Update one ServicePermission
     * const servicePermission = await prisma.servicePermission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ServicePermissionUpdateArgs>(args: SelectSubset<T, ServicePermissionUpdateArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ServicePermissions.
     * @param {ServicePermissionDeleteManyArgs} args - Arguments to filter ServicePermissions to delete.
     * @example
     * // Delete a few ServicePermissions
     * const { count } = await prisma.servicePermission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ServicePermissionDeleteManyArgs>(args?: SelectSubset<T, ServicePermissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ServicePermissions
     * const servicePermission = await prisma.servicePermission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ServicePermissionUpdateManyArgs>(args: SelectSubset<T, ServicePermissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ServicePermissions and returns the data updated in the database.
     * @param {ServicePermissionUpdateManyAndReturnArgs} args - Arguments to update many ServicePermissions.
     * @example
     * // Update many ServicePermissions
     * const servicePermission = await prisma.servicePermission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ServicePermissions and only return the `id`
     * const servicePermissionWithIdOnly = await prisma.servicePermission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ServicePermissionUpdateManyAndReturnArgs>(args: SelectSubset<T, ServicePermissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ServicePermission.
     * @param {ServicePermissionUpsertArgs} args - Arguments to update or create a ServicePermission.
     * @example
     * // Update or create a ServicePermission
     * const servicePermission = await prisma.servicePermission.upsert({
     *   create: {
     *     // ... data to create a ServicePermission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ServicePermission we want to update
     *   }
     * })
     */
    upsert<T extends ServicePermissionUpsertArgs>(args: SelectSubset<T, ServicePermissionUpsertArgs<ExtArgs>>): Prisma__ServicePermissionClient<$Result.GetResult<Prisma.$ServicePermissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ServicePermissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionCountArgs} args - Arguments to filter ServicePermissions to count.
     * @example
     * // Count the number of ServicePermissions
     * const count = await prisma.servicePermission.count({
     *   where: {
     *     // ... the filter for the ServicePermissions we want to count
     *   }
     * })
    **/
    count<T extends ServicePermissionCountArgs>(
      args?: Subset<T, ServicePermissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ServicePermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ServicePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ServicePermissionAggregateArgs>(args: Subset<T, ServicePermissionAggregateArgs>): Prisma.PrismaPromise<GetServicePermissionAggregateType<T>>

    /**
     * Group by ServicePermission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ServicePermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ServicePermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ServicePermissionGroupByArgs['orderBy'] }
        : { orderBy?: ServicePermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ServicePermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetServicePermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ServicePermission model
   */
  readonly fields: ServicePermissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ServicePermission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ServicePermissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ServicePermission model
   */
  interface ServicePermissionFieldRefs {
    readonly id: FieldRef<"ServicePermission", 'String'>
    readonly contractId: FieldRef<"ServicePermission", 'String'>
    readonly serviceId: FieldRef<"ServicePermission", 'String'>
    readonly providerId: FieldRef<"ServicePermission", 'Int'>
    readonly accessGranted: FieldRef<"ServicePermission", 'Boolean'>
    readonly jwtToken: FieldRef<"ServicePermission", 'String'>
    readonly grantedAt: FieldRef<"ServicePermission", 'DateTime'>
    readonly updatedAt: FieldRef<"ServicePermission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ServicePermission findUnique
   */
  export type ServicePermissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePermission to fetch.
     */
    where: ServicePermissionWhereUniqueInput
  }

  /**
   * ServicePermission findUniqueOrThrow
   */
  export type ServicePermissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePermission to fetch.
     */
    where: ServicePermissionWhereUniqueInput
  }

  /**
   * ServicePermission findFirst
   */
  export type ServicePermissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePermission to fetch.
     */
    where?: ServicePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePermissions to fetch.
     */
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePermissions.
     */
    cursor?: ServicePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePermissions.
     */
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * ServicePermission findFirstOrThrow
   */
  export type ServicePermissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePermission to fetch.
     */
    where?: ServicePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePermissions to fetch.
     */
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ServicePermissions.
     */
    cursor?: ServicePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePermissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ServicePermissions.
     */
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * ServicePermission findMany
   */
  export type ServicePermissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter, which ServicePermissions to fetch.
     */
    where?: ServicePermissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ServicePermissions to fetch.
     */
    orderBy?: ServicePermissionOrderByWithRelationInput | ServicePermissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ServicePermissions.
     */
    cursor?: ServicePermissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ServicePermissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ServicePermissions.
     */
    skip?: number
    distinct?: ServicePermissionScalarFieldEnum | ServicePermissionScalarFieldEnum[]
  }

  /**
   * ServicePermission create
   */
  export type ServicePermissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * The data needed to create a ServicePermission.
     */
    data: XOR<ServicePermissionCreateInput, ServicePermissionUncheckedCreateInput>
  }

  /**
   * ServicePermission createMany
   */
  export type ServicePermissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ServicePermissions.
     */
    data: ServicePermissionCreateManyInput | ServicePermissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ServicePermission createManyAndReturn
   */
  export type ServicePermissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * The data used to create many ServicePermissions.
     */
    data: ServicePermissionCreateManyInput | ServicePermissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePermission update
   */
  export type ServicePermissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * The data needed to update a ServicePermission.
     */
    data: XOR<ServicePermissionUpdateInput, ServicePermissionUncheckedUpdateInput>
    /**
     * Choose, which ServicePermission to update.
     */
    where: ServicePermissionWhereUniqueInput
  }

  /**
   * ServicePermission updateMany
   */
  export type ServicePermissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ServicePermissions.
     */
    data: XOR<ServicePermissionUpdateManyMutationInput, ServicePermissionUncheckedUpdateManyInput>
    /**
     * Filter which ServicePermissions to update
     */
    where?: ServicePermissionWhereInput
    /**
     * Limit how many ServicePermissions to update.
     */
    limit?: number
  }

  /**
   * ServicePermission updateManyAndReturn
   */
  export type ServicePermissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * The data used to update ServicePermissions.
     */
    data: XOR<ServicePermissionUpdateManyMutationInput, ServicePermissionUncheckedUpdateManyInput>
    /**
     * Filter which ServicePermissions to update
     */
    where?: ServicePermissionWhereInput
    /**
     * Limit how many ServicePermissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ServicePermission upsert
   */
  export type ServicePermissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * The filter to search for the ServicePermission to update in case it exists.
     */
    where: ServicePermissionWhereUniqueInput
    /**
     * In case the ServicePermission found by the `where` argument doesn't exist, create a new ServicePermission with this data.
     */
    create: XOR<ServicePermissionCreateInput, ServicePermissionUncheckedCreateInput>
    /**
     * In case the ServicePermission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ServicePermissionUpdateInput, ServicePermissionUncheckedUpdateInput>
  }

  /**
   * ServicePermission delete
   */
  export type ServicePermissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
    /**
     * Filter which ServicePermission to delete.
     */
    where: ServicePermissionWhereUniqueInput
  }

  /**
   * ServicePermission deleteMany
   */
  export type ServicePermissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ServicePermissions to delete
     */
    where?: ServicePermissionWhereInput
    /**
     * Limit how many ServicePermissions to delete.
     */
    limit?: number
  }

  /**
   * ServicePermission without action
   */
  export type ServicePermissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ServicePermission
     */
    select?: ServicePermissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ServicePermission
     */
    omit?: ServicePermissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServicePermissionInclude<ExtArgs> | null
  }


  /**
   * Model AccessLog
   */

  export type AggregateAccessLog = {
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  export type AccessLogAvgAggregateOutputType = {
    providerId: number | null
  }

  export type AccessLogSumAggregateOutputType = {
    providerId: number | null
  }

  export type AccessLogMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    providerId: number | null
    action: string | null
    zkProofHash: string | null
    timestamp: Date | null
  }

  export type AccessLogMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    providerId: number | null
    action: string | null
    zkProofHash: string | null
    timestamp: Date | null
  }

  export type AccessLogCountAggregateOutputType = {
    id: number
    contractId: number
    serviceId: number
    providerId: number
    action: number
    zkProofHash: number
    metadata: number
    timestamp: number
    _all: number
  }


  export type AccessLogAvgAggregateInputType = {
    providerId?: true
  }

  export type AccessLogSumAggregateInputType = {
    providerId?: true
  }

  export type AccessLogMinAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    action?: true
    zkProofHash?: true
    timestamp?: true
  }

  export type AccessLogMaxAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    action?: true
    zkProofHash?: true
    timestamp?: true
  }

  export type AccessLogCountAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    providerId?: true
    action?: true
    zkProofHash?: true
    metadata?: true
    timestamp?: true
    _all?: true
  }

  export type AccessLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLog to aggregate.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AccessLogs
    **/
    _count?: true | AccessLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessLogMaxAggregateInputType
  }

  export type GetAccessLogAggregateType<T extends AccessLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAccessLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccessLog[P]>
      : GetScalarType<T[P], AggregateAccessLog[P]>
  }




  export type AccessLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessLogWhereInput
    orderBy?: AccessLogOrderByWithAggregationInput | AccessLogOrderByWithAggregationInput[]
    by: AccessLogScalarFieldEnum[] | AccessLogScalarFieldEnum
    having?: AccessLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessLogCountAggregateInputType | true
    _avg?: AccessLogAvgAggregateInputType
    _sum?: AccessLogSumAggregateInputType
    _min?: AccessLogMinAggregateInputType
    _max?: AccessLogMaxAggregateInputType
  }

  export type AccessLogGroupByOutputType = {
    id: string
    contractId: string | null
    serviceId: string
    providerId: number
    action: string
    zkProofHash: string | null
    metadata: JsonValue | null
    timestamp: Date
    _count: AccessLogCountAggregateOutputType | null
    _avg: AccessLogAvgAggregateOutputType | null
    _sum: AccessLogSumAggregateOutputType | null
    _min: AccessLogMinAggregateOutputType | null
    _max: AccessLogMaxAggregateOutputType | null
  }

  type GetAccessLogGroupByPayload<T extends AccessLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
            : GetScalarType<T[P], AccessLogGroupByOutputType[P]>
        }
      >
    >


  export type AccessLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    action?: boolean
    zkProofHash?: boolean
    metadata?: boolean
    timestamp?: boolean
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    action?: boolean
    zkProofHash?: boolean
    metadata?: boolean
    timestamp?: boolean
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    action?: boolean
    zkProofHash?: boolean
    metadata?: boolean
    timestamp?: boolean
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["accessLog"]>

  export type AccessLogSelectScalar = {
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    providerId?: boolean
    action?: boolean
    zkProofHash?: boolean
    metadata?: boolean
    timestamp?: boolean
  }

  export type AccessLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "serviceId" | "providerId" | "action" | "zkProofHash" | "metadata" | "timestamp", ExtArgs["result"]["accessLog"]>
  export type AccessLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type AccessLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }
  export type AccessLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | AccessLog$contractArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
  }

  export type $AccessLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AccessLog"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs> | null
      service: Prisma.$ServicePayload<ExtArgs>
      provider: Prisma.$ProviderPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string | null
      serviceId: string
      providerId: number
      action: string
      zkProofHash: string | null
      metadata: Prisma.JsonValue | null
      timestamp: Date
    }, ExtArgs["result"]["accessLog"]>
    composites: {}
  }

  type AccessLogGetPayload<S extends boolean | null | undefined | AccessLogDefaultArgs> = $Result.GetResult<Prisma.$AccessLogPayload, S>

  type AccessLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccessLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccessLogCountAggregateInputType | true
    }

  export interface AccessLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AccessLog'], meta: { name: 'AccessLog' } }
    /**
     * Find zero or one AccessLog that matches the filter.
     * @param {AccessLogFindUniqueArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccessLogFindUniqueArgs>(args: SelectSubset<T, AccessLogFindUniqueArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one AccessLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccessLogFindUniqueOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccessLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AccessLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccessLogFindFirstArgs>(args?: SelectSubset<T, AccessLogFindFirstArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first AccessLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindFirstOrThrowArgs} args - Arguments to find a AccessLog
     * @example
     * // Get one AccessLog
     * const accessLog = await prisma.accessLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccessLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AccessLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more AccessLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AccessLogs
     * const accessLogs = await prisma.accessLog.findMany()
     * 
     * // Get first 10 AccessLogs
     * const accessLogs = await prisma.accessLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccessLogFindManyArgs>(args?: SelectSubset<T, AccessLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a AccessLog.
     * @param {AccessLogCreateArgs} args - Arguments to create a AccessLog.
     * @example
     * // Create one AccessLog
     * const AccessLog = await prisma.accessLog.create({
     *   data: {
     *     // ... data to create a AccessLog
     *   }
     * })
     * 
     */
    create<T extends AccessLogCreateArgs>(args: SelectSubset<T, AccessLogCreateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many AccessLogs.
     * @param {AccessLogCreateManyArgs} args - Arguments to create many AccessLogs.
     * @example
     * // Create many AccessLogs
     * const accessLog = await prisma.accessLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccessLogCreateManyArgs>(args?: SelectSubset<T, AccessLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AccessLogs and returns the data saved in the database.
     * @param {AccessLogCreateManyAndReturnArgs} args - Arguments to create many AccessLogs.
     * @example
     * // Create many AccessLogs
     * const accessLog = await prisma.accessLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AccessLogs and only return the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccessLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AccessLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a AccessLog.
     * @param {AccessLogDeleteArgs} args - Arguments to delete one AccessLog.
     * @example
     * // Delete one AccessLog
     * const AccessLog = await prisma.accessLog.delete({
     *   where: {
     *     // ... filter to delete one AccessLog
     *   }
     * })
     * 
     */
    delete<T extends AccessLogDeleteArgs>(args: SelectSubset<T, AccessLogDeleteArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one AccessLog.
     * @param {AccessLogUpdateArgs} args - Arguments to update one AccessLog.
     * @example
     * // Update one AccessLog
     * const accessLog = await prisma.accessLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccessLogUpdateArgs>(args: SelectSubset<T, AccessLogUpdateArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more AccessLogs.
     * @param {AccessLogDeleteManyArgs} args - Arguments to filter AccessLogs to delete.
     * @example
     * // Delete a few AccessLogs
     * const { count } = await prisma.accessLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccessLogDeleteManyArgs>(args?: SelectSubset<T, AccessLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AccessLogs
     * const accessLog = await prisma.accessLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccessLogUpdateManyArgs>(args: SelectSubset<T, AccessLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AccessLogs and returns the data updated in the database.
     * @param {AccessLogUpdateManyAndReturnArgs} args - Arguments to update many AccessLogs.
     * @example
     * // Update many AccessLogs
     * const accessLog = await prisma.accessLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more AccessLogs and only return the `id`
     * const accessLogWithIdOnly = await prisma.accessLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccessLogUpdateManyAndReturnArgs>(args: SelectSubset<T, AccessLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one AccessLog.
     * @param {AccessLogUpsertArgs} args - Arguments to update or create a AccessLog.
     * @example
     * // Update or create a AccessLog
     * const accessLog = await prisma.accessLog.upsert({
     *   create: {
     *     // ... data to create a AccessLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AccessLog we want to update
     *   }
     * })
     */
    upsert<T extends AccessLogUpsertArgs>(args: SelectSubset<T, AccessLogUpsertArgs<ExtArgs>>): Prisma__AccessLogClient<$Result.GetResult<Prisma.$AccessLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of AccessLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogCountArgs} args - Arguments to filter AccessLogs to count.
     * @example
     * // Count the number of AccessLogs
     * const count = await prisma.accessLog.count({
     *   where: {
     *     // ... the filter for the AccessLogs we want to count
     *   }
     * })
    **/
    count<T extends AccessLogCountArgs>(
      args?: Subset<T, AccessLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessLogAggregateArgs>(args: Subset<T, AccessLogAggregateArgs>): Prisma.PrismaPromise<GetAccessLogAggregateType<T>>

    /**
     * Group by AccessLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessLogGroupByArgs['orderBy'] }
        : { orderBy?: AccessLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AccessLog model
   */
  readonly fields: AccessLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AccessLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends AccessLog$contractArgs<ExtArgs> = {}>(args?: Subset<T, AccessLog$contractArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AccessLog model
   */
  interface AccessLogFieldRefs {
    readonly id: FieldRef<"AccessLog", 'String'>
    readonly contractId: FieldRef<"AccessLog", 'String'>
    readonly serviceId: FieldRef<"AccessLog", 'String'>
    readonly providerId: FieldRef<"AccessLog", 'Int'>
    readonly action: FieldRef<"AccessLog", 'String'>
    readonly zkProofHash: FieldRef<"AccessLog", 'String'>
    readonly metadata: FieldRef<"AccessLog", 'Json'>
    readonly timestamp: FieldRef<"AccessLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AccessLog findUnique
   */
  export type AccessLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findUniqueOrThrow
   */
  export type AccessLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog findFirst
   */
  export type AccessLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findFirstOrThrow
   */
  export type AccessLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLog to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AccessLogs.
     */
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog findMany
   */
  export type AccessLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter, which AccessLogs to fetch.
     */
    where?: AccessLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AccessLogs to fetch.
     */
    orderBy?: AccessLogOrderByWithRelationInput | AccessLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AccessLogs.
     */
    cursor?: AccessLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AccessLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AccessLogs.
     */
    skip?: number
    distinct?: AccessLogScalarFieldEnum | AccessLogScalarFieldEnum[]
  }

  /**
   * AccessLog create
   */
  export type AccessLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AccessLog.
     */
    data: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
  }

  /**
   * AccessLog createMany
   */
  export type AccessLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AccessLogs.
     */
    data: AccessLogCreateManyInput | AccessLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AccessLog createManyAndReturn
   */
  export type AccessLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data used to create many AccessLogs.
     */
    data: AccessLogCreateManyInput | AccessLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessLog update
   */
  export type AccessLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AccessLog.
     */
    data: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
    /**
     * Choose, which AccessLog to update.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog updateMany
   */
  export type AccessLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AccessLogs.
     */
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AccessLogs to update
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to update.
     */
    limit?: number
  }

  /**
   * AccessLog updateManyAndReturn
   */
  export type AccessLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * The data used to update AccessLogs.
     */
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyInput>
    /**
     * Filter which AccessLogs to update
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * AccessLog upsert
   */
  export type AccessLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AccessLog to update in case it exists.
     */
    where: AccessLogWhereUniqueInput
    /**
     * In case the AccessLog found by the `where` argument doesn't exist, create a new AccessLog with this data.
     */
    create: XOR<AccessLogCreateInput, AccessLogUncheckedCreateInput>
    /**
     * In case the AccessLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessLogUpdateInput, AccessLogUncheckedUpdateInput>
  }

  /**
   * AccessLog delete
   */
  export type AccessLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
    /**
     * Filter which AccessLog to delete.
     */
    where: AccessLogWhereUniqueInput
  }

  /**
   * AccessLog deleteMany
   */
  export type AccessLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AccessLogs to delete
     */
    where?: AccessLogWhereInput
    /**
     * Limit how many AccessLogs to delete.
     */
    limit?: number
  }

  /**
   * AccessLog.contract
   */
  export type AccessLog$contractArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Contract
     */
    select?: ContractSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Contract
     */
    omit?: ContractOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ContractInclude<ExtArgs> | null
    where?: ContractWhereInput
  }

  /**
   * AccessLog without action
   */
  export type AccessLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AccessLog
     */
    select?: AccessLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the AccessLog
     */
    omit?: AccessLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccessLogInclude<ExtArgs> | null
  }


  /**
   * Model UsageQuota
   */

  export type AggregateUsageQuota = {
    _count: UsageQuotaCountAggregateOutputType | null
    _avg: UsageQuotaAvgAggregateOutputType | null
    _sum: UsageQuotaSumAggregateOutputType | null
    _min: UsageQuotaMinAggregateOutputType | null
    _max: UsageQuotaMaxAggregateOutputType | null
  }

  export type UsageQuotaAvgAggregateOutputType = {
    maxRequests: number | null
    usedRequests: number | null
  }

  export type UsageQuotaSumAggregateOutputType = {
    maxRequests: number | null
    usedRequests: number | null
  }

  export type UsageQuotaMinAggregateOutputType = {
    id: string | null
    contractPermissionId: string | null
    maxRequests: number | null
    usedRequests: number | null
    timeWindow: string | null
    renewalPeriod: string | null
    lastReset: Date | null
    createdAt: Date | null
  }

  export type UsageQuotaMaxAggregateOutputType = {
    id: string | null
    contractPermissionId: string | null
    maxRequests: number | null
    usedRequests: number | null
    timeWindow: string | null
    renewalPeriod: string | null
    lastReset: Date | null
    createdAt: Date | null
  }

  export type UsageQuotaCountAggregateOutputType = {
    id: number
    contractPermissionId: number
    maxRequests: number
    usedRequests: number
    timeWindow: number
    renewalPeriod: number
    lastReset: number
    createdAt: number
    _all: number
  }


  export type UsageQuotaAvgAggregateInputType = {
    maxRequests?: true
    usedRequests?: true
  }

  export type UsageQuotaSumAggregateInputType = {
    maxRequests?: true
    usedRequests?: true
  }

  export type UsageQuotaMinAggregateInputType = {
    id?: true
    contractPermissionId?: true
    maxRequests?: true
    usedRequests?: true
    timeWindow?: true
    renewalPeriod?: true
    lastReset?: true
    createdAt?: true
  }

  export type UsageQuotaMaxAggregateInputType = {
    id?: true
    contractPermissionId?: true
    maxRequests?: true
    usedRequests?: true
    timeWindow?: true
    renewalPeriod?: true
    lastReset?: true
    createdAt?: true
  }

  export type UsageQuotaCountAggregateInputType = {
    id?: true
    contractPermissionId?: true
    maxRequests?: true
    usedRequests?: true
    timeWindow?: true
    renewalPeriod?: true
    lastReset?: true
    createdAt?: true
    _all?: true
  }

  export type UsageQuotaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageQuota to aggregate.
     */
    where?: UsageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageQuotas to fetch.
     */
    orderBy?: UsageQuotaOrderByWithRelationInput | UsageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UsageQuotas
    **/
    _count?: true | UsageQuotaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsageQuotaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsageQuotaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsageQuotaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsageQuotaMaxAggregateInputType
  }

  export type GetUsageQuotaAggregateType<T extends UsageQuotaAggregateArgs> = {
        [P in keyof T & keyof AggregateUsageQuota]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsageQuota[P]>
      : GetScalarType<T[P], AggregateUsageQuota[P]>
  }




  export type UsageQuotaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsageQuotaWhereInput
    orderBy?: UsageQuotaOrderByWithAggregationInput | UsageQuotaOrderByWithAggregationInput[]
    by: UsageQuotaScalarFieldEnum[] | UsageQuotaScalarFieldEnum
    having?: UsageQuotaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsageQuotaCountAggregateInputType | true
    _avg?: UsageQuotaAvgAggregateInputType
    _sum?: UsageQuotaSumAggregateInputType
    _min?: UsageQuotaMinAggregateInputType
    _max?: UsageQuotaMaxAggregateInputType
  }

  export type UsageQuotaGroupByOutputType = {
    id: string
    contractPermissionId: string
    maxRequests: number
    usedRequests: number
    timeWindow: string
    renewalPeriod: string
    lastReset: Date
    createdAt: Date
    _count: UsageQuotaCountAggregateOutputType | null
    _avg: UsageQuotaAvgAggregateOutputType | null
    _sum: UsageQuotaSumAggregateOutputType | null
    _min: UsageQuotaMinAggregateOutputType | null
    _max: UsageQuotaMaxAggregateOutputType | null
  }

  type GetUsageQuotaGroupByPayload<T extends UsageQuotaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsageQuotaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsageQuotaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsageQuotaGroupByOutputType[P]>
            : GetScalarType<T[P], UsageQuotaGroupByOutputType[P]>
        }
      >
    >


  export type UsageQuotaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractPermissionId?: boolean
    maxRequests?: boolean
    usedRequests?: boolean
    timeWindow?: boolean
    renewalPeriod?: boolean
    lastReset?: boolean
    createdAt?: boolean
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageQuota"]>

  export type UsageQuotaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractPermissionId?: boolean
    maxRequests?: boolean
    usedRequests?: boolean
    timeWindow?: boolean
    renewalPeriod?: boolean
    lastReset?: boolean
    createdAt?: boolean
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageQuota"]>

  export type UsageQuotaSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractPermissionId?: boolean
    maxRequests?: boolean
    usedRequests?: boolean
    timeWindow?: boolean
    renewalPeriod?: boolean
    lastReset?: boolean
    createdAt?: boolean
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usageQuota"]>

  export type UsageQuotaSelectScalar = {
    id?: boolean
    contractPermissionId?: boolean
    maxRequests?: boolean
    usedRequests?: boolean
    timeWindow?: boolean
    renewalPeriod?: boolean
    lastReset?: boolean
    createdAt?: boolean
  }

  export type UsageQuotaOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractPermissionId" | "maxRequests" | "usedRequests" | "timeWindow" | "renewalPeriod" | "lastReset" | "createdAt", ExtArgs["result"]["usageQuota"]>
  export type UsageQuotaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }
  export type UsageQuotaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }
  export type UsageQuotaIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contractPermission?: boolean | ContractPermissionDefaultArgs<ExtArgs>
  }

  export type $UsageQuotaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UsageQuota"
    objects: {
      contractPermission: Prisma.$ContractPermissionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractPermissionId: string
      maxRequests: number
      usedRequests: number
      timeWindow: string
      renewalPeriod: string
      lastReset: Date
      createdAt: Date
    }, ExtArgs["result"]["usageQuota"]>
    composites: {}
  }

  type UsageQuotaGetPayload<S extends boolean | null | undefined | UsageQuotaDefaultArgs> = $Result.GetResult<Prisma.$UsageQuotaPayload, S>

  type UsageQuotaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UsageQuotaFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsageQuotaCountAggregateInputType | true
    }

  export interface UsageQuotaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UsageQuota'], meta: { name: 'UsageQuota' } }
    /**
     * Find zero or one UsageQuota that matches the filter.
     * @param {UsageQuotaFindUniqueArgs} args - Arguments to find a UsageQuota
     * @example
     * // Get one UsageQuota
     * const usageQuota = await prisma.usageQuota.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsageQuotaFindUniqueArgs>(args: SelectSubset<T, UsageQuotaFindUniqueArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UsageQuota that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UsageQuotaFindUniqueOrThrowArgs} args - Arguments to find a UsageQuota
     * @example
     * // Get one UsageQuota
     * const usageQuota = await prisma.usageQuota.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsageQuotaFindUniqueOrThrowArgs>(args: SelectSubset<T, UsageQuotaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageQuota that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaFindFirstArgs} args - Arguments to find a UsageQuota
     * @example
     * // Get one UsageQuota
     * const usageQuota = await prisma.usageQuota.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsageQuotaFindFirstArgs>(args?: SelectSubset<T, UsageQuotaFindFirstArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UsageQuota that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaFindFirstOrThrowArgs} args - Arguments to find a UsageQuota
     * @example
     * // Get one UsageQuota
     * const usageQuota = await prisma.usageQuota.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsageQuotaFindFirstOrThrowArgs>(args?: SelectSubset<T, UsageQuotaFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UsageQuotas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UsageQuotas
     * const usageQuotas = await prisma.usageQuota.findMany()
     * 
     * // Get first 10 UsageQuotas
     * const usageQuotas = await prisma.usageQuota.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usageQuotaWithIdOnly = await prisma.usageQuota.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsageQuotaFindManyArgs>(args?: SelectSubset<T, UsageQuotaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UsageQuota.
     * @param {UsageQuotaCreateArgs} args - Arguments to create a UsageQuota.
     * @example
     * // Create one UsageQuota
     * const UsageQuota = await prisma.usageQuota.create({
     *   data: {
     *     // ... data to create a UsageQuota
     *   }
     * })
     * 
     */
    create<T extends UsageQuotaCreateArgs>(args: SelectSubset<T, UsageQuotaCreateArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UsageQuotas.
     * @param {UsageQuotaCreateManyArgs} args - Arguments to create many UsageQuotas.
     * @example
     * // Create many UsageQuotas
     * const usageQuota = await prisma.usageQuota.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsageQuotaCreateManyArgs>(args?: SelectSubset<T, UsageQuotaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UsageQuotas and returns the data saved in the database.
     * @param {UsageQuotaCreateManyAndReturnArgs} args - Arguments to create many UsageQuotas.
     * @example
     * // Create many UsageQuotas
     * const usageQuota = await prisma.usageQuota.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UsageQuotas and only return the `id`
     * const usageQuotaWithIdOnly = await prisma.usageQuota.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsageQuotaCreateManyAndReturnArgs>(args?: SelectSubset<T, UsageQuotaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UsageQuota.
     * @param {UsageQuotaDeleteArgs} args - Arguments to delete one UsageQuota.
     * @example
     * // Delete one UsageQuota
     * const UsageQuota = await prisma.usageQuota.delete({
     *   where: {
     *     // ... filter to delete one UsageQuota
     *   }
     * })
     * 
     */
    delete<T extends UsageQuotaDeleteArgs>(args: SelectSubset<T, UsageQuotaDeleteArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UsageQuota.
     * @param {UsageQuotaUpdateArgs} args - Arguments to update one UsageQuota.
     * @example
     * // Update one UsageQuota
     * const usageQuota = await prisma.usageQuota.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsageQuotaUpdateArgs>(args: SelectSubset<T, UsageQuotaUpdateArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UsageQuotas.
     * @param {UsageQuotaDeleteManyArgs} args - Arguments to filter UsageQuotas to delete.
     * @example
     * // Delete a few UsageQuotas
     * const { count } = await prisma.usageQuota.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsageQuotaDeleteManyArgs>(args?: SelectSubset<T, UsageQuotaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UsageQuotas
     * const usageQuota = await prisma.usageQuota.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsageQuotaUpdateManyArgs>(args: SelectSubset<T, UsageQuotaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UsageQuotas and returns the data updated in the database.
     * @param {UsageQuotaUpdateManyAndReturnArgs} args - Arguments to update many UsageQuotas.
     * @example
     * // Update many UsageQuotas
     * const usageQuota = await prisma.usageQuota.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UsageQuotas and only return the `id`
     * const usageQuotaWithIdOnly = await prisma.usageQuota.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UsageQuotaUpdateManyAndReturnArgs>(args: SelectSubset<T, UsageQuotaUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UsageQuota.
     * @param {UsageQuotaUpsertArgs} args - Arguments to update or create a UsageQuota.
     * @example
     * // Update or create a UsageQuota
     * const usageQuota = await prisma.usageQuota.upsert({
     *   create: {
     *     // ... data to create a UsageQuota
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UsageQuota we want to update
     *   }
     * })
     */
    upsert<T extends UsageQuotaUpsertArgs>(args: SelectSubset<T, UsageQuotaUpsertArgs<ExtArgs>>): Prisma__UsageQuotaClient<$Result.GetResult<Prisma.$UsageQuotaPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UsageQuotas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaCountArgs} args - Arguments to filter UsageQuotas to count.
     * @example
     * // Count the number of UsageQuotas
     * const count = await prisma.usageQuota.count({
     *   where: {
     *     // ... the filter for the UsageQuotas we want to count
     *   }
     * })
    **/
    count<T extends UsageQuotaCountArgs>(
      args?: Subset<T, UsageQuotaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsageQuotaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UsageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsageQuotaAggregateArgs>(args: Subset<T, UsageQuotaAggregateArgs>): Prisma.PrismaPromise<GetUsageQuotaAggregateType<T>>

    /**
     * Group by UsageQuota.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsageQuotaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsageQuotaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsageQuotaGroupByArgs['orderBy'] }
        : { orderBy?: UsageQuotaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsageQuotaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsageQuotaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UsageQuota model
   */
  readonly fields: UsageQuotaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UsageQuota.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsageQuotaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contractPermission<T extends ContractPermissionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractPermissionDefaultArgs<ExtArgs>>): Prisma__ContractPermissionClient<$Result.GetResult<Prisma.$ContractPermissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UsageQuota model
   */
  interface UsageQuotaFieldRefs {
    readonly id: FieldRef<"UsageQuota", 'String'>
    readonly contractPermissionId: FieldRef<"UsageQuota", 'String'>
    readonly maxRequests: FieldRef<"UsageQuota", 'Int'>
    readonly usedRequests: FieldRef<"UsageQuota", 'Int'>
    readonly timeWindow: FieldRef<"UsageQuota", 'String'>
    readonly renewalPeriod: FieldRef<"UsageQuota", 'String'>
    readonly lastReset: FieldRef<"UsageQuota", 'DateTime'>
    readonly createdAt: FieldRef<"UsageQuota", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UsageQuota findUnique
   */
  export type UsageQuotaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UsageQuota to fetch.
     */
    where: UsageQuotaWhereUniqueInput
  }

  /**
   * UsageQuota findUniqueOrThrow
   */
  export type UsageQuotaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UsageQuota to fetch.
     */
    where: UsageQuotaWhereUniqueInput
  }

  /**
   * UsageQuota findFirst
   */
  export type UsageQuotaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UsageQuota to fetch.
     */
    where?: UsageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageQuotas to fetch.
     */
    orderBy?: UsageQuotaOrderByWithRelationInput | UsageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageQuotas.
     */
    cursor?: UsageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageQuotas.
     */
    distinct?: UsageQuotaScalarFieldEnum | UsageQuotaScalarFieldEnum[]
  }

  /**
   * UsageQuota findFirstOrThrow
   */
  export type UsageQuotaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UsageQuota to fetch.
     */
    where?: UsageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageQuotas to fetch.
     */
    orderBy?: UsageQuotaOrderByWithRelationInput | UsageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UsageQuotas.
     */
    cursor?: UsageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageQuotas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UsageQuotas.
     */
    distinct?: UsageQuotaScalarFieldEnum | UsageQuotaScalarFieldEnum[]
  }

  /**
   * UsageQuota findMany
   */
  export type UsageQuotaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter, which UsageQuotas to fetch.
     */
    where?: UsageQuotaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UsageQuotas to fetch.
     */
    orderBy?: UsageQuotaOrderByWithRelationInput | UsageQuotaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UsageQuotas.
     */
    cursor?: UsageQuotaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UsageQuotas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UsageQuotas.
     */
    skip?: number
    distinct?: UsageQuotaScalarFieldEnum | UsageQuotaScalarFieldEnum[]
  }

  /**
   * UsageQuota create
   */
  export type UsageQuotaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to create a UsageQuota.
     */
    data: XOR<UsageQuotaCreateInput, UsageQuotaUncheckedCreateInput>
  }

  /**
   * UsageQuota createMany
   */
  export type UsageQuotaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UsageQuotas.
     */
    data: UsageQuotaCreateManyInput | UsageQuotaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UsageQuota createManyAndReturn
   */
  export type UsageQuotaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * The data used to create many UsageQuotas.
     */
    data: UsageQuotaCreateManyInput | UsageQuotaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageQuota update
   */
  export type UsageQuotaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * The data needed to update a UsageQuota.
     */
    data: XOR<UsageQuotaUpdateInput, UsageQuotaUncheckedUpdateInput>
    /**
     * Choose, which UsageQuota to update.
     */
    where: UsageQuotaWhereUniqueInput
  }

  /**
   * UsageQuota updateMany
   */
  export type UsageQuotaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UsageQuotas.
     */
    data: XOR<UsageQuotaUpdateManyMutationInput, UsageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which UsageQuotas to update
     */
    where?: UsageQuotaWhereInput
    /**
     * Limit how many UsageQuotas to update.
     */
    limit?: number
  }

  /**
   * UsageQuota updateManyAndReturn
   */
  export type UsageQuotaUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * The data used to update UsageQuotas.
     */
    data: XOR<UsageQuotaUpdateManyMutationInput, UsageQuotaUncheckedUpdateManyInput>
    /**
     * Filter which UsageQuotas to update
     */
    where?: UsageQuotaWhereInput
    /**
     * Limit how many UsageQuotas to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UsageQuota upsert
   */
  export type UsageQuotaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * The filter to search for the UsageQuota to update in case it exists.
     */
    where: UsageQuotaWhereUniqueInput
    /**
     * In case the UsageQuota found by the `where` argument doesn't exist, create a new UsageQuota with this data.
     */
    create: XOR<UsageQuotaCreateInput, UsageQuotaUncheckedCreateInput>
    /**
     * In case the UsageQuota was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsageQuotaUpdateInput, UsageQuotaUncheckedUpdateInput>
  }

  /**
   * UsageQuota delete
   */
  export type UsageQuotaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
    /**
     * Filter which UsageQuota to delete.
     */
    where: UsageQuotaWhereUniqueInput
  }

  /**
   * UsageQuota deleteMany
   */
  export type UsageQuotaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UsageQuotas to delete
     */
    where?: UsageQuotaWhereInput
    /**
     * Limit how many UsageQuotas to delete.
     */
    limit?: number
  }

  /**
   * UsageQuota without action
   */
  export type UsageQuotaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsageQuota
     */
    select?: UsageQuotaSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UsageQuota
     */
    omit?: UsageQuotaOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsageQuotaInclude<ExtArgs> | null
  }


  /**
   * Model ComplianceAudit
   */

  export type AggregateComplianceAudit = {
    _count: ComplianceAuditCountAggregateOutputType | null
    _avg: ComplianceAuditAvgAggregateOutputType | null
    _sum: ComplianceAuditSumAggregateOutputType | null
    _min: ComplianceAuditMinAggregateOutputType | null
    _max: ComplianceAuditMaxAggregateOutputType | null
  }

  export type ComplianceAuditAvgAggregateOutputType = {
    providerId: number | null
  }

  export type ComplianceAuditSumAggregateOutputType = {
    providerId: number | null
  }

  export type ComplianceAuditMinAggregateOutputType = {
    id: string | null
    providerId: number | null
    serviceId: string | null
    framework: $Enums.ComplianceFramework | null
    status: $Enums.ComplianceStatus | null
    auditDate: Date | null
    expiresAt: Date | null
  }

  export type ComplianceAuditMaxAggregateOutputType = {
    id: string | null
    providerId: number | null
    serviceId: string | null
    framework: $Enums.ComplianceFramework | null
    status: $Enums.ComplianceStatus | null
    auditDate: Date | null
    expiresAt: Date | null
  }

  export type ComplianceAuditCountAggregateOutputType = {
    id: number
    providerId: number
    serviceId: number
    framework: number
    status: number
    auditData: number
    auditDate: number
    expiresAt: number
    _all: number
  }


  export type ComplianceAuditAvgAggregateInputType = {
    providerId?: true
  }

  export type ComplianceAuditSumAggregateInputType = {
    providerId?: true
  }

  export type ComplianceAuditMinAggregateInputType = {
    id?: true
    providerId?: true
    serviceId?: true
    framework?: true
    status?: true
    auditDate?: true
    expiresAt?: true
  }

  export type ComplianceAuditMaxAggregateInputType = {
    id?: true
    providerId?: true
    serviceId?: true
    framework?: true
    status?: true
    auditDate?: true
    expiresAt?: true
  }

  export type ComplianceAuditCountAggregateInputType = {
    id?: true
    providerId?: true
    serviceId?: true
    framework?: true
    status?: true
    auditData?: true
    auditDate?: true
    expiresAt?: true
    _all?: true
  }

  export type ComplianceAuditAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceAudit to aggregate.
     */
    where?: ComplianceAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAudits to fetch.
     */
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplianceAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplianceAudits
    **/
    _count?: true | ComplianceAuditCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ComplianceAuditAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ComplianceAuditSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplianceAuditMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplianceAuditMaxAggregateInputType
  }

  export type GetComplianceAuditAggregateType<T extends ComplianceAuditAggregateArgs> = {
        [P in keyof T & keyof AggregateComplianceAudit]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplianceAudit[P]>
      : GetScalarType<T[P], AggregateComplianceAudit[P]>
  }




  export type ComplianceAuditGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplianceAuditWhereInput
    orderBy?: ComplianceAuditOrderByWithAggregationInput | ComplianceAuditOrderByWithAggregationInput[]
    by: ComplianceAuditScalarFieldEnum[] | ComplianceAuditScalarFieldEnum
    having?: ComplianceAuditScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplianceAuditCountAggregateInputType | true
    _avg?: ComplianceAuditAvgAggregateInputType
    _sum?: ComplianceAuditSumAggregateInputType
    _min?: ComplianceAuditMinAggregateInputType
    _max?: ComplianceAuditMaxAggregateInputType
  }

  export type ComplianceAuditGroupByOutputType = {
    id: string
    providerId: number
    serviceId: string | null
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonValue
    auditDate: Date
    expiresAt: Date | null
    _count: ComplianceAuditCountAggregateOutputType | null
    _avg: ComplianceAuditAvgAggregateOutputType | null
    _sum: ComplianceAuditSumAggregateOutputType | null
    _min: ComplianceAuditMinAggregateOutputType | null
    _max: ComplianceAuditMaxAggregateOutputType | null
  }

  type GetComplianceAuditGroupByPayload<T extends ComplianceAuditGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplianceAuditGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplianceAuditGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplianceAuditGroupByOutputType[P]>
            : GetScalarType<T[P], ComplianceAuditGroupByOutputType[P]>
        }
      >
    >


  export type ComplianceAuditSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    serviceId?: boolean
    framework?: boolean
    status?: boolean
    auditData?: boolean
    auditDate?: boolean
    expiresAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAudit"]>

  export type ComplianceAuditSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    serviceId?: boolean
    framework?: boolean
    status?: boolean
    auditData?: boolean
    auditDate?: boolean
    expiresAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAudit"]>

  export type ComplianceAuditSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    providerId?: boolean
    serviceId?: boolean
    framework?: boolean
    status?: boolean
    auditData?: boolean
    auditDate?: boolean
    expiresAt?: boolean
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }, ExtArgs["result"]["complianceAudit"]>

  export type ComplianceAuditSelectScalar = {
    id?: boolean
    providerId?: boolean
    serviceId?: boolean
    framework?: boolean
    status?: boolean
    auditData?: boolean
    auditDate?: boolean
    expiresAt?: boolean
  }

  export type ComplianceAuditOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "providerId" | "serviceId" | "framework" | "status" | "auditData" | "auditDate" | "expiresAt", ExtArgs["result"]["complianceAudit"]>
  export type ComplianceAuditInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }
  export type ComplianceAuditIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }
  export type ComplianceAuditIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    provider?: boolean | ProviderDefaultArgs<ExtArgs>
    service?: boolean | ComplianceAudit$serviceArgs<ExtArgs>
  }

  export type $ComplianceAuditPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplianceAudit"
    objects: {
      provider: Prisma.$ProviderPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      providerId: number
      serviceId: string | null
      framework: $Enums.ComplianceFramework
      status: $Enums.ComplianceStatus
      auditData: Prisma.JsonValue
      auditDate: Date
      expiresAt: Date | null
    }, ExtArgs["result"]["complianceAudit"]>
    composites: {}
  }

  type ComplianceAuditGetPayload<S extends boolean | null | undefined | ComplianceAuditDefaultArgs> = $Result.GetResult<Prisma.$ComplianceAuditPayload, S>

  type ComplianceAuditCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplianceAuditFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplianceAuditCountAggregateInputType | true
    }

  export interface ComplianceAuditDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplianceAudit'], meta: { name: 'ComplianceAudit' } }
    /**
     * Find zero or one ComplianceAudit that matches the filter.
     * @param {ComplianceAuditFindUniqueArgs} args - Arguments to find a ComplianceAudit
     * @example
     * // Get one ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplianceAuditFindUniqueArgs>(args: SelectSubset<T, ComplianceAuditFindUniqueArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplianceAudit that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplianceAuditFindUniqueOrThrowArgs} args - Arguments to find a ComplianceAudit
     * @example
     * // Get one ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplianceAuditFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplianceAuditFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceAudit that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditFindFirstArgs} args - Arguments to find a ComplianceAudit
     * @example
     * // Get one ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplianceAuditFindFirstArgs>(args?: SelectSubset<T, ComplianceAuditFindFirstArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplianceAudit that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditFindFirstOrThrowArgs} args - Arguments to find a ComplianceAudit
     * @example
     * // Get one ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplianceAuditFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplianceAuditFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplianceAudits that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplianceAudits
     * const complianceAudits = await prisma.complianceAudit.findMany()
     * 
     * // Get first 10 ComplianceAudits
     * const complianceAudits = await prisma.complianceAudit.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complianceAuditWithIdOnly = await prisma.complianceAudit.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplianceAuditFindManyArgs>(args?: SelectSubset<T, ComplianceAuditFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplianceAudit.
     * @param {ComplianceAuditCreateArgs} args - Arguments to create a ComplianceAudit.
     * @example
     * // Create one ComplianceAudit
     * const ComplianceAudit = await prisma.complianceAudit.create({
     *   data: {
     *     // ... data to create a ComplianceAudit
     *   }
     * })
     * 
     */
    create<T extends ComplianceAuditCreateArgs>(args: SelectSubset<T, ComplianceAuditCreateArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplianceAudits.
     * @param {ComplianceAuditCreateManyArgs} args - Arguments to create many ComplianceAudits.
     * @example
     * // Create many ComplianceAudits
     * const complianceAudit = await prisma.complianceAudit.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplianceAuditCreateManyArgs>(args?: SelectSubset<T, ComplianceAuditCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplianceAudits and returns the data saved in the database.
     * @param {ComplianceAuditCreateManyAndReturnArgs} args - Arguments to create many ComplianceAudits.
     * @example
     * // Create many ComplianceAudits
     * const complianceAudit = await prisma.complianceAudit.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplianceAudits and only return the `id`
     * const complianceAuditWithIdOnly = await prisma.complianceAudit.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplianceAuditCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplianceAuditCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplianceAudit.
     * @param {ComplianceAuditDeleteArgs} args - Arguments to delete one ComplianceAudit.
     * @example
     * // Delete one ComplianceAudit
     * const ComplianceAudit = await prisma.complianceAudit.delete({
     *   where: {
     *     // ... filter to delete one ComplianceAudit
     *   }
     * })
     * 
     */
    delete<T extends ComplianceAuditDeleteArgs>(args: SelectSubset<T, ComplianceAuditDeleteArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplianceAudit.
     * @param {ComplianceAuditUpdateArgs} args - Arguments to update one ComplianceAudit.
     * @example
     * // Update one ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplianceAuditUpdateArgs>(args: SelectSubset<T, ComplianceAuditUpdateArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplianceAudits.
     * @param {ComplianceAuditDeleteManyArgs} args - Arguments to filter ComplianceAudits to delete.
     * @example
     * // Delete a few ComplianceAudits
     * const { count } = await prisma.complianceAudit.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplianceAuditDeleteManyArgs>(args?: SelectSubset<T, ComplianceAuditDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplianceAudits
     * const complianceAudit = await prisma.complianceAudit.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplianceAuditUpdateManyArgs>(args: SelectSubset<T, ComplianceAuditUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplianceAudits and returns the data updated in the database.
     * @param {ComplianceAuditUpdateManyAndReturnArgs} args - Arguments to update many ComplianceAudits.
     * @example
     * // Update many ComplianceAudits
     * const complianceAudit = await prisma.complianceAudit.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplianceAudits and only return the `id`
     * const complianceAuditWithIdOnly = await prisma.complianceAudit.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplianceAuditUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplianceAuditUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplianceAudit.
     * @param {ComplianceAuditUpsertArgs} args - Arguments to update or create a ComplianceAudit.
     * @example
     * // Update or create a ComplianceAudit
     * const complianceAudit = await prisma.complianceAudit.upsert({
     *   create: {
     *     // ... data to create a ComplianceAudit
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplianceAudit we want to update
     *   }
     * })
     */
    upsert<T extends ComplianceAuditUpsertArgs>(args: SelectSubset<T, ComplianceAuditUpsertArgs<ExtArgs>>): Prisma__ComplianceAuditClient<$Result.GetResult<Prisma.$ComplianceAuditPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplianceAudits.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditCountArgs} args - Arguments to filter ComplianceAudits to count.
     * @example
     * // Count the number of ComplianceAudits
     * const count = await prisma.complianceAudit.count({
     *   where: {
     *     // ... the filter for the ComplianceAudits we want to count
     *   }
     * })
    **/
    count<T extends ComplianceAuditCountArgs>(
      args?: Subset<T, ComplianceAuditCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplianceAuditCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplianceAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplianceAuditAggregateArgs>(args: Subset<T, ComplianceAuditAggregateArgs>): Prisma.PrismaPromise<GetComplianceAuditAggregateType<T>>

    /**
     * Group by ComplianceAudit.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplianceAuditGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplianceAuditGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplianceAuditGroupByArgs['orderBy'] }
        : { orderBy?: ComplianceAuditGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplianceAuditGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplianceAuditGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplianceAudit model
   */
  readonly fields: ComplianceAuditFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplianceAudit.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplianceAuditClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    provider<T extends ProviderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderDefaultArgs<ExtArgs>>): Prisma__ProviderClient<$Result.GetResult<Prisma.$ProviderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ComplianceAudit$serviceArgs<ExtArgs> = {}>(args?: Subset<T, ComplianceAudit$serviceArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplianceAudit model
   */
  interface ComplianceAuditFieldRefs {
    readonly id: FieldRef<"ComplianceAudit", 'String'>
    readonly providerId: FieldRef<"ComplianceAudit", 'Int'>
    readonly serviceId: FieldRef<"ComplianceAudit", 'String'>
    readonly framework: FieldRef<"ComplianceAudit", 'ComplianceFramework'>
    readonly status: FieldRef<"ComplianceAudit", 'ComplianceStatus'>
    readonly auditData: FieldRef<"ComplianceAudit", 'Json'>
    readonly auditDate: FieldRef<"ComplianceAudit", 'DateTime'>
    readonly expiresAt: FieldRef<"ComplianceAudit", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplianceAudit findUnique
   */
  export type ComplianceAuditFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAudit to fetch.
     */
    where: ComplianceAuditWhereUniqueInput
  }

  /**
   * ComplianceAudit findUniqueOrThrow
   */
  export type ComplianceAuditFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAudit to fetch.
     */
    where: ComplianceAuditWhereUniqueInput
  }

  /**
   * ComplianceAudit findFirst
   */
  export type ComplianceAuditFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAudit to fetch.
     */
    where?: ComplianceAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAudits to fetch.
     */
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceAudits.
     */
    cursor?: ComplianceAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceAudits.
     */
    distinct?: ComplianceAuditScalarFieldEnum | ComplianceAuditScalarFieldEnum[]
  }

  /**
   * ComplianceAudit findFirstOrThrow
   */
  export type ComplianceAuditFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAudit to fetch.
     */
    where?: ComplianceAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAudits to fetch.
     */
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplianceAudits.
     */
    cursor?: ComplianceAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAudits.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplianceAudits.
     */
    distinct?: ComplianceAuditScalarFieldEnum | ComplianceAuditScalarFieldEnum[]
  }

  /**
   * ComplianceAudit findMany
   */
  export type ComplianceAuditFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter, which ComplianceAudits to fetch.
     */
    where?: ComplianceAuditWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplianceAudits to fetch.
     */
    orderBy?: ComplianceAuditOrderByWithRelationInput | ComplianceAuditOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplianceAudits.
     */
    cursor?: ComplianceAuditWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ComplianceAudits from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplianceAudits.
     */
    skip?: number
    distinct?: ComplianceAuditScalarFieldEnum | ComplianceAuditScalarFieldEnum[]
  }

  /**
   * ComplianceAudit create
   */
  export type ComplianceAuditCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * The data needed to create a ComplianceAudit.
     */
    data: XOR<ComplianceAuditCreateInput, ComplianceAuditUncheckedCreateInput>
  }

  /**
   * ComplianceAudit createMany
   */
  export type ComplianceAuditCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplianceAudits.
     */
    data: ComplianceAuditCreateManyInput | ComplianceAuditCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplianceAudit createManyAndReturn
   */
  export type ComplianceAuditCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * The data used to create many ComplianceAudits.
     */
    data: ComplianceAuditCreateManyInput | ComplianceAuditCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceAudit update
   */
  export type ComplianceAuditUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * The data needed to update a ComplianceAudit.
     */
    data: XOR<ComplianceAuditUpdateInput, ComplianceAuditUncheckedUpdateInput>
    /**
     * Choose, which ComplianceAudit to update.
     */
    where: ComplianceAuditWhereUniqueInput
  }

  /**
   * ComplianceAudit updateMany
   */
  export type ComplianceAuditUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplianceAudits.
     */
    data: XOR<ComplianceAuditUpdateManyMutationInput, ComplianceAuditUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceAudits to update
     */
    where?: ComplianceAuditWhereInput
    /**
     * Limit how many ComplianceAudits to update.
     */
    limit?: number
  }

  /**
   * ComplianceAudit updateManyAndReturn
   */
  export type ComplianceAuditUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * The data used to update ComplianceAudits.
     */
    data: XOR<ComplianceAuditUpdateManyMutationInput, ComplianceAuditUncheckedUpdateManyInput>
    /**
     * Filter which ComplianceAudits to update
     */
    where?: ComplianceAuditWhereInput
    /**
     * Limit how many ComplianceAudits to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ComplianceAudit upsert
   */
  export type ComplianceAuditUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * The filter to search for the ComplianceAudit to update in case it exists.
     */
    where: ComplianceAuditWhereUniqueInput
    /**
     * In case the ComplianceAudit found by the `where` argument doesn't exist, create a new ComplianceAudit with this data.
     */
    create: XOR<ComplianceAuditCreateInput, ComplianceAuditUncheckedCreateInput>
    /**
     * In case the ComplianceAudit was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplianceAuditUpdateInput, ComplianceAuditUncheckedUpdateInput>
  }

  /**
   * ComplianceAudit delete
   */
  export type ComplianceAuditDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
    /**
     * Filter which ComplianceAudit to delete.
     */
    where: ComplianceAuditWhereUniqueInput
  }

  /**
   * ComplianceAudit deleteMany
   */
  export type ComplianceAuditDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplianceAudits to delete
     */
    where?: ComplianceAuditWhereInput
    /**
     * Limit how many ComplianceAudits to delete.
     */
    limit?: number
  }

  /**
   * ComplianceAudit.service
   */
  export type ComplianceAudit$serviceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Service
     */
    select?: ServiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Service
     */
    omit?: ServiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ServiceInclude<ExtArgs> | null
    where?: ServiceWhereInput
  }

  /**
   * ComplianceAudit without action
   */
  export type ComplianceAuditDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplianceAudit
     */
    select?: ComplianceAuditSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplianceAudit
     */
    omit?: ComplianceAuditOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ComplianceAuditInclude<ExtArgs> | null
  }


  /**
   * Model ZKProofVerification
   */

  export type AggregateZKProofVerification = {
    _count: ZKProofVerificationCountAggregateOutputType | null
    _min: ZKProofVerificationMinAggregateOutputType | null
    _max: ZKProofVerificationMaxAggregateOutputType | null
  }

  export type ZKProofVerificationMinAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    proofType: $Enums.ZKProofType | null
    proofHash: string | null
    isValid: boolean | null
    verifiedAt: Date | null
  }

  export type ZKProofVerificationMaxAggregateOutputType = {
    id: string | null
    contractId: string | null
    serviceId: string | null
    proofType: $Enums.ZKProofType | null
    proofHash: string | null
    isValid: boolean | null
    verifiedAt: Date | null
  }

  export type ZKProofVerificationCountAggregateOutputType = {
    id: number
    contractId: number
    serviceId: number
    proofType: number
    proofHash: number
    publicInputs: number
    isValid: number
    verifiedAt: number
    _all: number
  }


  export type ZKProofVerificationMinAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    proofType?: true
    proofHash?: true
    isValid?: true
    verifiedAt?: true
  }

  export type ZKProofVerificationMaxAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    proofType?: true
    proofHash?: true
    isValid?: true
    verifiedAt?: true
  }

  export type ZKProofVerificationCountAggregateInputType = {
    id?: true
    contractId?: true
    serviceId?: true
    proofType?: true
    proofHash?: true
    publicInputs?: true
    isValid?: true
    verifiedAt?: true
    _all?: true
  }

  export type ZKProofVerificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZKProofVerification to aggregate.
     */
    where?: ZKProofVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZKProofVerifications to fetch.
     */
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ZKProofVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZKProofVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZKProofVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ZKProofVerifications
    **/
    _count?: true | ZKProofVerificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ZKProofVerificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ZKProofVerificationMaxAggregateInputType
  }

  export type GetZKProofVerificationAggregateType<T extends ZKProofVerificationAggregateArgs> = {
        [P in keyof T & keyof AggregateZKProofVerification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateZKProofVerification[P]>
      : GetScalarType<T[P], AggregateZKProofVerification[P]>
  }




  export type ZKProofVerificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ZKProofVerificationWhereInput
    orderBy?: ZKProofVerificationOrderByWithAggregationInput | ZKProofVerificationOrderByWithAggregationInput[]
    by: ZKProofVerificationScalarFieldEnum[] | ZKProofVerificationScalarFieldEnum
    having?: ZKProofVerificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ZKProofVerificationCountAggregateInputType | true
    _min?: ZKProofVerificationMinAggregateInputType
    _max?: ZKProofVerificationMaxAggregateInputType
  }

  export type ZKProofVerificationGroupByOutputType = {
    id: string
    contractId: string
    serviceId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonValue
    isValid: boolean
    verifiedAt: Date
    _count: ZKProofVerificationCountAggregateOutputType | null
    _min: ZKProofVerificationMinAggregateOutputType | null
    _max: ZKProofVerificationMaxAggregateOutputType | null
  }

  type GetZKProofVerificationGroupByPayload<T extends ZKProofVerificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ZKProofVerificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ZKProofVerificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ZKProofVerificationGroupByOutputType[P]>
            : GetScalarType<T[P], ZKProofVerificationGroupByOutputType[P]>
        }
      >
    >


  export type ZKProofVerificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    proofType?: boolean
    proofHash?: boolean
    publicInputs?: boolean
    isValid?: boolean
    verifiedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zKProofVerification"]>

  export type ZKProofVerificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    proofType?: boolean
    proofHash?: boolean
    publicInputs?: boolean
    isValid?: boolean
    verifiedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zKProofVerification"]>

  export type ZKProofVerificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    proofType?: boolean
    proofHash?: boolean
    publicInputs?: boolean
    isValid?: boolean
    verifiedAt?: boolean
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["zKProofVerification"]>

  export type ZKProofVerificationSelectScalar = {
    id?: boolean
    contractId?: boolean
    serviceId?: boolean
    proofType?: boolean
    proofHash?: boolean
    publicInputs?: boolean
    isValid?: boolean
    verifiedAt?: boolean
  }

  export type ZKProofVerificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "contractId" | "serviceId" | "proofType" | "proofHash" | "publicInputs" | "isValid" | "verifiedAt", ExtArgs["result"]["zKProofVerification"]>
  export type ZKProofVerificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ZKProofVerificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }
  export type ZKProofVerificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    contract?: boolean | ContractDefaultArgs<ExtArgs>
    service?: boolean | ServiceDefaultArgs<ExtArgs>
  }

  export type $ZKProofVerificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ZKProofVerification"
    objects: {
      contract: Prisma.$ContractPayload<ExtArgs>
      service: Prisma.$ServicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      contractId: string
      serviceId: string
      proofType: $Enums.ZKProofType
      proofHash: string
      publicInputs: Prisma.JsonValue
      isValid: boolean
      verifiedAt: Date
    }, ExtArgs["result"]["zKProofVerification"]>
    composites: {}
  }

  type ZKProofVerificationGetPayload<S extends boolean | null | undefined | ZKProofVerificationDefaultArgs> = $Result.GetResult<Prisma.$ZKProofVerificationPayload, S>

  type ZKProofVerificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ZKProofVerificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ZKProofVerificationCountAggregateInputType | true
    }

  export interface ZKProofVerificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ZKProofVerification'], meta: { name: 'ZKProofVerification' } }
    /**
     * Find zero or one ZKProofVerification that matches the filter.
     * @param {ZKProofVerificationFindUniqueArgs} args - Arguments to find a ZKProofVerification
     * @example
     * // Get one ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ZKProofVerificationFindUniqueArgs>(args: SelectSubset<T, ZKProofVerificationFindUniqueArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ZKProofVerification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ZKProofVerificationFindUniqueOrThrowArgs} args - Arguments to find a ZKProofVerification
     * @example
     * // Get one ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ZKProofVerificationFindUniqueOrThrowArgs>(args: SelectSubset<T, ZKProofVerificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZKProofVerification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationFindFirstArgs} args - Arguments to find a ZKProofVerification
     * @example
     * // Get one ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ZKProofVerificationFindFirstArgs>(args?: SelectSubset<T, ZKProofVerificationFindFirstArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ZKProofVerification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationFindFirstOrThrowArgs} args - Arguments to find a ZKProofVerification
     * @example
     * // Get one ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ZKProofVerificationFindFirstOrThrowArgs>(args?: SelectSubset<T, ZKProofVerificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ZKProofVerifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ZKProofVerifications
     * const zKProofVerifications = await prisma.zKProofVerification.findMany()
     * 
     * // Get first 10 ZKProofVerifications
     * const zKProofVerifications = await prisma.zKProofVerification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const zKProofVerificationWithIdOnly = await prisma.zKProofVerification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ZKProofVerificationFindManyArgs>(args?: SelectSubset<T, ZKProofVerificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ZKProofVerification.
     * @param {ZKProofVerificationCreateArgs} args - Arguments to create a ZKProofVerification.
     * @example
     * // Create one ZKProofVerification
     * const ZKProofVerification = await prisma.zKProofVerification.create({
     *   data: {
     *     // ... data to create a ZKProofVerification
     *   }
     * })
     * 
     */
    create<T extends ZKProofVerificationCreateArgs>(args: SelectSubset<T, ZKProofVerificationCreateArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ZKProofVerifications.
     * @param {ZKProofVerificationCreateManyArgs} args - Arguments to create many ZKProofVerifications.
     * @example
     * // Create many ZKProofVerifications
     * const zKProofVerification = await prisma.zKProofVerification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ZKProofVerificationCreateManyArgs>(args?: SelectSubset<T, ZKProofVerificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ZKProofVerifications and returns the data saved in the database.
     * @param {ZKProofVerificationCreateManyAndReturnArgs} args - Arguments to create many ZKProofVerifications.
     * @example
     * // Create many ZKProofVerifications
     * const zKProofVerification = await prisma.zKProofVerification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ZKProofVerifications and only return the `id`
     * const zKProofVerificationWithIdOnly = await prisma.zKProofVerification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ZKProofVerificationCreateManyAndReturnArgs>(args?: SelectSubset<T, ZKProofVerificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ZKProofVerification.
     * @param {ZKProofVerificationDeleteArgs} args - Arguments to delete one ZKProofVerification.
     * @example
     * // Delete one ZKProofVerification
     * const ZKProofVerification = await prisma.zKProofVerification.delete({
     *   where: {
     *     // ... filter to delete one ZKProofVerification
     *   }
     * })
     * 
     */
    delete<T extends ZKProofVerificationDeleteArgs>(args: SelectSubset<T, ZKProofVerificationDeleteArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ZKProofVerification.
     * @param {ZKProofVerificationUpdateArgs} args - Arguments to update one ZKProofVerification.
     * @example
     * // Update one ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ZKProofVerificationUpdateArgs>(args: SelectSubset<T, ZKProofVerificationUpdateArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ZKProofVerifications.
     * @param {ZKProofVerificationDeleteManyArgs} args - Arguments to filter ZKProofVerifications to delete.
     * @example
     * // Delete a few ZKProofVerifications
     * const { count } = await prisma.zKProofVerification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ZKProofVerificationDeleteManyArgs>(args?: SelectSubset<T, ZKProofVerificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZKProofVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ZKProofVerifications
     * const zKProofVerification = await prisma.zKProofVerification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ZKProofVerificationUpdateManyArgs>(args: SelectSubset<T, ZKProofVerificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ZKProofVerifications and returns the data updated in the database.
     * @param {ZKProofVerificationUpdateManyAndReturnArgs} args - Arguments to update many ZKProofVerifications.
     * @example
     * // Update many ZKProofVerifications
     * const zKProofVerification = await prisma.zKProofVerification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ZKProofVerifications and only return the `id`
     * const zKProofVerificationWithIdOnly = await prisma.zKProofVerification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ZKProofVerificationUpdateManyAndReturnArgs>(args: SelectSubset<T, ZKProofVerificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ZKProofVerification.
     * @param {ZKProofVerificationUpsertArgs} args - Arguments to update or create a ZKProofVerification.
     * @example
     * // Update or create a ZKProofVerification
     * const zKProofVerification = await prisma.zKProofVerification.upsert({
     *   create: {
     *     // ... data to create a ZKProofVerification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ZKProofVerification we want to update
     *   }
     * })
     */
    upsert<T extends ZKProofVerificationUpsertArgs>(args: SelectSubset<T, ZKProofVerificationUpsertArgs<ExtArgs>>): Prisma__ZKProofVerificationClient<$Result.GetResult<Prisma.$ZKProofVerificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ZKProofVerifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationCountArgs} args - Arguments to filter ZKProofVerifications to count.
     * @example
     * // Count the number of ZKProofVerifications
     * const count = await prisma.zKProofVerification.count({
     *   where: {
     *     // ... the filter for the ZKProofVerifications we want to count
     *   }
     * })
    **/
    count<T extends ZKProofVerificationCountArgs>(
      args?: Subset<T, ZKProofVerificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ZKProofVerificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ZKProofVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ZKProofVerificationAggregateArgs>(args: Subset<T, ZKProofVerificationAggregateArgs>): Prisma.PrismaPromise<GetZKProofVerificationAggregateType<T>>

    /**
     * Group by ZKProofVerification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ZKProofVerificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ZKProofVerificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ZKProofVerificationGroupByArgs['orderBy'] }
        : { orderBy?: ZKProofVerificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ZKProofVerificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetZKProofVerificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ZKProofVerification model
   */
  readonly fields: ZKProofVerificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ZKProofVerification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ZKProofVerificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    contract<T extends ContractDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ContractDefaultArgs<ExtArgs>>): Prisma__ContractClient<$Result.GetResult<Prisma.$ContractPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    service<T extends ServiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ServiceDefaultArgs<ExtArgs>>): Prisma__ServiceClient<$Result.GetResult<Prisma.$ServicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ZKProofVerification model
   */
  interface ZKProofVerificationFieldRefs {
    readonly id: FieldRef<"ZKProofVerification", 'String'>
    readonly contractId: FieldRef<"ZKProofVerification", 'String'>
    readonly serviceId: FieldRef<"ZKProofVerification", 'String'>
    readonly proofType: FieldRef<"ZKProofVerification", 'ZKProofType'>
    readonly proofHash: FieldRef<"ZKProofVerification", 'String'>
    readonly publicInputs: FieldRef<"ZKProofVerification", 'Json'>
    readonly isValid: FieldRef<"ZKProofVerification", 'Boolean'>
    readonly verifiedAt: FieldRef<"ZKProofVerification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ZKProofVerification findUnique
   */
  export type ZKProofVerificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZKProofVerification to fetch.
     */
    where: ZKProofVerificationWhereUniqueInput
  }

  /**
   * ZKProofVerification findUniqueOrThrow
   */
  export type ZKProofVerificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZKProofVerification to fetch.
     */
    where: ZKProofVerificationWhereUniqueInput
  }

  /**
   * ZKProofVerification findFirst
   */
  export type ZKProofVerificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZKProofVerification to fetch.
     */
    where?: ZKProofVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZKProofVerifications to fetch.
     */
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZKProofVerifications.
     */
    cursor?: ZKProofVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZKProofVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZKProofVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZKProofVerifications.
     */
    distinct?: ZKProofVerificationScalarFieldEnum | ZKProofVerificationScalarFieldEnum[]
  }

  /**
   * ZKProofVerification findFirstOrThrow
   */
  export type ZKProofVerificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZKProofVerification to fetch.
     */
    where?: ZKProofVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZKProofVerifications to fetch.
     */
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ZKProofVerifications.
     */
    cursor?: ZKProofVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZKProofVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZKProofVerifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ZKProofVerifications.
     */
    distinct?: ZKProofVerificationScalarFieldEnum | ZKProofVerificationScalarFieldEnum[]
  }

  /**
   * ZKProofVerification findMany
   */
  export type ZKProofVerificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter, which ZKProofVerifications to fetch.
     */
    where?: ZKProofVerificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ZKProofVerifications to fetch.
     */
    orderBy?: ZKProofVerificationOrderByWithRelationInput | ZKProofVerificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ZKProofVerifications.
     */
    cursor?: ZKProofVerificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ZKProofVerifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ZKProofVerifications.
     */
    skip?: number
    distinct?: ZKProofVerificationScalarFieldEnum | ZKProofVerificationScalarFieldEnum[]
  }

  /**
   * ZKProofVerification create
   */
  export type ZKProofVerificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * The data needed to create a ZKProofVerification.
     */
    data: XOR<ZKProofVerificationCreateInput, ZKProofVerificationUncheckedCreateInput>
  }

  /**
   * ZKProofVerification createMany
   */
  export type ZKProofVerificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ZKProofVerifications.
     */
    data: ZKProofVerificationCreateManyInput | ZKProofVerificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ZKProofVerification createManyAndReturn
   */
  export type ZKProofVerificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * The data used to create many ZKProofVerifications.
     */
    data: ZKProofVerificationCreateManyInput | ZKProofVerificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZKProofVerification update
   */
  export type ZKProofVerificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * The data needed to update a ZKProofVerification.
     */
    data: XOR<ZKProofVerificationUpdateInput, ZKProofVerificationUncheckedUpdateInput>
    /**
     * Choose, which ZKProofVerification to update.
     */
    where: ZKProofVerificationWhereUniqueInput
  }

  /**
   * ZKProofVerification updateMany
   */
  export type ZKProofVerificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ZKProofVerifications.
     */
    data: XOR<ZKProofVerificationUpdateManyMutationInput, ZKProofVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZKProofVerifications to update
     */
    where?: ZKProofVerificationWhereInput
    /**
     * Limit how many ZKProofVerifications to update.
     */
    limit?: number
  }

  /**
   * ZKProofVerification updateManyAndReturn
   */
  export type ZKProofVerificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * The data used to update ZKProofVerifications.
     */
    data: XOR<ZKProofVerificationUpdateManyMutationInput, ZKProofVerificationUncheckedUpdateManyInput>
    /**
     * Filter which ZKProofVerifications to update
     */
    where?: ZKProofVerificationWhereInput
    /**
     * Limit how many ZKProofVerifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ZKProofVerification upsert
   */
  export type ZKProofVerificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * The filter to search for the ZKProofVerification to update in case it exists.
     */
    where: ZKProofVerificationWhereUniqueInput
    /**
     * In case the ZKProofVerification found by the `where` argument doesn't exist, create a new ZKProofVerification with this data.
     */
    create: XOR<ZKProofVerificationCreateInput, ZKProofVerificationUncheckedCreateInput>
    /**
     * In case the ZKProofVerification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ZKProofVerificationUpdateInput, ZKProofVerificationUncheckedUpdateInput>
  }

  /**
   * ZKProofVerification delete
   */
  export type ZKProofVerificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
    /**
     * Filter which ZKProofVerification to delete.
     */
    where: ZKProofVerificationWhereUniqueInput
  }

  /**
   * ZKProofVerification deleteMany
   */
  export type ZKProofVerificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ZKProofVerifications to delete
     */
    where?: ZKProofVerificationWhereInput
    /**
     * Limit how many ZKProofVerifications to delete.
     */
    limit?: number
  }

  /**
   * ZKProofVerification without action
   */
  export type ZKProofVerificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ZKProofVerification
     */
    select?: ZKProofVerificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ZKProofVerification
     */
    omit?: ZKProofVerificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ZKProofVerificationInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const ProviderScalarFieldEnum: {
    id: 'id',
    name: 'name',
    serviceType: 'serviceType',
    email: 'email',
    rwaType: 'rwaType',
    verificationLayer: 'verificationLayer',
    interactionLayer: 'interactionLayer',
    logo: 'logo',
    coverImage: 'coverImage',
    serviceVerificationType: 'serviceVerificationType',
    chains: 'chains',
    interopProtocols: 'interopProtocols',
    serviceFee: 'serviceFee',
    authMethod: 'authMethod',
    jwtSettings: 'jwtSettings',
    zkProofSupport: 'zkProofSupport',
    privacyLevel: 'privacyLevel',
    complianceFramework: 'complianceFramework',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProviderScalarFieldEnum = (typeof ProviderScalarFieldEnum)[keyof typeof ProviderScalarFieldEnum]


  export const ServiceScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    name: 'name',
    description: 'description',
    endpoint: 'endpoint',
    proofOfService: 'proofOfService',
    serviceCategory: 'serviceCategory',
    authMethod: 'authMethod',
    accessLevel: 'accessLevel',
    rateLimits: 'rateLimits',
    zkRequirements: 'zkRequirements',
    complianceChecks: 'complianceChecks',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ServiceScalarFieldEnum = (typeof ServiceScalarFieldEnum)[keyof typeof ServiceScalarFieldEnum]


  export const PlatformScalarFieldEnum: {
    id: 'id',
    name: 'name',
    platformType: 'platformType',
    email: 'email',
    permissionLevel: 'permissionLevel',
    zkCapabilities: 'zkCapabilities',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformScalarFieldEnum = (typeof PlatformScalarFieldEnum)[keyof typeof PlatformScalarFieldEnum]


  export const ContractScalarFieldEnum: {
    id: 'id',
    platformId: 'platformId',
    name: 'name',
    chain: 'chain',
    address: 'address',
    abi: 'abi',
    zkProofRequirements: 'zkProofRequirements',
    complianceStatus: 'complianceStatus',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ContractScalarFieldEnum = (typeof ContractScalarFieldEnum)[keyof typeof ContractScalarFieldEnum]


  export const PlatformAccessScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    platformId: 'platformId',
    grantedServices: 'grantedServices',
    accessType: 'accessType',
    permissions: 'permissions',
    expiresAt: 'expiresAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PlatformAccessScalarFieldEnum = (typeof PlatformAccessScalarFieldEnum)[keyof typeof PlatformAccessScalarFieldEnum]


  export const ContractPermissionScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    contractId: 'contractId',
    serviceId: 'serviceId',
    jwtToken: 'jwtToken',
    permissions: 'permissions',
    grantedAt: 'grantedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type ContractPermissionScalarFieldEnum = (typeof ContractPermissionScalarFieldEnum)[keyof typeof ContractPermissionScalarFieldEnum]


  export const JWTTokenScalarFieldEnum: {
    id: 'id',
    token: 'token',
    providerId: 'providerId',
    contractId: 'contractId',
    serviceId: 'serviceId',
    permissions: 'permissions',
    zkProofHash: 'zkProofHash',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    isRevoked: 'isRevoked'
  };

  export type JWTTokenScalarFieldEnum = (typeof JWTTokenScalarFieldEnum)[keyof typeof JWTTokenScalarFieldEnum]


  export const ServiceSubscriptionScalarFieldEnum: {
    id: 'id',
    platformId: 'platformId',
    serviceId: 'serviceId',
    providerId: 'providerId',
    accessLevel: 'accessLevel',
    contractAccess: 'contractAccess',
    subscribedAt: 'subscribedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type ServiceSubscriptionScalarFieldEnum = (typeof ServiceSubscriptionScalarFieldEnum)[keyof typeof ServiceSubscriptionScalarFieldEnum]


  export const PlatformAccessTokenScalarFieldEnum: {
    id: 'id',
    platformId: 'platformId',
    providerId: 'providerId',
    token: 'token',
    serviceIds: 'serviceIds',
    permissions: 'permissions',
    zkProofRequired: 'zkProofRequired',
    issuedAt: 'issuedAt',
    expiresAt: 'expiresAt',
    isActive: 'isActive'
  };

  export type PlatformAccessTokenScalarFieldEnum = (typeof PlatformAccessTokenScalarFieldEnum)[keyof typeof PlatformAccessTokenScalarFieldEnum]


  export const ServicePermissionScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    serviceId: 'serviceId',
    providerId: 'providerId',
    accessGranted: 'accessGranted',
    jwtToken: 'jwtToken',
    grantedAt: 'grantedAt',
    updatedAt: 'updatedAt'
  };

  export type ServicePermissionScalarFieldEnum = (typeof ServicePermissionScalarFieldEnum)[keyof typeof ServicePermissionScalarFieldEnum]


  export const AccessLogScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    serviceId: 'serviceId',
    providerId: 'providerId',
    action: 'action',
    zkProofHash: 'zkProofHash',
    metadata: 'metadata',
    timestamp: 'timestamp'
  };

  export type AccessLogScalarFieldEnum = (typeof AccessLogScalarFieldEnum)[keyof typeof AccessLogScalarFieldEnum]


  export const UsageQuotaScalarFieldEnum: {
    id: 'id',
    contractPermissionId: 'contractPermissionId',
    maxRequests: 'maxRequests',
    usedRequests: 'usedRequests',
    timeWindow: 'timeWindow',
    renewalPeriod: 'renewalPeriod',
    lastReset: 'lastReset',
    createdAt: 'createdAt'
  };

  export type UsageQuotaScalarFieldEnum = (typeof UsageQuotaScalarFieldEnum)[keyof typeof UsageQuotaScalarFieldEnum]


  export const ComplianceAuditScalarFieldEnum: {
    id: 'id',
    providerId: 'providerId',
    serviceId: 'serviceId',
    framework: 'framework',
    status: 'status',
    auditData: 'auditData',
    auditDate: 'auditDate',
    expiresAt: 'expiresAt'
  };

  export type ComplianceAuditScalarFieldEnum = (typeof ComplianceAuditScalarFieldEnum)[keyof typeof ComplianceAuditScalarFieldEnum]


  export const ZKProofVerificationScalarFieldEnum: {
    id: 'id',
    contractId: 'contractId',
    serviceId: 'serviceId',
    proofType: 'proofType',
    proofHash: 'proofHash',
    publicInputs: 'publicInputs',
    isValid: 'isValid',
    verifiedAt: 'verifiedAt'
  };

  export type ZKProofVerificationScalarFieldEnum = (typeof ZKProofVerificationScalarFieldEnum)[keyof typeof ZKProofVerificationScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'ServiceType'
   */
  export type EnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType'>
    


  /**
   * Reference to a field of type 'ServiceType[]'
   */
  export type ListEnumServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceType[]'>
    


  /**
   * Reference to a field of type 'RWAType'
   */
  export type EnumRWATypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RWAType'>
    


  /**
   * Reference to a field of type 'RWAType[]'
   */
  export type ListEnumRWATypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RWAType[]'>
    


  /**
   * Reference to a field of type 'VerificationLayer'
   */
  export type EnumVerificationLayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationLayer'>
    


  /**
   * Reference to a field of type 'VerificationLayer[]'
   */
  export type ListEnumVerificationLayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'VerificationLayer[]'>
    


  /**
   * Reference to a field of type 'InteractionLayer'
   */
  export type EnumInteractionLayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionLayer'>
    


  /**
   * Reference to a field of type 'InteractionLayer[]'
   */
  export type ListEnumInteractionLayerFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteractionLayer[]'>
    


  /**
   * Reference to a field of type 'ServiceVerificationType'
   */
  export type EnumServiceVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceVerificationType'>
    


  /**
   * Reference to a field of type 'ServiceVerificationType[]'
   */
  export type ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceVerificationType[]'>
    


  /**
   * Reference to a field of type 'InteropProtocol[]'
   */
  export type ListEnumInteropProtocolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteropProtocol[]'>
    


  /**
   * Reference to a field of type 'InteropProtocol'
   */
  export type EnumInteropProtocolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InteropProtocol'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'AuthMethod'
   */
  export type EnumAuthMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthMethod'>
    


  /**
   * Reference to a field of type 'AuthMethod[]'
   */
  export type ListEnumAuthMethodFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AuthMethod[]'>
    


  /**
   * Reference to a field of type 'ZKProofType[]'
   */
  export type ListEnumZKProofTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZKProofType[]'>
    


  /**
   * Reference to a field of type 'ZKProofType'
   */
  export type EnumZKProofTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ZKProofType'>
    


  /**
   * Reference to a field of type 'PrivacyLevel'
   */
  export type EnumPrivacyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrivacyLevel'>
    


  /**
   * Reference to a field of type 'PrivacyLevel[]'
   */
  export type ListEnumPrivacyLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PrivacyLevel[]'>
    


  /**
   * Reference to a field of type 'ComplianceFramework[]'
   */
  export type ListEnumComplianceFrameworkFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceFramework[]'>
    


  /**
   * Reference to a field of type 'ComplianceFramework'
   */
  export type EnumComplianceFrameworkFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceFramework'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ProofOfServiceType'
   */
  export type EnumProofOfServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProofOfServiceType'>
    


  /**
   * Reference to a field of type 'ProofOfServiceType[]'
   */
  export type ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProofOfServiceType[]'>
    


  /**
   * Reference to a field of type 'ServiceCategory'
   */
  export type EnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory'>
    


  /**
   * Reference to a field of type 'ServiceCategory[]'
   */
  export type ListEnumServiceCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ServiceCategory[]'>
    


  /**
   * Reference to a field of type 'AccessLevel'
   */
  export type EnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel'>
    


  /**
   * Reference to a field of type 'AccessLevel[]'
   */
  export type ListEnumAccessLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessLevel[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'PlatformType'
   */
  export type EnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType'>
    


  /**
   * Reference to a field of type 'PlatformType[]'
   */
  export type ListEnumPlatformTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PlatformType[]'>
    


  /**
   * Reference to a field of type 'PermissionLevel'
   */
  export type EnumPermissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionLevel'>
    


  /**
   * Reference to a field of type 'PermissionLevel[]'
   */
  export type ListEnumPermissionLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PermissionLevel[]'>
    


  /**
   * Reference to a field of type 'ComplianceStatus'
   */
  export type EnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus'>
    


  /**
   * Reference to a field of type 'ComplianceStatus[]'
   */
  export type ListEnumComplianceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ComplianceStatus[]'>
    


  /**
   * Reference to a field of type 'AccessType'
   */
  export type EnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessType'>
    


  /**
   * Reference to a field of type 'AccessType[]'
   */
  export type ListEnumAccessTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AccessType[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type ProviderWhereInput = {
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    id?: IntFilter<"Provider"> | number
    name?: StringFilter<"Provider"> | string
    serviceType?: EnumServiceTypeFilter<"Provider"> | $Enums.ServiceType
    email?: StringFilter<"Provider"> | string
    rwaType?: EnumRWATypeFilter<"Provider"> | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFilter<"Provider"> | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFilter<"Provider"> | $Enums.InteractionLayer
    logo?: StringNullableFilter<"Provider"> | string | null
    coverImage?: StringNullableFilter<"Provider"> | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFilter<"Provider"> | $Enums.ServiceVerificationType
    chains?: StringNullableListFilter<"Provider">
    interopProtocols?: EnumInteropProtocolNullableListFilter<"Provider">
    serviceFee?: JsonFilter<"Provider">
    authMethod?: EnumAuthMethodFilter<"Provider"> | $Enums.AuthMethod
    jwtSettings?: JsonFilter<"Provider">
    zkProofSupport?: EnumZKProofTypeNullableListFilter<"Provider">
    privacyLevel?: EnumPrivacyLevelFilter<"Provider"> | $Enums.PrivacyLevel
    complianceFramework?: EnumComplianceFrameworkNullableListFilter<"Provider">
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    services?: ServiceListRelationFilter
    platformAccess?: PlatformAccessListRelationFilter
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    platformAccessTokens?: PlatformAccessTokenListRelationFilter
    complianceAudits?: ComplianceAuditListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    ServicePermission?: ServicePermissionListRelationFilter
  }

  export type ProviderOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    email?: SortOrder
    rwaType?: SortOrder
    verificationLayer?: SortOrder
    interactionLayer?: SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    serviceVerificationType?: SortOrder
    chains?: SortOrder
    interopProtocols?: SortOrder
    serviceFee?: SortOrder
    authMethod?: SortOrder
    jwtSettings?: SortOrder
    zkProofSupport?: SortOrder
    privacyLevel?: SortOrder
    complianceFramework?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    services?: ServiceOrderByRelationAggregateInput
    platformAccess?: PlatformAccessOrderByRelationAggregateInput
    contractPermissions?: ContractPermissionOrderByRelationAggregateInput
    jwtTokens?: JWTTokenOrderByRelationAggregateInput
    serviceSubscriptions?: ServiceSubscriptionOrderByRelationAggregateInput
    platformAccessTokens?: PlatformAccessTokenOrderByRelationAggregateInput
    complianceAudits?: ComplianceAuditOrderByRelationAggregateInput
    accessLogs?: AccessLogOrderByRelationAggregateInput
    ServicePermission?: ServicePermissionOrderByRelationAggregateInput
  }

  export type ProviderWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: ProviderWhereInput | ProviderWhereInput[]
    OR?: ProviderWhereInput[]
    NOT?: ProviderWhereInput | ProviderWhereInput[]
    name?: StringFilter<"Provider"> | string
    serviceType?: EnumServiceTypeFilter<"Provider"> | $Enums.ServiceType
    rwaType?: EnumRWATypeFilter<"Provider"> | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFilter<"Provider"> | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFilter<"Provider"> | $Enums.InteractionLayer
    logo?: StringNullableFilter<"Provider"> | string | null
    coverImage?: StringNullableFilter<"Provider"> | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFilter<"Provider"> | $Enums.ServiceVerificationType
    chains?: StringNullableListFilter<"Provider">
    interopProtocols?: EnumInteropProtocolNullableListFilter<"Provider">
    serviceFee?: JsonFilter<"Provider">
    authMethod?: EnumAuthMethodFilter<"Provider"> | $Enums.AuthMethod
    jwtSettings?: JsonFilter<"Provider">
    zkProofSupport?: EnumZKProofTypeNullableListFilter<"Provider">
    privacyLevel?: EnumPrivacyLevelFilter<"Provider"> | $Enums.PrivacyLevel
    complianceFramework?: EnumComplianceFrameworkNullableListFilter<"Provider">
    createdAt?: DateTimeFilter<"Provider"> | Date | string
    updatedAt?: DateTimeFilter<"Provider"> | Date | string
    services?: ServiceListRelationFilter
    platformAccess?: PlatformAccessListRelationFilter
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    platformAccessTokens?: PlatformAccessTokenListRelationFilter
    complianceAudits?: ComplianceAuditListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    ServicePermission?: ServicePermissionListRelationFilter
  }, "id" | "email">

  export type ProviderOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    email?: SortOrder
    rwaType?: SortOrder
    verificationLayer?: SortOrder
    interactionLayer?: SortOrder
    logo?: SortOrderInput | SortOrder
    coverImage?: SortOrderInput | SortOrder
    serviceVerificationType?: SortOrder
    chains?: SortOrder
    interopProtocols?: SortOrder
    serviceFee?: SortOrder
    authMethod?: SortOrder
    jwtSettings?: SortOrder
    zkProofSupport?: SortOrder
    privacyLevel?: SortOrder
    complianceFramework?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProviderCountOrderByAggregateInput
    _avg?: ProviderAvgOrderByAggregateInput
    _max?: ProviderMaxOrderByAggregateInput
    _min?: ProviderMinOrderByAggregateInput
    _sum?: ProviderSumOrderByAggregateInput
  }

  export type ProviderScalarWhereWithAggregatesInput = {
    AND?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    OR?: ProviderScalarWhereWithAggregatesInput[]
    NOT?: ProviderScalarWhereWithAggregatesInput | ProviderScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Provider"> | number
    name?: StringWithAggregatesFilter<"Provider"> | string
    serviceType?: EnumServiceTypeWithAggregatesFilter<"Provider"> | $Enums.ServiceType
    email?: StringWithAggregatesFilter<"Provider"> | string
    rwaType?: EnumRWATypeWithAggregatesFilter<"Provider"> | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerWithAggregatesFilter<"Provider"> | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerWithAggregatesFilter<"Provider"> | $Enums.InteractionLayer
    logo?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    coverImage?: StringNullableWithAggregatesFilter<"Provider"> | string | null
    serviceVerificationType?: EnumServiceVerificationTypeWithAggregatesFilter<"Provider"> | $Enums.ServiceVerificationType
    chains?: StringNullableListFilter<"Provider">
    interopProtocols?: EnumInteropProtocolNullableListFilter<"Provider">
    serviceFee?: JsonWithAggregatesFilter<"Provider">
    authMethod?: EnumAuthMethodWithAggregatesFilter<"Provider"> | $Enums.AuthMethod
    jwtSettings?: JsonWithAggregatesFilter<"Provider">
    zkProofSupport?: EnumZKProofTypeNullableListFilter<"Provider">
    privacyLevel?: EnumPrivacyLevelWithAggregatesFilter<"Provider"> | $Enums.PrivacyLevel
    complianceFramework?: EnumComplianceFrameworkNullableListFilter<"Provider">
    createdAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Provider"> | Date | string
  }

  export type ServiceWhereInput = {
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    id?: StringFilter<"Service"> | string
    providerId?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    endpoint?: StringFilter<"Service"> | string
    proofOfService?: EnumProofOfServiceTypeFilter<"Service"> | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFilter<"Service"> | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFilter<"Service"> | $Enums.AccessLevel
    rateLimits?: JsonFilter<"Service">
    zkRequirements?: JsonFilter<"Service">
    complianceChecks?: JsonFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    servicePermissions?: ServicePermissionListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    complianceAudits?: ComplianceAuditListRelationFilter
    zkProofVerifications?: ZKProofVerificationListRelationFilter
  }

  export type ServiceOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    proofOfService?: SortOrder
    serviceCategory?: SortOrder
    authMethod?: SortOrder
    accessLevel?: SortOrder
    rateLimits?: SortOrder
    zkRequirements?: SortOrder
    complianceChecks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    contractPermissions?: ContractPermissionOrderByRelationAggregateInput
    jwtTokens?: JWTTokenOrderByRelationAggregateInput
    serviceSubscriptions?: ServiceSubscriptionOrderByRelationAggregateInput
    servicePermissions?: ServicePermissionOrderByRelationAggregateInput
    accessLogs?: AccessLogOrderByRelationAggregateInput
    complianceAudits?: ComplianceAuditOrderByRelationAggregateInput
    zkProofVerifications?: ZKProofVerificationOrderByRelationAggregateInput
  }

  export type ServiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceWhereInput | ServiceWhereInput[]
    OR?: ServiceWhereInput[]
    NOT?: ServiceWhereInput | ServiceWhereInput[]
    providerId?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    endpoint?: StringFilter<"Service"> | string
    proofOfService?: EnumProofOfServiceTypeFilter<"Service"> | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFilter<"Service"> | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFilter<"Service"> | $Enums.AccessLevel
    rateLimits?: JsonFilter<"Service">
    zkRequirements?: JsonFilter<"Service">
    complianceChecks?: JsonFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    servicePermissions?: ServicePermissionListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    complianceAudits?: ComplianceAuditListRelationFilter
    zkProofVerifications?: ZKProofVerificationListRelationFilter
  }, "id">

  export type ServiceOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    endpoint?: SortOrder
    proofOfService?: SortOrder
    serviceCategory?: SortOrder
    authMethod?: SortOrder
    accessLevel?: SortOrder
    rateLimits?: SortOrder
    zkRequirements?: SortOrder
    complianceChecks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServiceCountOrderByAggregateInput
    _avg?: ServiceAvgOrderByAggregateInput
    _max?: ServiceMaxOrderByAggregateInput
    _min?: ServiceMinOrderByAggregateInput
    _sum?: ServiceSumOrderByAggregateInput
  }

  export type ServiceScalarWhereWithAggregatesInput = {
    AND?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    OR?: ServiceScalarWhereWithAggregatesInput[]
    NOT?: ServiceScalarWhereWithAggregatesInput | ServiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Service"> | string
    providerId?: IntWithAggregatesFilter<"Service"> | number
    name?: StringWithAggregatesFilter<"Service"> | string
    description?: StringNullableWithAggregatesFilter<"Service"> | string | null
    endpoint?: StringWithAggregatesFilter<"Service"> | string
    proofOfService?: EnumProofOfServiceTypeWithAggregatesFilter<"Service"> | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryWithAggregatesFilter<"Service"> | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodWithAggregatesFilter<"Service"> | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"Service"> | $Enums.AccessLevel
    rateLimits?: JsonWithAggregatesFilter<"Service">
    zkRequirements?: JsonWithAggregatesFilter<"Service">
    complianceChecks?: JsonWithAggregatesFilter<"Service">
    isActive?: BoolWithAggregatesFilter<"Service"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Service"> | Date | string
  }

  export type PlatformWhereInput = {
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    id?: StringFilter<"Platform"> | string
    name?: StringFilter<"Platform"> | string
    platformType?: EnumPlatformTypeFilter<"Platform"> | $Enums.PlatformType
    email?: StringFilter<"Platform"> | string
    permissionLevel?: EnumPermissionLevelFilter<"Platform"> | $Enums.PermissionLevel
    zkCapabilities?: JsonFilter<"Platform">
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    contracts?: ContractListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    platformAccessTokens?: PlatformAccessTokenListRelationFilter
    platformAccess?: PlatformAccessListRelationFilter
  }

  export type PlatformOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    platformType?: SortOrder
    email?: SortOrder
    permissionLevel?: SortOrder
    zkCapabilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    contracts?: ContractOrderByRelationAggregateInput
    serviceSubscriptions?: ServiceSubscriptionOrderByRelationAggregateInput
    platformAccessTokens?: PlatformAccessTokenOrderByRelationAggregateInput
    platformAccess?: PlatformAccessOrderByRelationAggregateInput
  }

  export type PlatformWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: PlatformWhereInput | PlatformWhereInput[]
    OR?: PlatformWhereInput[]
    NOT?: PlatformWhereInput | PlatformWhereInput[]
    name?: StringFilter<"Platform"> | string
    platformType?: EnumPlatformTypeFilter<"Platform"> | $Enums.PlatformType
    permissionLevel?: EnumPermissionLevelFilter<"Platform"> | $Enums.PermissionLevel
    zkCapabilities?: JsonFilter<"Platform">
    createdAt?: DateTimeFilter<"Platform"> | Date | string
    updatedAt?: DateTimeFilter<"Platform"> | Date | string
    contracts?: ContractListRelationFilter
    serviceSubscriptions?: ServiceSubscriptionListRelationFilter
    platformAccessTokens?: PlatformAccessTokenListRelationFilter
    platformAccess?: PlatformAccessListRelationFilter
  }, "id" | "email">

  export type PlatformOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    platformType?: SortOrder
    email?: SortOrder
    permissionLevel?: SortOrder
    zkCapabilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformCountOrderByAggregateInput
    _max?: PlatformMaxOrderByAggregateInput
    _min?: PlatformMinOrderByAggregateInput
  }

  export type PlatformScalarWhereWithAggregatesInput = {
    AND?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    OR?: PlatformScalarWhereWithAggregatesInput[]
    NOT?: PlatformScalarWhereWithAggregatesInput | PlatformScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Platform"> | string
    name?: StringWithAggregatesFilter<"Platform"> | string
    platformType?: EnumPlatformTypeWithAggregatesFilter<"Platform"> | $Enums.PlatformType
    email?: StringWithAggregatesFilter<"Platform"> | string
    permissionLevel?: EnumPermissionLevelWithAggregatesFilter<"Platform"> | $Enums.PermissionLevel
    zkCapabilities?: JsonWithAggregatesFilter<"Platform">
    createdAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Platform"> | Date | string
  }

  export type ContractWhereInput = {
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    id?: StringFilter<"Contract"> | string
    platformId?: StringFilter<"Contract"> | string
    name?: StringFilter<"Contract"> | string
    chain?: StringFilter<"Contract"> | string
    address?: StringFilter<"Contract"> | string
    abi?: JsonFilter<"Contract">
    zkProofRequirements?: JsonFilter<"Contract">
    complianceStatus?: EnumComplianceStatusFilter<"Contract"> | $Enums.ComplianceStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    servicePermissions?: ServicePermissionListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    zkProofVerifications?: ZKProofVerificationListRelationFilter
  }

  export type ContractOrderByWithRelationInput = {
    id?: SortOrder
    platformId?: SortOrder
    name?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    abi?: SortOrder
    zkProofRequirements?: SortOrder
    complianceStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    platform?: PlatformOrderByWithRelationInput
    contractPermissions?: ContractPermissionOrderByRelationAggregateInput
    jwtTokens?: JWTTokenOrderByRelationAggregateInput
    servicePermissions?: ServicePermissionOrderByRelationAggregateInput
    accessLogs?: AccessLogOrderByRelationAggregateInput
    zkProofVerifications?: ZKProofVerificationOrderByRelationAggregateInput
  }

  export type ContractWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractWhereInput | ContractWhereInput[]
    OR?: ContractWhereInput[]
    NOT?: ContractWhereInput | ContractWhereInput[]
    platformId?: StringFilter<"Contract"> | string
    name?: StringFilter<"Contract"> | string
    chain?: StringFilter<"Contract"> | string
    address?: StringFilter<"Contract"> | string
    abi?: JsonFilter<"Contract">
    zkProofRequirements?: JsonFilter<"Contract">
    complianceStatus?: EnumComplianceStatusFilter<"Contract"> | $Enums.ComplianceStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    contractPermissions?: ContractPermissionListRelationFilter
    jwtTokens?: JWTTokenListRelationFilter
    servicePermissions?: ServicePermissionListRelationFilter
    accessLogs?: AccessLogListRelationFilter
    zkProofVerifications?: ZKProofVerificationListRelationFilter
  }, "id">

  export type ContractOrderByWithAggregationInput = {
    id?: SortOrder
    platformId?: SortOrder
    name?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    abi?: SortOrder
    zkProofRequirements?: SortOrder
    complianceStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ContractCountOrderByAggregateInput
    _max?: ContractMaxOrderByAggregateInput
    _min?: ContractMinOrderByAggregateInput
  }

  export type ContractScalarWhereWithAggregatesInput = {
    AND?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    OR?: ContractScalarWhereWithAggregatesInput[]
    NOT?: ContractScalarWhereWithAggregatesInput | ContractScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Contract"> | string
    platformId?: StringWithAggregatesFilter<"Contract"> | string
    name?: StringWithAggregatesFilter<"Contract"> | string
    chain?: StringWithAggregatesFilter<"Contract"> | string
    address?: StringWithAggregatesFilter<"Contract"> | string
    abi?: JsonWithAggregatesFilter<"Contract">
    zkProofRequirements?: JsonWithAggregatesFilter<"Contract">
    complianceStatus?: EnumComplianceStatusWithAggregatesFilter<"Contract"> | $Enums.ComplianceStatus
    createdAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Contract"> | Date | string
  }

  export type PlatformAccessWhereInput = {
    AND?: PlatformAccessWhereInput | PlatformAccessWhereInput[]
    OR?: PlatformAccessWhereInput[]
    NOT?: PlatformAccessWhereInput | PlatformAccessWhereInput[]
    id?: StringFilter<"PlatformAccess"> | string
    providerId?: IntFilter<"PlatformAccess"> | number
    platformId?: StringFilter<"PlatformAccess"> | string
    grantedServices?: StringNullableListFilter<"PlatformAccess">
    accessType?: EnumAccessTypeFilter<"PlatformAccess"> | $Enums.AccessType
    permissions?: JsonFilter<"PlatformAccess">
    expiresAt?: DateTimeNullableFilter<"PlatformAccess"> | Date | string | null
    isActive?: BoolFilter<"PlatformAccess"> | boolean
    createdAt?: DateTimeFilter<"PlatformAccess"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformAccess"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
  }

  export type PlatformAccessOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    platformId?: SortOrder
    grantedServices?: SortOrder
    accessType?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    platform?: PlatformOrderByWithRelationInput
  }

  export type PlatformAccessWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PlatformAccessWhereInput | PlatformAccessWhereInput[]
    OR?: PlatformAccessWhereInput[]
    NOT?: PlatformAccessWhereInput | PlatformAccessWhereInput[]
    providerId?: IntFilter<"PlatformAccess"> | number
    platformId?: StringFilter<"PlatformAccess"> | string
    grantedServices?: StringNullableListFilter<"PlatformAccess">
    accessType?: EnumAccessTypeFilter<"PlatformAccess"> | $Enums.AccessType
    permissions?: JsonFilter<"PlatformAccess">
    expiresAt?: DateTimeNullableFilter<"PlatformAccess"> | Date | string | null
    isActive?: BoolFilter<"PlatformAccess"> | boolean
    createdAt?: DateTimeFilter<"PlatformAccess"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformAccess"> | Date | string
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
  }, "id">

  export type PlatformAccessOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    platformId?: SortOrder
    grantedServices?: SortOrder
    accessType?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PlatformAccessCountOrderByAggregateInput
    _avg?: PlatformAccessAvgOrderByAggregateInput
    _max?: PlatformAccessMaxOrderByAggregateInput
    _min?: PlatformAccessMinOrderByAggregateInput
    _sum?: PlatformAccessSumOrderByAggregateInput
  }

  export type PlatformAccessScalarWhereWithAggregatesInput = {
    AND?: PlatformAccessScalarWhereWithAggregatesInput | PlatformAccessScalarWhereWithAggregatesInput[]
    OR?: PlatformAccessScalarWhereWithAggregatesInput[]
    NOT?: PlatformAccessScalarWhereWithAggregatesInput | PlatformAccessScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformAccess"> | string
    providerId?: IntWithAggregatesFilter<"PlatformAccess"> | number
    platformId?: StringWithAggregatesFilter<"PlatformAccess"> | string
    grantedServices?: StringNullableListFilter<"PlatformAccess">
    accessType?: EnumAccessTypeWithAggregatesFilter<"PlatformAccess"> | $Enums.AccessType
    permissions?: JsonWithAggregatesFilter<"PlatformAccess">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"PlatformAccess"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"PlatformAccess"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PlatformAccess"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PlatformAccess"> | Date | string
  }

  export type ContractPermissionWhereInput = {
    AND?: ContractPermissionWhereInput | ContractPermissionWhereInput[]
    OR?: ContractPermissionWhereInput[]
    NOT?: ContractPermissionWhereInput | ContractPermissionWhereInput[]
    id?: StringFilter<"ContractPermission"> | string
    providerId?: IntFilter<"ContractPermission"> | number
    contractId?: StringFilter<"ContractPermission"> | string
    serviceId?: StringFilter<"ContractPermission"> | string
    jwtToken?: StringFilter<"ContractPermission"> | string
    permissions?: JsonFilter<"ContractPermission">
    grantedAt?: DateTimeFilter<"ContractPermission"> | Date | string
    expiresAt?: DateTimeFilter<"ContractPermission"> | Date | string
    isActive?: BoolFilter<"ContractPermission"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    usageQuota?: XOR<UsageQuotaNullableScalarRelationFilter, UsageQuotaWhereInput> | null
  }

  export type ContractPermissionOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    jwtToken?: SortOrder
    permissions?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    usageQuota?: UsageQuotaOrderByWithRelationInput
  }

  export type ContractPermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ContractPermissionWhereInput | ContractPermissionWhereInput[]
    OR?: ContractPermissionWhereInput[]
    NOT?: ContractPermissionWhereInput | ContractPermissionWhereInput[]
    providerId?: IntFilter<"ContractPermission"> | number
    contractId?: StringFilter<"ContractPermission"> | string
    serviceId?: StringFilter<"ContractPermission"> | string
    jwtToken?: StringFilter<"ContractPermission"> | string
    permissions?: JsonFilter<"ContractPermission">
    grantedAt?: DateTimeFilter<"ContractPermission"> | Date | string
    expiresAt?: DateTimeFilter<"ContractPermission"> | Date | string
    isActive?: BoolFilter<"ContractPermission"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    usageQuota?: XOR<UsageQuotaNullableScalarRelationFilter, UsageQuotaWhereInput> | null
  }, "id">

  export type ContractPermissionOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    jwtToken?: SortOrder
    permissions?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    _count?: ContractPermissionCountOrderByAggregateInput
    _avg?: ContractPermissionAvgOrderByAggregateInput
    _max?: ContractPermissionMaxOrderByAggregateInput
    _min?: ContractPermissionMinOrderByAggregateInput
    _sum?: ContractPermissionSumOrderByAggregateInput
  }

  export type ContractPermissionScalarWhereWithAggregatesInput = {
    AND?: ContractPermissionScalarWhereWithAggregatesInput | ContractPermissionScalarWhereWithAggregatesInput[]
    OR?: ContractPermissionScalarWhereWithAggregatesInput[]
    NOT?: ContractPermissionScalarWhereWithAggregatesInput | ContractPermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ContractPermission"> | string
    providerId?: IntWithAggregatesFilter<"ContractPermission"> | number
    contractId?: StringWithAggregatesFilter<"ContractPermission"> | string
    serviceId?: StringWithAggregatesFilter<"ContractPermission"> | string
    jwtToken?: StringWithAggregatesFilter<"ContractPermission"> | string
    permissions?: JsonWithAggregatesFilter<"ContractPermission">
    grantedAt?: DateTimeWithAggregatesFilter<"ContractPermission"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"ContractPermission"> | Date | string
    isActive?: BoolWithAggregatesFilter<"ContractPermission"> | boolean
  }

  export type JWTTokenWhereInput = {
    AND?: JWTTokenWhereInput | JWTTokenWhereInput[]
    OR?: JWTTokenWhereInput[]
    NOT?: JWTTokenWhereInput | JWTTokenWhereInput[]
    id?: StringFilter<"JWTToken"> | string
    token?: StringFilter<"JWTToken"> | string
    providerId?: IntFilter<"JWTToken"> | number
    contractId?: StringNullableFilter<"JWTToken"> | string | null
    serviceId?: StringFilter<"JWTToken"> | string
    permissions?: JsonFilter<"JWTToken">
    zkProofHash?: StringNullableFilter<"JWTToken"> | string | null
    issuedAt?: DateTimeFilter<"JWTToken"> | Date | string
    expiresAt?: DateTimeFilter<"JWTToken"> | Date | string
    isRevoked?: BoolFilter<"JWTToken"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type JWTTokenOrderByWithRelationInput = {
    id?: SortOrder
    token?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    permissions?: SortOrder
    zkProofHash?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    provider?: ProviderOrderByWithRelationInput
    contract?: ContractOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type JWTTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: JWTTokenWhereInput | JWTTokenWhereInput[]
    OR?: JWTTokenWhereInput[]
    NOT?: JWTTokenWhereInput | JWTTokenWhereInput[]
    providerId?: IntFilter<"JWTToken"> | number
    contractId?: StringNullableFilter<"JWTToken"> | string | null
    serviceId?: StringFilter<"JWTToken"> | string
    permissions?: JsonFilter<"JWTToken">
    zkProofHash?: StringNullableFilter<"JWTToken"> | string | null
    issuedAt?: DateTimeFilter<"JWTToken"> | Date | string
    expiresAt?: DateTimeFilter<"JWTToken"> | Date | string
    isRevoked?: BoolFilter<"JWTToken"> | boolean
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id" | "token">

  export type JWTTokenOrderByWithAggregationInput = {
    id?: SortOrder
    token?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    permissions?: SortOrder
    zkProofHash?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
    _count?: JWTTokenCountOrderByAggregateInput
    _avg?: JWTTokenAvgOrderByAggregateInput
    _max?: JWTTokenMaxOrderByAggregateInput
    _min?: JWTTokenMinOrderByAggregateInput
    _sum?: JWTTokenSumOrderByAggregateInput
  }

  export type JWTTokenScalarWhereWithAggregatesInput = {
    AND?: JWTTokenScalarWhereWithAggregatesInput | JWTTokenScalarWhereWithAggregatesInput[]
    OR?: JWTTokenScalarWhereWithAggregatesInput[]
    NOT?: JWTTokenScalarWhereWithAggregatesInput | JWTTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"JWTToken"> | string
    token?: StringWithAggregatesFilter<"JWTToken"> | string
    providerId?: IntWithAggregatesFilter<"JWTToken"> | number
    contractId?: StringNullableWithAggregatesFilter<"JWTToken"> | string | null
    serviceId?: StringWithAggregatesFilter<"JWTToken"> | string
    permissions?: JsonWithAggregatesFilter<"JWTToken">
    zkProofHash?: StringNullableWithAggregatesFilter<"JWTToken"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"JWTToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"JWTToken"> | Date | string
    isRevoked?: BoolWithAggregatesFilter<"JWTToken"> | boolean
  }

  export type ServiceSubscriptionWhereInput = {
    AND?: ServiceSubscriptionWhereInput | ServiceSubscriptionWhereInput[]
    OR?: ServiceSubscriptionWhereInput[]
    NOT?: ServiceSubscriptionWhereInput | ServiceSubscriptionWhereInput[]
    id?: StringFilter<"ServiceSubscription"> | string
    platformId?: StringFilter<"ServiceSubscription"> | string
    serviceId?: StringFilter<"ServiceSubscription"> | string
    providerId?: IntFilter<"ServiceSubscription"> | number
    accessLevel?: EnumAccessLevelFilter<"ServiceSubscription"> | $Enums.AccessLevel
    contractAccess?: JsonFilter<"ServiceSubscription">
    subscribedAt?: DateTimeFilter<"ServiceSubscription"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ServiceSubscription"> | Date | string | null
    isActive?: BoolFilter<"ServiceSubscription"> | boolean
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type ServiceSubscriptionOrderByWithRelationInput = {
    id?: SortOrder
    platformId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessLevel?: SortOrder
    contractAccess?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    platform?: PlatformOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type ServiceSubscriptionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServiceSubscriptionWhereInput | ServiceSubscriptionWhereInput[]
    OR?: ServiceSubscriptionWhereInput[]
    NOT?: ServiceSubscriptionWhereInput | ServiceSubscriptionWhereInput[]
    platformId?: StringFilter<"ServiceSubscription"> | string
    serviceId?: StringFilter<"ServiceSubscription"> | string
    providerId?: IntFilter<"ServiceSubscription"> | number
    accessLevel?: EnumAccessLevelFilter<"ServiceSubscription"> | $Enums.AccessLevel
    contractAccess?: JsonFilter<"ServiceSubscription">
    subscribedAt?: DateTimeFilter<"ServiceSubscription"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ServiceSubscription"> | Date | string | null
    isActive?: BoolFilter<"ServiceSubscription"> | boolean
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type ServiceSubscriptionOrderByWithAggregationInput = {
    id?: SortOrder
    platformId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessLevel?: SortOrder
    contractAccess?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    _count?: ServiceSubscriptionCountOrderByAggregateInput
    _avg?: ServiceSubscriptionAvgOrderByAggregateInput
    _max?: ServiceSubscriptionMaxOrderByAggregateInput
    _min?: ServiceSubscriptionMinOrderByAggregateInput
    _sum?: ServiceSubscriptionSumOrderByAggregateInput
  }

  export type ServiceSubscriptionScalarWhereWithAggregatesInput = {
    AND?: ServiceSubscriptionScalarWhereWithAggregatesInput | ServiceSubscriptionScalarWhereWithAggregatesInput[]
    OR?: ServiceSubscriptionScalarWhereWithAggregatesInput[]
    NOT?: ServiceSubscriptionScalarWhereWithAggregatesInput | ServiceSubscriptionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServiceSubscription"> | string
    platformId?: StringWithAggregatesFilter<"ServiceSubscription"> | string
    serviceId?: StringWithAggregatesFilter<"ServiceSubscription"> | string
    providerId?: IntWithAggregatesFilter<"ServiceSubscription"> | number
    accessLevel?: EnumAccessLevelWithAggregatesFilter<"ServiceSubscription"> | $Enums.AccessLevel
    contractAccess?: JsonWithAggregatesFilter<"ServiceSubscription">
    subscribedAt?: DateTimeWithAggregatesFilter<"ServiceSubscription"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ServiceSubscription"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ServiceSubscription"> | boolean
  }

  export type PlatformAccessTokenWhereInput = {
    AND?: PlatformAccessTokenWhereInput | PlatformAccessTokenWhereInput[]
    OR?: PlatformAccessTokenWhereInput[]
    NOT?: PlatformAccessTokenWhereInput | PlatformAccessTokenWhereInput[]
    id?: StringFilter<"PlatformAccessToken"> | string
    platformId?: StringFilter<"PlatformAccessToken"> | string
    providerId?: IntFilter<"PlatformAccessToken"> | number
    token?: StringFilter<"PlatformAccessToken"> | string
    serviceIds?: StringNullableListFilter<"PlatformAccessToken">
    permissions?: JsonFilter<"PlatformAccessToken">
    zkProofRequired?: BoolFilter<"PlatformAccessToken"> | boolean
    issuedAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    expiresAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    isActive?: BoolFilter<"PlatformAccessToken"> | boolean
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type PlatformAccessTokenOrderByWithRelationInput = {
    id?: SortOrder
    platformId?: SortOrder
    providerId?: SortOrder
    token?: SortOrder
    serviceIds?: SortOrder
    permissions?: SortOrder
    zkProofRequired?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    platform?: PlatformOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type PlatformAccessTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: PlatformAccessTokenWhereInput | PlatformAccessTokenWhereInput[]
    OR?: PlatformAccessTokenWhereInput[]
    NOT?: PlatformAccessTokenWhereInput | PlatformAccessTokenWhereInput[]
    platformId?: StringFilter<"PlatformAccessToken"> | string
    providerId?: IntFilter<"PlatformAccessToken"> | number
    serviceIds?: StringNullableListFilter<"PlatformAccessToken">
    permissions?: JsonFilter<"PlatformAccessToken">
    zkProofRequired?: BoolFilter<"PlatformAccessToken"> | boolean
    issuedAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    expiresAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    isActive?: BoolFilter<"PlatformAccessToken"> | boolean
    platform?: XOR<PlatformScalarRelationFilter, PlatformWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id" | "token">

  export type PlatformAccessTokenOrderByWithAggregationInput = {
    id?: SortOrder
    platformId?: SortOrder
    providerId?: SortOrder
    token?: SortOrder
    serviceIds?: SortOrder
    permissions?: SortOrder
    zkProofRequired?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    _count?: PlatformAccessTokenCountOrderByAggregateInput
    _avg?: PlatformAccessTokenAvgOrderByAggregateInput
    _max?: PlatformAccessTokenMaxOrderByAggregateInput
    _min?: PlatformAccessTokenMinOrderByAggregateInput
    _sum?: PlatformAccessTokenSumOrderByAggregateInput
  }

  export type PlatformAccessTokenScalarWhereWithAggregatesInput = {
    AND?: PlatformAccessTokenScalarWhereWithAggregatesInput | PlatformAccessTokenScalarWhereWithAggregatesInput[]
    OR?: PlatformAccessTokenScalarWhereWithAggregatesInput[]
    NOT?: PlatformAccessTokenScalarWhereWithAggregatesInput | PlatformAccessTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PlatformAccessToken"> | string
    platformId?: StringWithAggregatesFilter<"PlatformAccessToken"> | string
    providerId?: IntWithAggregatesFilter<"PlatformAccessToken"> | number
    token?: StringWithAggregatesFilter<"PlatformAccessToken"> | string
    serviceIds?: StringNullableListFilter<"PlatformAccessToken">
    permissions?: JsonWithAggregatesFilter<"PlatformAccessToken">
    zkProofRequired?: BoolWithAggregatesFilter<"PlatformAccessToken"> | boolean
    issuedAt?: DateTimeWithAggregatesFilter<"PlatformAccessToken"> | Date | string
    expiresAt?: DateTimeWithAggregatesFilter<"PlatformAccessToken"> | Date | string
    isActive?: BoolWithAggregatesFilter<"PlatformAccessToken"> | boolean
  }

  export type ServicePermissionWhereInput = {
    AND?: ServicePermissionWhereInput | ServicePermissionWhereInput[]
    OR?: ServicePermissionWhereInput[]
    NOT?: ServicePermissionWhereInput | ServicePermissionWhereInput[]
    id?: StringFilter<"ServicePermission"> | string
    contractId?: StringFilter<"ServicePermission"> | string
    serviceId?: StringFilter<"ServicePermission"> | string
    providerId?: IntFilter<"ServicePermission"> | number
    accessGranted?: BoolFilter<"ServicePermission"> | boolean
    jwtToken?: StringNullableFilter<"ServicePermission"> | string | null
    grantedAt?: DateTimeFilter<"ServicePermission"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePermission"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type ServicePermissionOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessGranted?: SortOrder
    jwtToken?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    updatedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type ServicePermissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ServicePermissionWhereInput | ServicePermissionWhereInput[]
    OR?: ServicePermissionWhereInput[]
    NOT?: ServicePermissionWhereInput | ServicePermissionWhereInput[]
    contractId?: StringFilter<"ServicePermission"> | string
    serviceId?: StringFilter<"ServicePermission"> | string
    providerId?: IntFilter<"ServicePermission"> | number
    accessGranted?: BoolFilter<"ServicePermission"> | boolean
    jwtToken?: StringNullableFilter<"ServicePermission"> | string | null
    grantedAt?: DateTimeFilter<"ServicePermission"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePermission"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type ServicePermissionOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessGranted?: SortOrder
    jwtToken?: SortOrderInput | SortOrder
    grantedAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ServicePermissionCountOrderByAggregateInput
    _avg?: ServicePermissionAvgOrderByAggregateInput
    _max?: ServicePermissionMaxOrderByAggregateInput
    _min?: ServicePermissionMinOrderByAggregateInput
    _sum?: ServicePermissionSumOrderByAggregateInput
  }

  export type ServicePermissionScalarWhereWithAggregatesInput = {
    AND?: ServicePermissionScalarWhereWithAggregatesInput | ServicePermissionScalarWhereWithAggregatesInput[]
    OR?: ServicePermissionScalarWhereWithAggregatesInput[]
    NOT?: ServicePermissionScalarWhereWithAggregatesInput | ServicePermissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ServicePermission"> | string
    contractId?: StringWithAggregatesFilter<"ServicePermission"> | string
    serviceId?: StringWithAggregatesFilter<"ServicePermission"> | string
    providerId?: IntWithAggregatesFilter<"ServicePermission"> | number
    accessGranted?: BoolWithAggregatesFilter<"ServicePermission"> | boolean
    jwtToken?: StringNullableWithAggregatesFilter<"ServicePermission"> | string | null
    grantedAt?: DateTimeWithAggregatesFilter<"ServicePermission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ServicePermission"> | Date | string
  }

  export type AccessLogWhereInput = {
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    id?: StringFilter<"AccessLog"> | string
    contractId?: StringNullableFilter<"AccessLog"> | string | null
    serviceId?: StringFilter<"AccessLog"> | string
    providerId?: IntFilter<"AccessLog"> | number
    action?: StringFilter<"AccessLog"> | string
    zkProofHash?: StringNullableFilter<"AccessLog"> | string | null
    metadata?: JsonNullableFilter<"AccessLog">
    timestamp?: DateTimeFilter<"AccessLog"> | Date | string
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }

  export type AccessLogOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    action?: SortOrder
    zkProofHash?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    contract?: ContractOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
    provider?: ProviderOrderByWithRelationInput
  }

  export type AccessLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AccessLogWhereInput | AccessLogWhereInput[]
    OR?: AccessLogWhereInput[]
    NOT?: AccessLogWhereInput | AccessLogWhereInput[]
    contractId?: StringNullableFilter<"AccessLog"> | string | null
    serviceId?: StringFilter<"AccessLog"> | string
    providerId?: IntFilter<"AccessLog"> | number
    action?: StringFilter<"AccessLog"> | string
    zkProofHash?: StringNullableFilter<"AccessLog"> | string | null
    metadata?: JsonNullableFilter<"AccessLog">
    timestamp?: DateTimeFilter<"AccessLog"> | Date | string
    contract?: XOR<ContractNullableScalarRelationFilter, ContractWhereInput> | null
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
  }, "id">

  export type AccessLogOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrderInput | SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    action?: SortOrder
    zkProofHash?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    timestamp?: SortOrder
    _count?: AccessLogCountOrderByAggregateInput
    _avg?: AccessLogAvgOrderByAggregateInput
    _max?: AccessLogMaxOrderByAggregateInput
    _min?: AccessLogMinOrderByAggregateInput
    _sum?: AccessLogSumOrderByAggregateInput
  }

  export type AccessLogScalarWhereWithAggregatesInput = {
    AND?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    OR?: AccessLogScalarWhereWithAggregatesInput[]
    NOT?: AccessLogScalarWhereWithAggregatesInput | AccessLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AccessLog"> | string
    contractId?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    serviceId?: StringWithAggregatesFilter<"AccessLog"> | string
    providerId?: IntWithAggregatesFilter<"AccessLog"> | number
    action?: StringWithAggregatesFilter<"AccessLog"> | string
    zkProofHash?: StringNullableWithAggregatesFilter<"AccessLog"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"AccessLog">
    timestamp?: DateTimeWithAggregatesFilter<"AccessLog"> | Date | string
  }

  export type UsageQuotaWhereInput = {
    AND?: UsageQuotaWhereInput | UsageQuotaWhereInput[]
    OR?: UsageQuotaWhereInput[]
    NOT?: UsageQuotaWhereInput | UsageQuotaWhereInput[]
    id?: StringFilter<"UsageQuota"> | string
    contractPermissionId?: StringFilter<"UsageQuota"> | string
    maxRequests?: IntFilter<"UsageQuota"> | number
    usedRequests?: IntFilter<"UsageQuota"> | number
    timeWindow?: StringFilter<"UsageQuota"> | string
    renewalPeriod?: StringFilter<"UsageQuota"> | string
    lastReset?: DateTimeFilter<"UsageQuota"> | Date | string
    createdAt?: DateTimeFilter<"UsageQuota"> | Date | string
    contractPermission?: XOR<ContractPermissionScalarRelationFilter, ContractPermissionWhereInput>
  }

  export type UsageQuotaOrderByWithRelationInput = {
    id?: SortOrder
    contractPermissionId?: SortOrder
    maxRequests?: SortOrder
    usedRequests?: SortOrder
    timeWindow?: SortOrder
    renewalPeriod?: SortOrder
    lastReset?: SortOrder
    createdAt?: SortOrder
    contractPermission?: ContractPermissionOrderByWithRelationInput
  }

  export type UsageQuotaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    contractPermissionId?: string
    AND?: UsageQuotaWhereInput | UsageQuotaWhereInput[]
    OR?: UsageQuotaWhereInput[]
    NOT?: UsageQuotaWhereInput | UsageQuotaWhereInput[]
    maxRequests?: IntFilter<"UsageQuota"> | number
    usedRequests?: IntFilter<"UsageQuota"> | number
    timeWindow?: StringFilter<"UsageQuota"> | string
    renewalPeriod?: StringFilter<"UsageQuota"> | string
    lastReset?: DateTimeFilter<"UsageQuota"> | Date | string
    createdAt?: DateTimeFilter<"UsageQuota"> | Date | string
    contractPermission?: XOR<ContractPermissionScalarRelationFilter, ContractPermissionWhereInput>
  }, "id" | "contractPermissionId">

  export type UsageQuotaOrderByWithAggregationInput = {
    id?: SortOrder
    contractPermissionId?: SortOrder
    maxRequests?: SortOrder
    usedRequests?: SortOrder
    timeWindow?: SortOrder
    renewalPeriod?: SortOrder
    lastReset?: SortOrder
    createdAt?: SortOrder
    _count?: UsageQuotaCountOrderByAggregateInput
    _avg?: UsageQuotaAvgOrderByAggregateInput
    _max?: UsageQuotaMaxOrderByAggregateInput
    _min?: UsageQuotaMinOrderByAggregateInput
    _sum?: UsageQuotaSumOrderByAggregateInput
  }

  export type UsageQuotaScalarWhereWithAggregatesInput = {
    AND?: UsageQuotaScalarWhereWithAggregatesInput | UsageQuotaScalarWhereWithAggregatesInput[]
    OR?: UsageQuotaScalarWhereWithAggregatesInput[]
    NOT?: UsageQuotaScalarWhereWithAggregatesInput | UsageQuotaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UsageQuota"> | string
    contractPermissionId?: StringWithAggregatesFilter<"UsageQuota"> | string
    maxRequests?: IntWithAggregatesFilter<"UsageQuota"> | number
    usedRequests?: IntWithAggregatesFilter<"UsageQuota"> | number
    timeWindow?: StringWithAggregatesFilter<"UsageQuota"> | string
    renewalPeriod?: StringWithAggregatesFilter<"UsageQuota"> | string
    lastReset?: DateTimeWithAggregatesFilter<"UsageQuota"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"UsageQuota"> | Date | string
  }

  export type ComplianceAuditWhereInput = {
    AND?: ComplianceAuditWhereInput | ComplianceAuditWhereInput[]
    OR?: ComplianceAuditWhereInput[]
    NOT?: ComplianceAuditWhereInput | ComplianceAuditWhereInput[]
    id?: StringFilter<"ComplianceAudit"> | string
    providerId?: IntFilter<"ComplianceAudit"> | number
    serviceId?: StringNullableFilter<"ComplianceAudit"> | string | null
    framework?: EnumComplianceFrameworkFilter<"ComplianceAudit"> | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFilter<"ComplianceAudit"> | $Enums.ComplianceStatus
    auditData?: JsonFilter<"ComplianceAudit">
    auditDate?: DateTimeFilter<"ComplianceAudit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ComplianceAudit"> | Date | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }

  export type ComplianceAuditOrderByWithRelationInput = {
    id?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    framework?: SortOrder
    status?: SortOrder
    auditData?: SortOrder
    auditDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    provider?: ProviderOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ComplianceAuditWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ComplianceAuditWhereInput | ComplianceAuditWhereInput[]
    OR?: ComplianceAuditWhereInput[]
    NOT?: ComplianceAuditWhereInput | ComplianceAuditWhereInput[]
    providerId?: IntFilter<"ComplianceAudit"> | number
    serviceId?: StringNullableFilter<"ComplianceAudit"> | string | null
    framework?: EnumComplianceFrameworkFilter<"ComplianceAudit"> | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFilter<"ComplianceAudit"> | $Enums.ComplianceStatus
    auditData?: JsonFilter<"ComplianceAudit">
    auditDate?: DateTimeFilter<"ComplianceAudit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ComplianceAudit"> | Date | string | null
    provider?: XOR<ProviderScalarRelationFilter, ProviderWhereInput>
    service?: XOR<ServiceNullableScalarRelationFilter, ServiceWhereInput> | null
  }, "id">

  export type ComplianceAuditOrderByWithAggregationInput = {
    id?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrderInput | SortOrder
    framework?: SortOrder
    status?: SortOrder
    auditData?: SortOrder
    auditDate?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    _count?: ComplianceAuditCountOrderByAggregateInput
    _avg?: ComplianceAuditAvgOrderByAggregateInput
    _max?: ComplianceAuditMaxOrderByAggregateInput
    _min?: ComplianceAuditMinOrderByAggregateInput
    _sum?: ComplianceAuditSumOrderByAggregateInput
  }

  export type ComplianceAuditScalarWhereWithAggregatesInput = {
    AND?: ComplianceAuditScalarWhereWithAggregatesInput | ComplianceAuditScalarWhereWithAggregatesInput[]
    OR?: ComplianceAuditScalarWhereWithAggregatesInput[]
    NOT?: ComplianceAuditScalarWhereWithAggregatesInput | ComplianceAuditScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ComplianceAudit"> | string
    providerId?: IntWithAggregatesFilter<"ComplianceAudit"> | number
    serviceId?: StringNullableWithAggregatesFilter<"ComplianceAudit"> | string | null
    framework?: EnumComplianceFrameworkWithAggregatesFilter<"ComplianceAudit"> | $Enums.ComplianceFramework
    status?: EnumComplianceStatusWithAggregatesFilter<"ComplianceAudit"> | $Enums.ComplianceStatus
    auditData?: JsonWithAggregatesFilter<"ComplianceAudit">
    auditDate?: DateTimeWithAggregatesFilter<"ComplianceAudit"> | Date | string
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ComplianceAudit"> | Date | string | null
  }

  export type ZKProofVerificationWhereInput = {
    AND?: ZKProofVerificationWhereInput | ZKProofVerificationWhereInput[]
    OR?: ZKProofVerificationWhereInput[]
    NOT?: ZKProofVerificationWhereInput | ZKProofVerificationWhereInput[]
    id?: StringFilter<"ZKProofVerification"> | string
    contractId?: StringFilter<"ZKProofVerification"> | string
    serviceId?: StringFilter<"ZKProofVerification"> | string
    proofType?: EnumZKProofTypeFilter<"ZKProofVerification"> | $Enums.ZKProofType
    proofHash?: StringFilter<"ZKProofVerification"> | string
    publicInputs?: JsonFilter<"ZKProofVerification">
    isValid?: BoolFilter<"ZKProofVerification"> | boolean
    verifiedAt?: DateTimeFilter<"ZKProofVerification"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }

  export type ZKProofVerificationOrderByWithRelationInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    proofType?: SortOrder
    proofHash?: SortOrder
    publicInputs?: SortOrder
    isValid?: SortOrder
    verifiedAt?: SortOrder
    contract?: ContractOrderByWithRelationInput
    service?: ServiceOrderByWithRelationInput
  }

  export type ZKProofVerificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ZKProofVerificationWhereInput | ZKProofVerificationWhereInput[]
    OR?: ZKProofVerificationWhereInput[]
    NOT?: ZKProofVerificationWhereInput | ZKProofVerificationWhereInput[]
    contractId?: StringFilter<"ZKProofVerification"> | string
    serviceId?: StringFilter<"ZKProofVerification"> | string
    proofType?: EnumZKProofTypeFilter<"ZKProofVerification"> | $Enums.ZKProofType
    proofHash?: StringFilter<"ZKProofVerification"> | string
    publicInputs?: JsonFilter<"ZKProofVerification">
    isValid?: BoolFilter<"ZKProofVerification"> | boolean
    verifiedAt?: DateTimeFilter<"ZKProofVerification"> | Date | string
    contract?: XOR<ContractScalarRelationFilter, ContractWhereInput>
    service?: XOR<ServiceScalarRelationFilter, ServiceWhereInput>
  }, "id">

  export type ZKProofVerificationOrderByWithAggregationInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    proofType?: SortOrder
    proofHash?: SortOrder
    publicInputs?: SortOrder
    isValid?: SortOrder
    verifiedAt?: SortOrder
    _count?: ZKProofVerificationCountOrderByAggregateInput
    _max?: ZKProofVerificationMaxOrderByAggregateInput
    _min?: ZKProofVerificationMinOrderByAggregateInput
  }

  export type ZKProofVerificationScalarWhereWithAggregatesInput = {
    AND?: ZKProofVerificationScalarWhereWithAggregatesInput | ZKProofVerificationScalarWhereWithAggregatesInput[]
    OR?: ZKProofVerificationScalarWhereWithAggregatesInput[]
    NOT?: ZKProofVerificationScalarWhereWithAggregatesInput | ZKProofVerificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ZKProofVerification"> | string
    contractId?: StringWithAggregatesFilter<"ZKProofVerification"> | string
    serviceId?: StringWithAggregatesFilter<"ZKProofVerification"> | string
    proofType?: EnumZKProofTypeWithAggregatesFilter<"ZKProofVerification"> | $Enums.ZKProofType
    proofHash?: StringWithAggregatesFilter<"ZKProofVerification"> | string
    publicInputs?: JsonWithAggregatesFilter<"ZKProofVerification">
    isValid?: BoolWithAggregatesFilter<"ZKProofVerification"> | boolean
    verifiedAt?: DateTimeWithAggregatesFilter<"ZKProofVerification"> | Date | string
  }

  export type ProviderCreateInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ProviderCreateManyInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProviderUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceCreateInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformCreateInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformCreateManyInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractCreateManyInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessCreateInput = {
    id?: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutPlatformAccessInput
    platform: PlatformCreateNestedOneWithoutPlatformAccessInput
  }

  export type PlatformAccessUncheckedCreateInput = {
    id?: string
    providerId: number
    platformId: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAccessUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutPlatformAccessNestedInput
    platform?: PlatformUpdateOneRequiredWithoutPlatformAccessNestedInput
  }

  export type PlatformAccessUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    platformId?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessCreateManyInput = {
    id?: string
    providerId: number
    platformId: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAccessUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    platformId?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractPermissionCreateInput = {
    id?: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    provider: ProviderCreateNestedOneWithoutContractPermissionsInput
    contract: ContractCreateNestedOneWithoutContractPermissionsInput
    service: ServiceCreateNestedOneWithoutContractPermissionsInput
    usageQuota?: UsageQuotaCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionUncheckedCreateInput = {
    id?: string
    providerId: number
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    usageQuota?: UsageQuotaUncheckedCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutContractPermissionsNestedInput
    contract?: ContractUpdateOneRequiredWithoutContractPermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutContractPermissionsNestedInput
    usageQuota?: UsageQuotaUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageQuota?: UsageQuotaUncheckedUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionCreateManyInput = {
    id?: string
    providerId: number
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type ContractPermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ContractPermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenCreateInput = {
    id?: string
    token: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
    provider: ProviderCreateNestedOneWithoutJwtTokensInput
    contract?: ContractCreateNestedOneWithoutJwtTokensInput
    service: ServiceCreateNestedOneWithoutJwtTokensInput
  }

  export type JWTTokenUncheckedCreateInput = {
    id?: string
    token: string
    providerId: number
    contractId?: string | null
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type JWTTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutJwtTokensNestedInput
    contract?: ContractUpdateOneWithoutJwtTokensNestedInput
    service?: ServiceUpdateOneRequiredWithoutJwtTokensNestedInput
  }

  export type JWTTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenCreateManyInput = {
    id?: string
    token: string
    providerId: number
    contractId?: string | null
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type JWTTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionCreateInput = {
    id?: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    platform: PlatformCreateNestedOneWithoutServiceSubscriptionsInput
    service: ServiceCreateNestedOneWithoutServiceSubscriptionsInput
    provider: ProviderCreateNestedOneWithoutServiceSubscriptionsInput
  }

  export type ServiceSubscriptionUncheckedCreateInput = {
    id?: string
    platformId: string
    serviceId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServiceSubscriptionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    platform?: PlatformUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
  }

  export type ServiceSubscriptionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionCreateManyInput = {
    id?: string
    platformId: string
    serviceId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServiceSubscriptionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenCreateInput = {
    id?: string
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    platform: PlatformCreateNestedOneWithoutPlatformAccessTokensInput
    provider: ProviderCreateNestedOneWithoutPlatformAccessTokensInput
  }

  export type PlatformAccessTokenUncheckedCreateInput = {
    id?: string
    platformId: string
    providerId: number
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type PlatformAccessTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    platform?: PlatformUpdateOneRequiredWithoutPlatformAccessTokensNestedInput
    provider?: ProviderUpdateOneRequiredWithoutPlatformAccessTokensNestedInput
  }

  export type PlatformAccessTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenCreateManyInput = {
    id?: string
    platformId: string
    providerId: number
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type PlatformAccessTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicePermissionCreateInput = {
    id?: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutServicePermissionsInput
    service: ServiceCreateNestedOneWithoutServicePermissionsInput
    provider: ProviderCreateNestedOneWithoutServicePermissionInput
  }

  export type ServicePermissionUncheckedCreateInput = {
    id?: string
    contractId: string
    serviceId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePermissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutServicePermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutServicePermissionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServicePermissionNestedInput
  }

  export type ServicePermissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionCreateManyInput = {
    id?: string
    contractId: string
    serviceId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePermissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogCreateInput = {
    id?: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    contract?: ContractCreateNestedOneWithoutAccessLogsInput
    service: ServiceCreateNestedOneWithoutAccessLogsInput
    provider: ProviderCreateNestedOneWithoutAccessLogsInput
  }

  export type AccessLogUncheckedCreateInput = {
    id?: string
    contractId?: string | null
    serviceId: string
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AccessLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutAccessLogsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAccessLogsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type AccessLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogCreateManyInput = {
    id?: string
    contractId?: string | null
    serviceId: string
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AccessLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageQuotaCreateInput = {
    id?: string
    maxRequests: number
    usedRequests?: number
    timeWindow: string
    renewalPeriod: string
    lastReset?: Date | string
    createdAt?: Date | string
    contractPermission: ContractPermissionCreateNestedOneWithoutUsageQuotaInput
  }

  export type UsageQuotaUncheckedCreateInput = {
    id?: string
    contractPermissionId: string
    maxRequests: number
    usedRequests?: number
    timeWindow: string
    renewalPeriod: string
    lastReset?: Date | string
    createdAt?: Date | string
  }

  export type UsageQuotaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermission?: ContractPermissionUpdateOneRequiredWithoutUsageQuotaNestedInput
  }

  export type UsageQuotaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractPermissionId?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageQuotaCreateManyInput = {
    id?: string
    contractPermissionId: string
    maxRequests: number
    usedRequests?: number
    timeWindow: string
    renewalPeriod: string
    lastReset?: Date | string
    createdAt?: Date | string
  }

  export type UsageQuotaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageQuotaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractPermissionId?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAuditCreateInput = {
    id?: string
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
    provider: ProviderCreateNestedOneWithoutComplianceAuditsInput
    service?: ServiceCreateNestedOneWithoutComplianceAuditsInput
  }

  export type ComplianceAuditUncheckedCreateInput = {
    id?: string
    providerId: number
    serviceId?: string | null
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type ComplianceAuditUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneRequiredWithoutComplianceAuditsNestedInput
    service?: ServiceUpdateOneWithoutComplianceAuditsNestedInput
  }

  export type ComplianceAuditUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComplianceAuditCreateManyInput = {
    id?: string
    providerId: number
    serviceId?: string | null
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type ComplianceAuditUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComplianceAuditUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZKProofVerificationCreateInput = {
    id?: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
    contract: ContractCreateNestedOneWithoutZkProofVerificationsInput
    service: ServiceCreateNestedOneWithoutZkProofVerificationsInput
  }

  export type ZKProofVerificationUncheckedCreateInput = {
    id?: string
    contractId: string
    serviceId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ZKProofVerificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutZkProofVerificationsNestedInput
    service?: ServiceUpdateOneRequiredWithoutZkProofVerificationsNestedInput
  }

  export type ZKProofVerificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZKProofVerificationCreateManyInput = {
    id?: string
    contractId: string
    serviceId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ZKProofVerificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZKProofVerificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type EnumRWATypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RWAType | EnumRWATypeFieldRefInput<$PrismaModel>
    in?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRWATypeFilter<$PrismaModel> | $Enums.RWAType
  }

  export type EnumVerificationLayerFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationLayer | EnumVerificationLayerFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationLayerFilter<$PrismaModel> | $Enums.VerificationLayer
  }

  export type EnumInteractionLayerFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionLayer | EnumInteractionLayerFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionLayerFilter<$PrismaModel> | $Enums.InteractionLayer
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumServiceVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceVerificationType | EnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceVerificationTypeFilter<$PrismaModel> | $Enums.ServiceVerificationType
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumInteropProtocolNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.InteropProtocol[] | ListEnumInteropProtocolFieldRefInput<$PrismaModel> | null
    has?: $Enums.InteropProtocol | EnumInteropProtocolFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.InteropProtocol[] | ListEnumInteropProtocolFieldRefInput<$PrismaModel>
    hasSome?: $Enums.InteropProtocol[] | ListEnumInteropProtocolFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type EnumAuthMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthMethodFilter<$PrismaModel> | $Enums.AuthMethod
  }

  export type EnumZKProofTypeNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel> | null
    has?: $Enums.ZKProofType | EnumZKProofTypeFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumPrivacyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PrivacyLevel | EnumPrivacyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyLevelFilter<$PrismaModel> | $Enums.PrivacyLevel
  }

  export type EnumComplianceFrameworkNullableListFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel> | null
    has?: $Enums.ComplianceFramework | EnumComplianceFrameworkFieldRefInput<$PrismaModel> | null
    hasEvery?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    hasSome?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ServiceListRelationFilter = {
    every?: ServiceWhereInput
    some?: ServiceWhereInput
    none?: ServiceWhereInput
  }

  export type PlatformAccessListRelationFilter = {
    every?: PlatformAccessWhereInput
    some?: PlatformAccessWhereInput
    none?: PlatformAccessWhereInput
  }

  export type ContractPermissionListRelationFilter = {
    every?: ContractPermissionWhereInput
    some?: ContractPermissionWhereInput
    none?: ContractPermissionWhereInput
  }

  export type JWTTokenListRelationFilter = {
    every?: JWTTokenWhereInput
    some?: JWTTokenWhereInput
    none?: JWTTokenWhereInput
  }

  export type ServiceSubscriptionListRelationFilter = {
    every?: ServiceSubscriptionWhereInput
    some?: ServiceSubscriptionWhereInput
    none?: ServiceSubscriptionWhereInput
  }

  export type PlatformAccessTokenListRelationFilter = {
    every?: PlatformAccessTokenWhereInput
    some?: PlatformAccessTokenWhereInput
    none?: PlatformAccessTokenWhereInput
  }

  export type ComplianceAuditListRelationFilter = {
    every?: ComplianceAuditWhereInput
    some?: ComplianceAuditWhereInput
    none?: ComplianceAuditWhereInput
  }

  export type AccessLogListRelationFilter = {
    every?: AccessLogWhereInput
    some?: AccessLogWhereInput
    none?: AccessLogWhereInput
  }

  export type ServicePermissionListRelationFilter = {
    every?: ServicePermissionWhereInput
    some?: ServicePermissionWhereInput
    none?: ServicePermissionWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ServiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformAccessOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ContractPermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type JWTTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceSubscriptionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformAccessTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ComplianceAuditOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AccessLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServicePermissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    email?: SortOrder
    rwaType?: SortOrder
    verificationLayer?: SortOrder
    interactionLayer?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    serviceVerificationType?: SortOrder
    chains?: SortOrder
    interopProtocols?: SortOrder
    serviceFee?: SortOrder
    authMethod?: SortOrder
    jwtSettings?: SortOrder
    zkProofSupport?: SortOrder
    privacyLevel?: SortOrder
    complianceFramework?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type ProviderMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    email?: SortOrder
    rwaType?: SortOrder
    verificationLayer?: SortOrder
    interactionLayer?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    serviceVerificationType?: SortOrder
    authMethod?: SortOrder
    privacyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    serviceType?: SortOrder
    email?: SortOrder
    rwaType?: SortOrder
    verificationLayer?: SortOrder
    interactionLayer?: SortOrder
    logo?: SortOrder
    coverImage?: SortOrder
    serviceVerificationType?: SortOrder
    authMethod?: SortOrder
    privacyLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProviderSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type EnumRWATypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RWAType | EnumRWATypeFieldRefInput<$PrismaModel>
    in?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRWATypeWithAggregatesFilter<$PrismaModel> | $Enums.RWAType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRWATypeFilter<$PrismaModel>
    _max?: NestedEnumRWATypeFilter<$PrismaModel>
  }

  export type EnumVerificationLayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationLayer | EnumVerificationLayerFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationLayerWithAggregatesFilter<$PrismaModel> | $Enums.VerificationLayer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationLayerFilter<$PrismaModel>
    _max?: NestedEnumVerificationLayerFilter<$PrismaModel>
  }

  export type EnumInteractionLayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionLayer | EnumInteractionLayerFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionLayerWithAggregatesFilter<$PrismaModel> | $Enums.InteractionLayer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionLayerFilter<$PrismaModel>
    _max?: NestedEnumInteractionLayerFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumServiceVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceVerificationType | EnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceVerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceVerificationTypeFilter<$PrismaModel>
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumAuthMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel> | $Enums.AuthMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthMethodFilter<$PrismaModel>
    _max?: NestedEnumAuthMethodFilter<$PrismaModel>
  }

  export type EnumPrivacyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrivacyLevel | EnumPrivacyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyLevelWithAggregatesFilter<$PrismaModel> | $Enums.PrivacyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrivacyLevelFilter<$PrismaModel>
    _max?: NestedEnumPrivacyLevelFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumProofOfServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProofOfServiceType | EnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProofOfServiceTypeFilter<$PrismaModel> | $Enums.ProofOfServiceType
  }

  export type EnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type EnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ProviderScalarRelationFilter = {
    is?: ProviderWhereInput
    isNot?: ProviderWhereInput
  }

  export type ZKProofVerificationListRelationFilter = {
    every?: ZKProofVerificationWhereInput
    some?: ZKProofVerificationWhereInput
    none?: ZKProofVerificationWhereInput
  }

  export type ZKProofVerificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ServiceCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    proofOfService?: SortOrder
    serviceCategory?: SortOrder
    authMethod?: SortOrder
    accessLevel?: SortOrder
    rateLimits?: SortOrder
    zkRequirements?: SortOrder
    complianceChecks?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ServiceMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    proofOfService?: SortOrder
    serviceCategory?: SortOrder
    authMethod?: SortOrder
    accessLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    endpoint?: SortOrder
    proofOfService?: SortOrder
    serviceCategory?: SortOrder
    authMethod?: SortOrder
    accessLevel?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServiceSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type EnumProofOfServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProofOfServiceType | EnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProofOfServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProofOfServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProofOfServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumProofOfServiceTypeFilter<$PrismaModel>
  }

  export type EnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type EnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type EnumPermissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelFilter<$PrismaModel> | $Enums.PermissionLevel
  }

  export type ContractListRelationFilter = {
    every?: ContractWhereInput
    some?: ContractWhereInput
    none?: ContractWhereInput
  }

  export type ContractOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PlatformCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platformType?: SortOrder
    email?: SortOrder
    permissionLevel?: SortOrder
    zkCapabilities?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platformType?: SortOrder
    email?: SortOrder
    permissionLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    platformType?: SortOrder
    email?: SortOrder
    permissionLevel?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type EnumPermissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.PermissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionLevelFilter<$PrismaModel>
    _max?: NestedEnumPermissionLevelFilter<$PrismaModel>
  }

  export type EnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type PlatformScalarRelationFilter = {
    is?: PlatformWhereInput
    isNot?: PlatformWhereInput
  }

  export type ContractCountOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    name?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    abi?: SortOrder
    zkProofRequirements?: SortOrder
    complianceStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMaxOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    name?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    complianceStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ContractMinOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    name?: SortOrder
    chain?: SortOrder
    address?: SortOrder
    complianceStatus?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type EnumAccessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeFilter<$PrismaModel> | $Enums.AccessType
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type PlatformAccessCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    platformId?: SortOrder
    grantedServices?: SortOrder
    accessType?: SortOrder
    permissions?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAccessAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type PlatformAccessMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    platformId?: SortOrder
    accessType?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAccessMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    platformId?: SortOrder
    accessType?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PlatformAccessSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type EnumAccessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type ContractScalarRelationFilter = {
    is?: ContractWhereInput
    isNot?: ContractWhereInput
  }

  export type ServiceScalarRelationFilter = {
    is?: ServiceWhereInput
    isNot?: ServiceWhereInput
  }

  export type UsageQuotaNullableScalarRelationFilter = {
    is?: UsageQuotaWhereInput | null
    isNot?: UsageQuotaWhereInput | null
  }

  export type ContractPermissionCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    jwtToken?: SortOrder
    permissions?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ContractPermissionAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ContractPermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    jwtToken?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ContractPermissionMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    jwtToken?: SortOrder
    grantedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ContractPermissionSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ContractNullableScalarRelationFilter = {
    is?: ContractWhereInput | null
    isNot?: ContractWhereInput | null
  }

  export type JWTTokenCountOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    permissions?: SortOrder
    zkProofHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type JWTTokenAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type JWTTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    zkProofHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type JWTTokenMinOrderByAggregateInput = {
    id?: SortOrder
    token?: SortOrder
    providerId?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    zkProofHash?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isRevoked?: SortOrder
  }

  export type JWTTokenSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ServiceSubscriptionCountOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessLevel?: SortOrder
    contractAccess?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceSubscriptionAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ServiceSubscriptionMaxOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessLevel?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceSubscriptionMinOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessLevel?: SortOrder
    subscribedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type ServiceSubscriptionSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type PlatformAccessTokenCountOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    providerId?: SortOrder
    token?: SortOrder
    serviceIds?: SortOrder
    permissions?: SortOrder
    zkProofRequired?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformAccessTokenAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type PlatformAccessTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    providerId?: SortOrder
    token?: SortOrder
    zkProofRequired?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformAccessTokenMinOrderByAggregateInput = {
    id?: SortOrder
    platformId?: SortOrder
    providerId?: SortOrder
    token?: SortOrder
    zkProofRequired?: SortOrder
    issuedAt?: SortOrder
    expiresAt?: SortOrder
    isActive?: SortOrder
  }

  export type PlatformAccessTokenSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ServicePermissionCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessGranted?: SortOrder
    jwtToken?: SortOrder
    grantedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePermissionAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ServicePermissionMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessGranted?: SortOrder
    jwtToken?: SortOrder
    grantedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePermissionMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    accessGranted?: SortOrder
    jwtToken?: SortOrder
    grantedAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ServicePermissionSumOrderByAggregateInput = {
    providerId?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type AccessLogCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    action?: SortOrder
    zkProofHash?: SortOrder
    metadata?: SortOrder
    timestamp?: SortOrder
  }

  export type AccessLogAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type AccessLogMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    action?: SortOrder
    zkProofHash?: SortOrder
    timestamp?: SortOrder
  }

  export type AccessLogMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    providerId?: SortOrder
    action?: SortOrder
    zkProofHash?: SortOrder
    timestamp?: SortOrder
  }

  export type AccessLogSumOrderByAggregateInput = {
    providerId?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type ContractPermissionScalarRelationFilter = {
    is?: ContractPermissionWhereInput
    isNot?: ContractPermissionWhereInput
  }

  export type UsageQuotaCountOrderByAggregateInput = {
    id?: SortOrder
    contractPermissionId?: SortOrder
    maxRequests?: SortOrder
    usedRequests?: SortOrder
    timeWindow?: SortOrder
    renewalPeriod?: SortOrder
    lastReset?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageQuotaAvgOrderByAggregateInput = {
    maxRequests?: SortOrder
    usedRequests?: SortOrder
  }

  export type UsageQuotaMaxOrderByAggregateInput = {
    id?: SortOrder
    contractPermissionId?: SortOrder
    maxRequests?: SortOrder
    usedRequests?: SortOrder
    timeWindow?: SortOrder
    renewalPeriod?: SortOrder
    lastReset?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageQuotaMinOrderByAggregateInput = {
    id?: SortOrder
    contractPermissionId?: SortOrder
    maxRequests?: SortOrder
    usedRequests?: SortOrder
    timeWindow?: SortOrder
    renewalPeriod?: SortOrder
    lastReset?: SortOrder
    createdAt?: SortOrder
  }

  export type UsageQuotaSumOrderByAggregateInput = {
    maxRequests?: SortOrder
    usedRequests?: SortOrder
  }

  export type EnumComplianceFrameworkFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceFramework | EnumComplianceFrameworkFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceFrameworkFilter<$PrismaModel> | $Enums.ComplianceFramework
  }

  export type ServiceNullableScalarRelationFilter = {
    is?: ServiceWhereInput | null
    isNot?: ServiceWhereInput | null
  }

  export type ComplianceAuditCountOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    framework?: SortOrder
    status?: SortOrder
    auditData?: SortOrder
    auditDate?: SortOrder
    expiresAt?: SortOrder
  }

  export type ComplianceAuditAvgOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type ComplianceAuditMaxOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    framework?: SortOrder
    status?: SortOrder
    auditDate?: SortOrder
    expiresAt?: SortOrder
  }

  export type ComplianceAuditMinOrderByAggregateInput = {
    id?: SortOrder
    providerId?: SortOrder
    serviceId?: SortOrder
    framework?: SortOrder
    status?: SortOrder
    auditDate?: SortOrder
    expiresAt?: SortOrder
  }

  export type ComplianceAuditSumOrderByAggregateInput = {
    providerId?: SortOrder
  }

  export type EnumComplianceFrameworkWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceFramework | EnumComplianceFrameworkFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceFrameworkWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceFramework
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceFrameworkFilter<$PrismaModel>
    _max?: NestedEnumComplianceFrameworkFilter<$PrismaModel>
  }

  export type EnumZKProofTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZKProofType | EnumZKProofTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZKProofTypeFilter<$PrismaModel> | $Enums.ZKProofType
  }

  export type ZKProofVerificationCountOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    proofType?: SortOrder
    proofHash?: SortOrder
    publicInputs?: SortOrder
    isValid?: SortOrder
    verifiedAt?: SortOrder
  }

  export type ZKProofVerificationMaxOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    proofType?: SortOrder
    proofHash?: SortOrder
    isValid?: SortOrder
    verifiedAt?: SortOrder
  }

  export type ZKProofVerificationMinOrderByAggregateInput = {
    id?: SortOrder
    contractId?: SortOrder
    serviceId?: SortOrder
    proofType?: SortOrder
    proofHash?: SortOrder
    isValid?: SortOrder
    verifiedAt?: SortOrder
  }

  export type EnumZKProofTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZKProofType | EnumZKProofTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZKProofTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZKProofType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZKProofTypeFilter<$PrismaModel>
    _max?: NestedEnumZKProofTypeFilter<$PrismaModel>
  }

  export type ProviderCreatechainsInput = {
    set: string[]
  }

  export type ProviderCreateinteropProtocolsInput = {
    set: $Enums.InteropProtocol[]
  }

  export type ProviderCreatezkProofSupportInput = {
    set: $Enums.ZKProofType[]
  }

  export type ProviderCreatecomplianceFrameworkInput = {
    set: $Enums.ComplianceFramework[]
  }

  export type ServiceCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PlatformAccessCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput> | PlatformAccessCreateWithoutProviderInput[] | PlatformAccessUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutProviderInput | PlatformAccessCreateOrConnectWithoutProviderInput[]
    createMany?: PlatformAccessCreateManyProviderInputEnvelope
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
  }

  export type ContractPermissionCreateNestedManyWithoutProviderInput = {
    create?: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput> | ContractPermissionCreateWithoutProviderInput[] | ContractPermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutProviderInput | ContractPermissionCreateOrConnectWithoutProviderInput[]
    createMany?: ContractPermissionCreateManyProviderInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenCreateNestedManyWithoutProviderInput = {
    create?: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput> | JWTTokenCreateWithoutProviderInput[] | JWTTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutProviderInput | JWTTokenCreateOrConnectWithoutProviderInput[]
    createMany?: JWTTokenCreateManyProviderInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServiceSubscriptionCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput> | ServiceSubscriptionCreateWithoutProviderInput[] | ServiceSubscriptionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutProviderInput | ServiceSubscriptionCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceSubscriptionCreateManyProviderInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type PlatformAccessTokenCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput> | PlatformAccessTokenCreateWithoutProviderInput[] | PlatformAccessTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutProviderInput | PlatformAccessTokenCreateOrConnectWithoutProviderInput[]
    createMany?: PlatformAccessTokenCreateManyProviderInputEnvelope
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
  }

  export type ComplianceAuditCreateNestedManyWithoutProviderInput = {
    create?: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput> | ComplianceAuditCreateWithoutProviderInput[] | ComplianceAuditUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutProviderInput | ComplianceAuditCreateOrConnectWithoutProviderInput[]
    createMany?: ComplianceAuditCreateManyProviderInputEnvelope
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
  }

  export type AccessLogCreateNestedManyWithoutProviderInput = {
    create?: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput> | AccessLogCreateWithoutProviderInput[] | AccessLogUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutProviderInput | AccessLogCreateOrConnectWithoutProviderInput[]
    createMany?: AccessLogCreateManyProviderInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ServicePermissionCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput> | ServicePermissionCreateWithoutProviderInput[] | ServicePermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutProviderInput | ServicePermissionCreateOrConnectWithoutProviderInput[]
    createMany?: ServicePermissionCreateManyProviderInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type ServiceUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
  }

  export type PlatformAccessUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput> | PlatformAccessCreateWithoutProviderInput[] | PlatformAccessUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutProviderInput | PlatformAccessCreateOrConnectWithoutProviderInput[]
    createMany?: PlatformAccessCreateManyProviderInputEnvelope
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
  }

  export type ContractPermissionUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput> | ContractPermissionCreateWithoutProviderInput[] | ContractPermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutProviderInput | ContractPermissionCreateOrConnectWithoutProviderInput[]
    createMany?: ContractPermissionCreateManyProviderInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput> | JWTTokenCreateWithoutProviderInput[] | JWTTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutProviderInput | JWTTokenCreateOrConnectWithoutProviderInput[]
    createMany?: JWTTokenCreateManyProviderInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput> | ServiceSubscriptionCreateWithoutProviderInput[] | ServiceSubscriptionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutProviderInput | ServiceSubscriptionCreateOrConnectWithoutProviderInput[]
    createMany?: ServiceSubscriptionCreateManyProviderInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput> | PlatformAccessTokenCreateWithoutProviderInput[] | PlatformAccessTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutProviderInput | PlatformAccessTokenCreateOrConnectWithoutProviderInput[]
    createMany?: PlatformAccessTokenCreateManyProviderInputEnvelope
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
  }

  export type ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput> | ComplianceAuditCreateWithoutProviderInput[] | ComplianceAuditUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutProviderInput | ComplianceAuditCreateOrConnectWithoutProviderInput[]
    createMany?: ComplianceAuditCreateManyProviderInputEnvelope
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
  }

  export type AccessLogUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput> | AccessLogCreateWithoutProviderInput[] | AccessLogUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutProviderInput | AccessLogCreateOrConnectWithoutProviderInput[]
    createMany?: AccessLogCreateManyProviderInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ServicePermissionUncheckedCreateNestedManyWithoutProviderInput = {
    create?: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput> | ServicePermissionCreateWithoutProviderInput[] | ServicePermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutProviderInput | ServicePermissionCreateOrConnectWithoutProviderInput[]
    createMany?: ServicePermissionCreateManyProviderInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceType
  }

  export type EnumRWATypeFieldUpdateOperationsInput = {
    set?: $Enums.RWAType
  }

  export type EnumVerificationLayerFieldUpdateOperationsInput = {
    set?: $Enums.VerificationLayer
  }

  export type EnumInteractionLayerFieldUpdateOperationsInput = {
    set?: $Enums.InteractionLayer
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumServiceVerificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.ServiceVerificationType
  }

  export type ProviderUpdatechainsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ProviderUpdateinteropProtocolsInput = {
    set?: $Enums.InteropProtocol[]
    push?: $Enums.InteropProtocol | $Enums.InteropProtocol[]
  }

  export type EnumAuthMethodFieldUpdateOperationsInput = {
    set?: $Enums.AuthMethod
  }

  export type ProviderUpdatezkProofSupportInput = {
    set?: $Enums.ZKProofType[]
    push?: $Enums.ZKProofType | $Enums.ZKProofType[]
  }

  export type EnumPrivacyLevelFieldUpdateOperationsInput = {
    set?: $Enums.PrivacyLevel
  }

  export type ProviderUpdatecomplianceFrameworkInput = {
    set?: $Enums.ComplianceFramework[]
    push?: $Enums.ComplianceFramework | $Enums.ComplianceFramework[]
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ServiceUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutProviderInput | ServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutProviderInput | ServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutProviderInput | ServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PlatformAccessUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput> | PlatformAccessCreateWithoutProviderInput[] | PlatformAccessUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutProviderInput | PlatformAccessCreateOrConnectWithoutProviderInput[]
    upsert?: PlatformAccessUpsertWithWhereUniqueWithoutProviderInput | PlatformAccessUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlatformAccessCreateManyProviderInputEnvelope
    set?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    disconnect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    delete?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    update?: PlatformAccessUpdateWithWhereUniqueWithoutProviderInput | PlatformAccessUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlatformAccessUpdateManyWithWhereWithoutProviderInput | PlatformAccessUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
  }

  export type ContractPermissionUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput> | ContractPermissionCreateWithoutProviderInput[] | ContractPermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutProviderInput | ContractPermissionCreateOrConnectWithoutProviderInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutProviderInput | ContractPermissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ContractPermissionCreateManyProviderInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutProviderInput | ContractPermissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutProviderInput | ContractPermissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUpdateManyWithoutProviderNestedInput = {
    create?: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput> | JWTTokenCreateWithoutProviderInput[] | JWTTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutProviderInput | JWTTokenCreateOrConnectWithoutProviderInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutProviderInput | JWTTokenUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: JWTTokenCreateManyProviderInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutProviderInput | JWTTokenUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutProviderInput | JWTTokenUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServiceSubscriptionUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput> | ServiceSubscriptionCreateWithoutProviderInput[] | ServiceSubscriptionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutProviderInput | ServiceSubscriptionCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutProviderInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceSubscriptionCreateManyProviderInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutProviderInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutProviderInput | ServiceSubscriptionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type PlatformAccessTokenUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput> | PlatformAccessTokenCreateWithoutProviderInput[] | PlatformAccessTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutProviderInput | PlatformAccessTokenCreateOrConnectWithoutProviderInput[]
    upsert?: PlatformAccessTokenUpsertWithWhereUniqueWithoutProviderInput | PlatformAccessTokenUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlatformAccessTokenCreateManyProviderInputEnvelope
    set?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    disconnect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    delete?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    update?: PlatformAccessTokenUpdateWithWhereUniqueWithoutProviderInput | PlatformAccessTokenUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlatformAccessTokenUpdateManyWithWhereWithoutProviderInput | PlatformAccessTokenUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
  }

  export type ComplianceAuditUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput> | ComplianceAuditCreateWithoutProviderInput[] | ComplianceAuditUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutProviderInput | ComplianceAuditCreateOrConnectWithoutProviderInput[]
    upsert?: ComplianceAuditUpsertWithWhereUniqueWithoutProviderInput | ComplianceAuditUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ComplianceAuditCreateManyProviderInputEnvelope
    set?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    disconnect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    delete?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    update?: ComplianceAuditUpdateWithWhereUniqueWithoutProviderInput | ComplianceAuditUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ComplianceAuditUpdateManyWithWhereWithoutProviderInput | ComplianceAuditUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
  }

  export type AccessLogUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput> | AccessLogCreateWithoutProviderInput[] | AccessLogUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutProviderInput | AccessLogCreateOrConnectWithoutProviderInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutProviderInput | AccessLogUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AccessLogCreateManyProviderInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutProviderInput | AccessLogUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutProviderInput | AccessLogUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ServicePermissionUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput> | ServicePermissionCreateWithoutProviderInput[] | ServicePermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutProviderInput | ServicePermissionCreateOrConnectWithoutProviderInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutProviderInput | ServicePermissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServicePermissionCreateManyProviderInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutProviderInput | ServicePermissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutProviderInput | ServicePermissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ServiceUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput> | ServiceCreateWithoutProviderInput[] | ServiceUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceCreateOrConnectWithoutProviderInput | ServiceCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceUpsertWithWhereUniqueWithoutProviderInput | ServiceUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceCreateManyProviderInputEnvelope
    set?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    disconnect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    delete?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    connect?: ServiceWhereUniqueInput | ServiceWhereUniqueInput[]
    update?: ServiceUpdateWithWhereUniqueWithoutProviderInput | ServiceUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceUpdateManyWithWhereWithoutProviderInput | ServiceUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
  }

  export type PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput> | PlatformAccessCreateWithoutProviderInput[] | PlatformAccessUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutProviderInput | PlatformAccessCreateOrConnectWithoutProviderInput[]
    upsert?: PlatformAccessUpsertWithWhereUniqueWithoutProviderInput | PlatformAccessUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlatformAccessCreateManyProviderInputEnvelope
    set?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    disconnect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    delete?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    update?: PlatformAccessUpdateWithWhereUniqueWithoutProviderInput | PlatformAccessUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlatformAccessUpdateManyWithWhereWithoutProviderInput | PlatformAccessUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
  }

  export type ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput> | ContractPermissionCreateWithoutProviderInput[] | ContractPermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutProviderInput | ContractPermissionCreateOrConnectWithoutProviderInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutProviderInput | ContractPermissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ContractPermissionCreateManyProviderInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutProviderInput | ContractPermissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutProviderInput | ContractPermissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput> | JWTTokenCreateWithoutProviderInput[] | JWTTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutProviderInput | JWTTokenCreateOrConnectWithoutProviderInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutProviderInput | JWTTokenUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: JWTTokenCreateManyProviderInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutProviderInput | JWTTokenUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutProviderInput | JWTTokenUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput> | ServiceSubscriptionCreateWithoutProviderInput[] | ServiceSubscriptionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutProviderInput | ServiceSubscriptionCreateOrConnectWithoutProviderInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutProviderInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServiceSubscriptionCreateManyProviderInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutProviderInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutProviderInput | ServiceSubscriptionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput> | PlatformAccessTokenCreateWithoutProviderInput[] | PlatformAccessTokenUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutProviderInput | PlatformAccessTokenCreateOrConnectWithoutProviderInput[]
    upsert?: PlatformAccessTokenUpsertWithWhereUniqueWithoutProviderInput | PlatformAccessTokenUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: PlatformAccessTokenCreateManyProviderInputEnvelope
    set?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    disconnect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    delete?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    update?: PlatformAccessTokenUpdateWithWhereUniqueWithoutProviderInput | PlatformAccessTokenUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: PlatformAccessTokenUpdateManyWithWhereWithoutProviderInput | PlatformAccessTokenUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
  }

  export type ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput> | ComplianceAuditCreateWithoutProviderInput[] | ComplianceAuditUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutProviderInput | ComplianceAuditCreateOrConnectWithoutProviderInput[]
    upsert?: ComplianceAuditUpsertWithWhereUniqueWithoutProviderInput | ComplianceAuditUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ComplianceAuditCreateManyProviderInputEnvelope
    set?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    disconnect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    delete?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    update?: ComplianceAuditUpdateWithWhereUniqueWithoutProviderInput | ComplianceAuditUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ComplianceAuditUpdateManyWithWhereWithoutProviderInput | ComplianceAuditUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
  }

  export type AccessLogUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput> | AccessLogCreateWithoutProviderInput[] | AccessLogUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutProviderInput | AccessLogCreateOrConnectWithoutProviderInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutProviderInput | AccessLogUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: AccessLogCreateManyProviderInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutProviderInput | AccessLogUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutProviderInput | AccessLogUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput> | ServicePermissionCreateWithoutProviderInput[] | ServicePermissionUncheckedCreateWithoutProviderInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutProviderInput | ServicePermissionCreateOrConnectWithoutProviderInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutProviderInput | ServicePermissionUpsertWithWhereUniqueWithoutProviderInput[]
    createMany?: ServicePermissionCreateManyProviderInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutProviderInput | ServicePermissionUpdateWithWhereUniqueWithoutProviderInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutProviderInput | ServicePermissionUpdateManyWithWhereWithoutProviderInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type ProviderCreateNestedOneWithoutServicesInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    connect?: ProviderWhereUniqueInput
  }

  export type ContractPermissionCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput> | ContractPermissionCreateWithoutServiceInput[] | ContractPermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutServiceInput | ContractPermissionCreateOrConnectWithoutServiceInput[]
    createMany?: ContractPermissionCreateManyServiceInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenCreateNestedManyWithoutServiceInput = {
    create?: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput> | JWTTokenCreateWithoutServiceInput[] | JWTTokenUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutServiceInput | JWTTokenCreateOrConnectWithoutServiceInput[]
    createMany?: JWTTokenCreateManyServiceInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServiceSubscriptionCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput> | ServiceSubscriptionCreateWithoutServiceInput[] | ServiceSubscriptionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutServiceInput | ServiceSubscriptionCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceSubscriptionCreateManyServiceInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type ServicePermissionCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput> | ServicePermissionCreateWithoutServiceInput[] | ServicePermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutServiceInput | ServicePermissionCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePermissionCreateManyServiceInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type AccessLogCreateNestedManyWithoutServiceInput = {
    create?: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput> | AccessLogCreateWithoutServiceInput[] | AccessLogUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutServiceInput | AccessLogCreateOrConnectWithoutServiceInput[]
    createMany?: AccessLogCreateManyServiceInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ComplianceAuditCreateNestedManyWithoutServiceInput = {
    create?: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput> | ComplianceAuditCreateWithoutServiceInput[] | ComplianceAuditUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutServiceInput | ComplianceAuditCreateOrConnectWithoutServiceInput[]
    createMany?: ComplianceAuditCreateManyServiceInputEnvelope
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
  }

  export type ZKProofVerificationCreateNestedManyWithoutServiceInput = {
    create?: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput> | ZKProofVerificationCreateWithoutServiceInput[] | ZKProofVerificationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutServiceInput | ZKProofVerificationCreateOrConnectWithoutServiceInput[]
    createMany?: ZKProofVerificationCreateManyServiceInputEnvelope
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
  }

  export type ContractPermissionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput> | ContractPermissionCreateWithoutServiceInput[] | ContractPermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutServiceInput | ContractPermissionCreateOrConnectWithoutServiceInput[]
    createMany?: ContractPermissionCreateManyServiceInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput> | JWTTokenCreateWithoutServiceInput[] | JWTTokenUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutServiceInput | JWTTokenCreateOrConnectWithoutServiceInput[]
    createMany?: JWTTokenCreateManyServiceInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput> | ServiceSubscriptionCreateWithoutServiceInput[] | ServiceSubscriptionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutServiceInput | ServiceSubscriptionCreateOrConnectWithoutServiceInput[]
    createMany?: ServiceSubscriptionCreateManyServiceInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type ServicePermissionUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput> | ServicePermissionCreateWithoutServiceInput[] | ServicePermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutServiceInput | ServicePermissionCreateOrConnectWithoutServiceInput[]
    createMany?: ServicePermissionCreateManyServiceInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type AccessLogUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput> | AccessLogCreateWithoutServiceInput[] | AccessLogUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutServiceInput | AccessLogCreateOrConnectWithoutServiceInput[]
    createMany?: AccessLogCreateManyServiceInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput> | ComplianceAuditCreateWithoutServiceInput[] | ComplianceAuditUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutServiceInput | ComplianceAuditCreateOrConnectWithoutServiceInput[]
    createMany?: ComplianceAuditCreateManyServiceInputEnvelope
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
  }

  export type ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput = {
    create?: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput> | ZKProofVerificationCreateWithoutServiceInput[] | ZKProofVerificationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutServiceInput | ZKProofVerificationCreateOrConnectWithoutServiceInput[]
    createMany?: ZKProofVerificationCreateManyServiceInputEnvelope
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
  }

  export type EnumProofOfServiceTypeFieldUpdateOperationsInput = {
    set?: $Enums.ProofOfServiceType
  }

  export type EnumServiceCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ServiceCategory
  }

  export type EnumAccessLevelFieldUpdateOperationsInput = {
    set?: $Enums.AccessLevel
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ProviderUpdateOneRequiredWithoutServicesNestedInput = {
    create?: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicesInput
    upsert?: ProviderUpsertWithoutServicesInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutServicesInput, ProviderUpdateWithoutServicesInput>, ProviderUncheckedUpdateWithoutServicesInput>
  }

  export type ContractPermissionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput> | ContractPermissionCreateWithoutServiceInput[] | ContractPermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutServiceInput | ContractPermissionCreateOrConnectWithoutServiceInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutServiceInput | ContractPermissionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContractPermissionCreateManyServiceInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutServiceInput | ContractPermissionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutServiceInput | ContractPermissionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUpdateManyWithoutServiceNestedInput = {
    create?: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput> | JWTTokenCreateWithoutServiceInput[] | JWTTokenUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutServiceInput | JWTTokenCreateOrConnectWithoutServiceInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutServiceInput | JWTTokenUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: JWTTokenCreateManyServiceInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutServiceInput | JWTTokenUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutServiceInput | JWTTokenUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServiceSubscriptionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput> | ServiceSubscriptionCreateWithoutServiceInput[] | ServiceSubscriptionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutServiceInput | ServiceSubscriptionCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutServiceInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceSubscriptionCreateManyServiceInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutServiceInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutServiceInput | ServiceSubscriptionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type ServicePermissionUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput> | ServicePermissionCreateWithoutServiceInput[] | ServicePermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutServiceInput | ServicePermissionCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutServiceInput | ServicePermissionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePermissionCreateManyServiceInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutServiceInput | ServicePermissionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutServiceInput | ServicePermissionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type AccessLogUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput> | AccessLogCreateWithoutServiceInput[] | AccessLogUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutServiceInput | AccessLogCreateOrConnectWithoutServiceInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutServiceInput | AccessLogUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AccessLogCreateManyServiceInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutServiceInput | AccessLogUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutServiceInput | AccessLogUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ComplianceAuditUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput> | ComplianceAuditCreateWithoutServiceInput[] | ComplianceAuditUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutServiceInput | ComplianceAuditCreateOrConnectWithoutServiceInput[]
    upsert?: ComplianceAuditUpsertWithWhereUniqueWithoutServiceInput | ComplianceAuditUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ComplianceAuditCreateManyServiceInputEnvelope
    set?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    disconnect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    delete?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    update?: ComplianceAuditUpdateWithWhereUniqueWithoutServiceInput | ComplianceAuditUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ComplianceAuditUpdateManyWithWhereWithoutServiceInput | ComplianceAuditUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
  }

  export type ZKProofVerificationUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput> | ZKProofVerificationCreateWithoutServiceInput[] | ZKProofVerificationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutServiceInput | ZKProofVerificationCreateOrConnectWithoutServiceInput[]
    upsert?: ZKProofVerificationUpsertWithWhereUniqueWithoutServiceInput | ZKProofVerificationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ZKProofVerificationCreateManyServiceInputEnvelope
    set?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    disconnect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    delete?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    update?: ZKProofVerificationUpdateWithWhereUniqueWithoutServiceInput | ZKProofVerificationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ZKProofVerificationUpdateManyWithWhereWithoutServiceInput | ZKProofVerificationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
  }

  export type ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput> | ContractPermissionCreateWithoutServiceInput[] | ContractPermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutServiceInput | ContractPermissionCreateOrConnectWithoutServiceInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutServiceInput | ContractPermissionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ContractPermissionCreateManyServiceInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutServiceInput | ContractPermissionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutServiceInput | ContractPermissionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput> | JWTTokenCreateWithoutServiceInput[] | JWTTokenUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutServiceInput | JWTTokenCreateOrConnectWithoutServiceInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutServiceInput | JWTTokenUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: JWTTokenCreateManyServiceInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutServiceInput | JWTTokenUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutServiceInput | JWTTokenUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput> | ServiceSubscriptionCreateWithoutServiceInput[] | ServiceSubscriptionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutServiceInput | ServiceSubscriptionCreateOrConnectWithoutServiceInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutServiceInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServiceSubscriptionCreateManyServiceInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutServiceInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutServiceInput | ServiceSubscriptionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput> | ServicePermissionCreateWithoutServiceInput[] | ServicePermissionUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutServiceInput | ServicePermissionCreateOrConnectWithoutServiceInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutServiceInput | ServicePermissionUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ServicePermissionCreateManyServiceInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutServiceInput | ServicePermissionUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutServiceInput | ServicePermissionUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type AccessLogUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput> | AccessLogCreateWithoutServiceInput[] | AccessLogUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutServiceInput | AccessLogCreateOrConnectWithoutServiceInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutServiceInput | AccessLogUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: AccessLogCreateManyServiceInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutServiceInput | AccessLogUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutServiceInput | AccessLogUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput> | ComplianceAuditCreateWithoutServiceInput[] | ComplianceAuditUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ComplianceAuditCreateOrConnectWithoutServiceInput | ComplianceAuditCreateOrConnectWithoutServiceInput[]
    upsert?: ComplianceAuditUpsertWithWhereUniqueWithoutServiceInput | ComplianceAuditUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ComplianceAuditCreateManyServiceInputEnvelope
    set?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    disconnect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    delete?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    connect?: ComplianceAuditWhereUniqueInput | ComplianceAuditWhereUniqueInput[]
    update?: ComplianceAuditUpdateWithWhereUniqueWithoutServiceInput | ComplianceAuditUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ComplianceAuditUpdateManyWithWhereWithoutServiceInput | ComplianceAuditUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
  }

  export type ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput = {
    create?: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput> | ZKProofVerificationCreateWithoutServiceInput[] | ZKProofVerificationUncheckedCreateWithoutServiceInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutServiceInput | ZKProofVerificationCreateOrConnectWithoutServiceInput[]
    upsert?: ZKProofVerificationUpsertWithWhereUniqueWithoutServiceInput | ZKProofVerificationUpsertWithWhereUniqueWithoutServiceInput[]
    createMany?: ZKProofVerificationCreateManyServiceInputEnvelope
    set?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    disconnect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    delete?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    update?: ZKProofVerificationUpdateWithWhereUniqueWithoutServiceInput | ZKProofVerificationUpdateWithWhereUniqueWithoutServiceInput[]
    updateMany?: ZKProofVerificationUpdateManyWithWhereWithoutServiceInput | ZKProofVerificationUpdateManyWithWhereWithoutServiceInput[]
    deleteMany?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
  }

  export type ContractCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput> | ContractCreateWithoutPlatformInput[] | ContractUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutPlatformInput | ContractCreateOrConnectWithoutPlatformInput[]
    createMany?: ContractCreateManyPlatformInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ServiceSubscriptionCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput> | ServiceSubscriptionCreateWithoutPlatformInput[] | ServiceSubscriptionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutPlatformInput | ServiceSubscriptionCreateOrConnectWithoutPlatformInput[]
    createMany?: ServiceSubscriptionCreateManyPlatformInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type PlatformAccessTokenCreateNestedManyWithoutPlatformInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput> | PlatformAccessTokenCreateWithoutPlatformInput[] | PlatformAccessTokenUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutPlatformInput | PlatformAccessTokenCreateOrConnectWithoutPlatformInput[]
    createMany?: PlatformAccessTokenCreateManyPlatformInputEnvelope
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
  }

  export type PlatformAccessCreateNestedManyWithoutPlatformInput = {
    create?: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput> | PlatformAccessCreateWithoutPlatformInput[] | PlatformAccessUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutPlatformInput | PlatformAccessCreateOrConnectWithoutPlatformInput[]
    createMany?: PlatformAccessCreateManyPlatformInputEnvelope
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
  }

  export type ContractUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput> | ContractCreateWithoutPlatformInput[] | ContractUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutPlatformInput | ContractCreateOrConnectWithoutPlatformInput[]
    createMany?: ContractCreateManyPlatformInputEnvelope
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
  }

  export type ServiceSubscriptionUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput> | ServiceSubscriptionCreateWithoutPlatformInput[] | ServiceSubscriptionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutPlatformInput | ServiceSubscriptionCreateOrConnectWithoutPlatformInput[]
    createMany?: ServiceSubscriptionCreateManyPlatformInputEnvelope
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
  }

  export type PlatformAccessTokenUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput> | PlatformAccessTokenCreateWithoutPlatformInput[] | PlatformAccessTokenUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutPlatformInput | PlatformAccessTokenCreateOrConnectWithoutPlatformInput[]
    createMany?: PlatformAccessTokenCreateManyPlatformInputEnvelope
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
  }

  export type PlatformAccessUncheckedCreateNestedManyWithoutPlatformInput = {
    create?: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput> | PlatformAccessCreateWithoutPlatformInput[] | PlatformAccessUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutPlatformInput | PlatformAccessCreateOrConnectWithoutPlatformInput[]
    createMany?: PlatformAccessCreateManyPlatformInputEnvelope
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
  }

  export type EnumPlatformTypeFieldUpdateOperationsInput = {
    set?: $Enums.PlatformType
  }

  export type EnumPermissionLevelFieldUpdateOperationsInput = {
    set?: $Enums.PermissionLevel
  }

  export type ContractUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput> | ContractCreateWithoutPlatformInput[] | ContractUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutPlatformInput | ContractCreateOrConnectWithoutPlatformInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutPlatformInput | ContractUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ContractCreateManyPlatformInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutPlatformInput | ContractUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutPlatformInput | ContractUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ServiceSubscriptionUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput> | ServiceSubscriptionCreateWithoutPlatformInput[] | ServiceSubscriptionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutPlatformInput | ServiceSubscriptionCreateOrConnectWithoutPlatformInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutPlatformInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ServiceSubscriptionCreateManyPlatformInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutPlatformInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutPlatformInput | ServiceSubscriptionUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type PlatformAccessTokenUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput> | PlatformAccessTokenCreateWithoutPlatformInput[] | PlatformAccessTokenUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutPlatformInput | PlatformAccessTokenCreateOrConnectWithoutPlatformInput[]
    upsert?: PlatformAccessTokenUpsertWithWhereUniqueWithoutPlatformInput | PlatformAccessTokenUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: PlatformAccessTokenCreateManyPlatformInputEnvelope
    set?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    disconnect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    delete?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    update?: PlatformAccessTokenUpdateWithWhereUniqueWithoutPlatformInput | PlatformAccessTokenUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: PlatformAccessTokenUpdateManyWithWhereWithoutPlatformInput | PlatformAccessTokenUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
  }

  export type PlatformAccessUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput> | PlatformAccessCreateWithoutPlatformInput[] | PlatformAccessUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutPlatformInput | PlatformAccessCreateOrConnectWithoutPlatformInput[]
    upsert?: PlatformAccessUpsertWithWhereUniqueWithoutPlatformInput | PlatformAccessUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: PlatformAccessCreateManyPlatformInputEnvelope
    set?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    disconnect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    delete?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    update?: PlatformAccessUpdateWithWhereUniqueWithoutPlatformInput | PlatformAccessUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: PlatformAccessUpdateManyWithWhereWithoutPlatformInput | PlatformAccessUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
  }

  export type ContractUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput> | ContractCreateWithoutPlatformInput[] | ContractUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ContractCreateOrConnectWithoutPlatformInput | ContractCreateOrConnectWithoutPlatformInput[]
    upsert?: ContractUpsertWithWhereUniqueWithoutPlatformInput | ContractUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ContractCreateManyPlatformInputEnvelope
    set?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    disconnect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    delete?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    connect?: ContractWhereUniqueInput | ContractWhereUniqueInput[]
    update?: ContractUpdateWithWhereUniqueWithoutPlatformInput | ContractUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ContractUpdateManyWithWhereWithoutPlatformInput | ContractUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ContractScalarWhereInput | ContractScalarWhereInput[]
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput> | ServiceSubscriptionCreateWithoutPlatformInput[] | ServiceSubscriptionUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: ServiceSubscriptionCreateOrConnectWithoutPlatformInput | ServiceSubscriptionCreateOrConnectWithoutPlatformInput[]
    upsert?: ServiceSubscriptionUpsertWithWhereUniqueWithoutPlatformInput | ServiceSubscriptionUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: ServiceSubscriptionCreateManyPlatformInputEnvelope
    set?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    disconnect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    delete?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    connect?: ServiceSubscriptionWhereUniqueInput | ServiceSubscriptionWhereUniqueInput[]
    update?: ServiceSubscriptionUpdateWithWhereUniqueWithoutPlatformInput | ServiceSubscriptionUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: ServiceSubscriptionUpdateManyWithWhereWithoutPlatformInput | ServiceSubscriptionUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
  }

  export type PlatformAccessTokenUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput> | PlatformAccessTokenCreateWithoutPlatformInput[] | PlatformAccessTokenUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessTokenCreateOrConnectWithoutPlatformInput | PlatformAccessTokenCreateOrConnectWithoutPlatformInput[]
    upsert?: PlatformAccessTokenUpsertWithWhereUniqueWithoutPlatformInput | PlatformAccessTokenUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: PlatformAccessTokenCreateManyPlatformInputEnvelope
    set?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    disconnect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    delete?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    connect?: PlatformAccessTokenWhereUniqueInput | PlatformAccessTokenWhereUniqueInput[]
    update?: PlatformAccessTokenUpdateWithWhereUniqueWithoutPlatformInput | PlatformAccessTokenUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: PlatformAccessTokenUpdateManyWithWhereWithoutPlatformInput | PlatformAccessTokenUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
  }

  export type PlatformAccessUncheckedUpdateManyWithoutPlatformNestedInput = {
    create?: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput> | PlatformAccessCreateWithoutPlatformInput[] | PlatformAccessUncheckedCreateWithoutPlatformInput[]
    connectOrCreate?: PlatformAccessCreateOrConnectWithoutPlatformInput | PlatformAccessCreateOrConnectWithoutPlatformInput[]
    upsert?: PlatformAccessUpsertWithWhereUniqueWithoutPlatformInput | PlatformAccessUpsertWithWhereUniqueWithoutPlatformInput[]
    createMany?: PlatformAccessCreateManyPlatformInputEnvelope
    set?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    disconnect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    delete?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    connect?: PlatformAccessWhereUniqueInput | PlatformAccessWhereUniqueInput[]
    update?: PlatformAccessUpdateWithWhereUniqueWithoutPlatformInput | PlatformAccessUpdateWithWhereUniqueWithoutPlatformInput[]
    updateMany?: PlatformAccessUpdateManyWithWhereWithoutPlatformInput | PlatformAccessUpdateManyWithWhereWithoutPlatformInput[]
    deleteMany?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
  }

  export type PlatformCreateNestedOneWithoutContractsInput = {
    create?: XOR<PlatformCreateWithoutContractsInput, PlatformUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutContractsInput
    connect?: PlatformWhereUniqueInput
  }

  export type ContractPermissionCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput> | ContractPermissionCreateWithoutContractInput[] | ContractPermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutContractInput | ContractPermissionCreateOrConnectWithoutContractInput[]
    createMany?: ContractPermissionCreateManyContractInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenCreateNestedManyWithoutContractInput = {
    create?: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput> | JWTTokenCreateWithoutContractInput[] | JWTTokenUncheckedCreateWithoutContractInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutContractInput | JWTTokenCreateOrConnectWithoutContractInput[]
    createMany?: JWTTokenCreateManyContractInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServicePermissionCreateNestedManyWithoutContractInput = {
    create?: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput> | ServicePermissionCreateWithoutContractInput[] | ServicePermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutContractInput | ServicePermissionCreateOrConnectWithoutContractInput[]
    createMany?: ServicePermissionCreateManyContractInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type AccessLogCreateNestedManyWithoutContractInput = {
    create?: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput> | AccessLogCreateWithoutContractInput[] | AccessLogUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutContractInput | AccessLogCreateOrConnectWithoutContractInput[]
    createMany?: AccessLogCreateManyContractInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ZKProofVerificationCreateNestedManyWithoutContractInput = {
    create?: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput> | ZKProofVerificationCreateWithoutContractInput[] | ZKProofVerificationUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutContractInput | ZKProofVerificationCreateOrConnectWithoutContractInput[]
    createMany?: ZKProofVerificationCreateManyContractInputEnvelope
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
  }

  export type ContractPermissionUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput> | ContractPermissionCreateWithoutContractInput[] | ContractPermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutContractInput | ContractPermissionCreateOrConnectWithoutContractInput[]
    createMany?: ContractPermissionCreateManyContractInputEnvelope
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
  }

  export type JWTTokenUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput> | JWTTokenCreateWithoutContractInput[] | JWTTokenUncheckedCreateWithoutContractInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutContractInput | JWTTokenCreateOrConnectWithoutContractInput[]
    createMany?: JWTTokenCreateManyContractInputEnvelope
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
  }

  export type ServicePermissionUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput> | ServicePermissionCreateWithoutContractInput[] | ServicePermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutContractInput | ServicePermissionCreateOrConnectWithoutContractInput[]
    createMany?: ServicePermissionCreateManyContractInputEnvelope
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
  }

  export type AccessLogUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput> | AccessLogCreateWithoutContractInput[] | AccessLogUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutContractInput | AccessLogCreateOrConnectWithoutContractInput[]
    createMany?: AccessLogCreateManyContractInputEnvelope
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
  }

  export type ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput = {
    create?: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput> | ZKProofVerificationCreateWithoutContractInput[] | ZKProofVerificationUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutContractInput | ZKProofVerificationCreateOrConnectWithoutContractInput[]
    createMany?: ZKProofVerificationCreateManyContractInputEnvelope
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
  }

  export type EnumComplianceStatusFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceStatus
  }

  export type PlatformUpdateOneRequiredWithoutContractsNestedInput = {
    create?: XOR<PlatformCreateWithoutContractsInput, PlatformUncheckedCreateWithoutContractsInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutContractsInput
    upsert?: PlatformUpsertWithoutContractsInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutContractsInput, PlatformUpdateWithoutContractsInput>, PlatformUncheckedUpdateWithoutContractsInput>
  }

  export type ContractPermissionUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput> | ContractPermissionCreateWithoutContractInput[] | ContractPermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutContractInput | ContractPermissionCreateOrConnectWithoutContractInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutContractInput | ContractPermissionUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractPermissionCreateManyContractInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutContractInput | ContractPermissionUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutContractInput | ContractPermissionUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUpdateManyWithoutContractNestedInput = {
    create?: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput> | JWTTokenCreateWithoutContractInput[] | JWTTokenUncheckedCreateWithoutContractInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutContractInput | JWTTokenCreateOrConnectWithoutContractInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutContractInput | JWTTokenUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: JWTTokenCreateManyContractInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutContractInput | JWTTokenUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutContractInput | JWTTokenUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServicePermissionUpdateManyWithoutContractNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput> | ServicePermissionCreateWithoutContractInput[] | ServicePermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutContractInput | ServicePermissionCreateOrConnectWithoutContractInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutContractInput | ServicePermissionUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ServicePermissionCreateManyContractInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutContractInput | ServicePermissionUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutContractInput | ServicePermissionUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type AccessLogUpdateManyWithoutContractNestedInput = {
    create?: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput> | AccessLogCreateWithoutContractInput[] | AccessLogUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutContractInput | AccessLogCreateOrConnectWithoutContractInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutContractInput | AccessLogUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AccessLogCreateManyContractInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutContractInput | AccessLogUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutContractInput | AccessLogUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ZKProofVerificationUpdateManyWithoutContractNestedInput = {
    create?: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput> | ZKProofVerificationCreateWithoutContractInput[] | ZKProofVerificationUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutContractInput | ZKProofVerificationCreateOrConnectWithoutContractInput[]
    upsert?: ZKProofVerificationUpsertWithWhereUniqueWithoutContractInput | ZKProofVerificationUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ZKProofVerificationCreateManyContractInputEnvelope
    set?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    disconnect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    delete?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    update?: ZKProofVerificationUpdateWithWhereUniqueWithoutContractInput | ZKProofVerificationUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ZKProofVerificationUpdateManyWithWhereWithoutContractInput | ZKProofVerificationUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
  }

  export type ContractPermissionUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput> | ContractPermissionCreateWithoutContractInput[] | ContractPermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutContractInput | ContractPermissionCreateOrConnectWithoutContractInput[]
    upsert?: ContractPermissionUpsertWithWhereUniqueWithoutContractInput | ContractPermissionUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ContractPermissionCreateManyContractInputEnvelope
    set?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    disconnect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    delete?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    connect?: ContractPermissionWhereUniqueInput | ContractPermissionWhereUniqueInput[]
    update?: ContractPermissionUpdateWithWhereUniqueWithoutContractInput | ContractPermissionUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ContractPermissionUpdateManyWithWhereWithoutContractInput | ContractPermissionUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
  }

  export type JWTTokenUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput> | JWTTokenCreateWithoutContractInput[] | JWTTokenUncheckedCreateWithoutContractInput[]
    connectOrCreate?: JWTTokenCreateOrConnectWithoutContractInput | JWTTokenCreateOrConnectWithoutContractInput[]
    upsert?: JWTTokenUpsertWithWhereUniqueWithoutContractInput | JWTTokenUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: JWTTokenCreateManyContractInputEnvelope
    set?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    disconnect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    delete?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    connect?: JWTTokenWhereUniqueInput | JWTTokenWhereUniqueInput[]
    update?: JWTTokenUpdateWithWhereUniqueWithoutContractInput | JWTTokenUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: JWTTokenUpdateManyWithWhereWithoutContractInput | JWTTokenUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
  }

  export type ServicePermissionUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput> | ServicePermissionCreateWithoutContractInput[] | ServicePermissionUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ServicePermissionCreateOrConnectWithoutContractInput | ServicePermissionCreateOrConnectWithoutContractInput[]
    upsert?: ServicePermissionUpsertWithWhereUniqueWithoutContractInput | ServicePermissionUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ServicePermissionCreateManyContractInputEnvelope
    set?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    disconnect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    delete?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    connect?: ServicePermissionWhereUniqueInput | ServicePermissionWhereUniqueInput[]
    update?: ServicePermissionUpdateWithWhereUniqueWithoutContractInput | ServicePermissionUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ServicePermissionUpdateManyWithWhereWithoutContractInput | ServicePermissionUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
  }

  export type AccessLogUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput> | AccessLogCreateWithoutContractInput[] | AccessLogUncheckedCreateWithoutContractInput[]
    connectOrCreate?: AccessLogCreateOrConnectWithoutContractInput | AccessLogCreateOrConnectWithoutContractInput[]
    upsert?: AccessLogUpsertWithWhereUniqueWithoutContractInput | AccessLogUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: AccessLogCreateManyContractInputEnvelope
    set?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    disconnect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    delete?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    connect?: AccessLogWhereUniqueInput | AccessLogWhereUniqueInput[]
    update?: AccessLogUpdateWithWhereUniqueWithoutContractInput | AccessLogUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: AccessLogUpdateManyWithWhereWithoutContractInput | AccessLogUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
  }

  export type ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput = {
    create?: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput> | ZKProofVerificationCreateWithoutContractInput[] | ZKProofVerificationUncheckedCreateWithoutContractInput[]
    connectOrCreate?: ZKProofVerificationCreateOrConnectWithoutContractInput | ZKProofVerificationCreateOrConnectWithoutContractInput[]
    upsert?: ZKProofVerificationUpsertWithWhereUniqueWithoutContractInput | ZKProofVerificationUpsertWithWhereUniqueWithoutContractInput[]
    createMany?: ZKProofVerificationCreateManyContractInputEnvelope
    set?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    disconnect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    delete?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    connect?: ZKProofVerificationWhereUniqueInput | ZKProofVerificationWhereUniqueInput[]
    update?: ZKProofVerificationUpdateWithWhereUniqueWithoutContractInput | ZKProofVerificationUpdateWithWhereUniqueWithoutContractInput[]
    updateMany?: ZKProofVerificationUpdateManyWithWhereWithoutContractInput | ZKProofVerificationUpdateManyWithWhereWithoutContractInput[]
    deleteMany?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
  }

  export type PlatformAccessCreategrantedServicesInput = {
    set: string[]
  }

  export type ProviderCreateNestedOneWithoutPlatformAccessInput = {
    create?: XOR<ProviderCreateWithoutPlatformAccessInput, ProviderUncheckedCreateWithoutPlatformAccessInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPlatformAccessInput
    connect?: ProviderWhereUniqueInput
  }

  export type PlatformCreateNestedOneWithoutPlatformAccessInput = {
    create?: XOR<PlatformCreateWithoutPlatformAccessInput, PlatformUncheckedCreateWithoutPlatformAccessInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformAccessInput
    connect?: PlatformWhereUniqueInput
  }

  export type PlatformAccessUpdategrantedServicesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumAccessTypeFieldUpdateOperationsInput = {
    set?: $Enums.AccessType
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProviderUpdateOneRequiredWithoutPlatformAccessNestedInput = {
    create?: XOR<ProviderCreateWithoutPlatformAccessInput, ProviderUncheckedCreateWithoutPlatformAccessInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPlatformAccessInput
    upsert?: ProviderUpsertWithoutPlatformAccessInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutPlatformAccessInput, ProviderUpdateWithoutPlatformAccessInput>, ProviderUncheckedUpdateWithoutPlatformAccessInput>
  }

  export type PlatformUpdateOneRequiredWithoutPlatformAccessNestedInput = {
    create?: XOR<PlatformCreateWithoutPlatformAccessInput, PlatformUncheckedCreateWithoutPlatformAccessInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformAccessInput
    upsert?: PlatformUpsertWithoutPlatformAccessInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutPlatformAccessInput, PlatformUpdateWithoutPlatformAccessInput>, PlatformUncheckedUpdateWithoutPlatformAccessInput>
  }

  export type ProviderCreateNestedOneWithoutContractPermissionsInput = {
    create?: XOR<ProviderCreateWithoutContractPermissionsInput, ProviderUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutContractPermissionsInput
    connect?: ProviderWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutContractPermissionsInput = {
    create?: XOR<ContractCreateWithoutContractPermissionsInput, ContractUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutContractPermissionsInput
    connect?: ContractWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutContractPermissionsInput = {
    create?: XOR<ServiceCreateWithoutContractPermissionsInput, ServiceUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutContractPermissionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type UsageQuotaCreateNestedOneWithoutContractPermissionInput = {
    create?: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
    connectOrCreate?: UsageQuotaCreateOrConnectWithoutContractPermissionInput
    connect?: UsageQuotaWhereUniqueInput
  }

  export type UsageQuotaUncheckedCreateNestedOneWithoutContractPermissionInput = {
    create?: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
    connectOrCreate?: UsageQuotaCreateOrConnectWithoutContractPermissionInput
    connect?: UsageQuotaWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutContractPermissionsNestedInput = {
    create?: XOR<ProviderCreateWithoutContractPermissionsInput, ProviderUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutContractPermissionsInput
    upsert?: ProviderUpsertWithoutContractPermissionsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutContractPermissionsInput, ProviderUpdateWithoutContractPermissionsInput>, ProviderUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type ContractUpdateOneRequiredWithoutContractPermissionsNestedInput = {
    create?: XOR<ContractCreateWithoutContractPermissionsInput, ContractUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutContractPermissionsInput
    upsert?: ContractUpsertWithoutContractPermissionsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutContractPermissionsInput, ContractUpdateWithoutContractPermissionsInput>, ContractUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type ServiceUpdateOneRequiredWithoutContractPermissionsNestedInput = {
    create?: XOR<ServiceCreateWithoutContractPermissionsInput, ServiceUncheckedCreateWithoutContractPermissionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutContractPermissionsInput
    upsert?: ServiceUpsertWithoutContractPermissionsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutContractPermissionsInput, ServiceUpdateWithoutContractPermissionsInput>, ServiceUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type UsageQuotaUpdateOneWithoutContractPermissionNestedInput = {
    create?: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
    connectOrCreate?: UsageQuotaCreateOrConnectWithoutContractPermissionInput
    upsert?: UsageQuotaUpsertWithoutContractPermissionInput
    disconnect?: UsageQuotaWhereInput | boolean
    delete?: UsageQuotaWhereInput | boolean
    connect?: UsageQuotaWhereUniqueInput
    update?: XOR<XOR<UsageQuotaUpdateToOneWithWhereWithoutContractPermissionInput, UsageQuotaUpdateWithoutContractPermissionInput>, UsageQuotaUncheckedUpdateWithoutContractPermissionInput>
  }

  export type UsageQuotaUncheckedUpdateOneWithoutContractPermissionNestedInput = {
    create?: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
    connectOrCreate?: UsageQuotaCreateOrConnectWithoutContractPermissionInput
    upsert?: UsageQuotaUpsertWithoutContractPermissionInput
    disconnect?: UsageQuotaWhereInput | boolean
    delete?: UsageQuotaWhereInput | boolean
    connect?: UsageQuotaWhereUniqueInput
    update?: XOR<XOR<UsageQuotaUpdateToOneWithWhereWithoutContractPermissionInput, UsageQuotaUpdateWithoutContractPermissionInput>, UsageQuotaUncheckedUpdateWithoutContractPermissionInput>
  }

  export type ProviderCreateNestedOneWithoutJwtTokensInput = {
    create?: XOR<ProviderCreateWithoutJwtTokensInput, ProviderUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutJwtTokensInput
    connect?: ProviderWhereUniqueInput
  }

  export type ContractCreateNestedOneWithoutJwtTokensInput = {
    create?: XOR<ContractCreateWithoutJwtTokensInput, ContractUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ContractCreateOrConnectWithoutJwtTokensInput
    connect?: ContractWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutJwtTokensInput = {
    create?: XOR<ServiceCreateWithoutJwtTokensInput, ServiceUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutJwtTokensInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProviderUpdateOneRequiredWithoutJwtTokensNestedInput = {
    create?: XOR<ProviderCreateWithoutJwtTokensInput, ProviderUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutJwtTokensInput
    upsert?: ProviderUpsertWithoutJwtTokensInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutJwtTokensInput, ProviderUpdateWithoutJwtTokensInput>, ProviderUncheckedUpdateWithoutJwtTokensInput>
  }

  export type ContractUpdateOneWithoutJwtTokensNestedInput = {
    create?: XOR<ContractCreateWithoutJwtTokensInput, ContractUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ContractCreateOrConnectWithoutJwtTokensInput
    upsert?: ContractUpsertWithoutJwtTokensInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutJwtTokensInput, ContractUpdateWithoutJwtTokensInput>, ContractUncheckedUpdateWithoutJwtTokensInput>
  }

  export type ServiceUpdateOneRequiredWithoutJwtTokensNestedInput = {
    create?: XOR<ServiceCreateWithoutJwtTokensInput, ServiceUncheckedCreateWithoutJwtTokensInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutJwtTokensInput
    upsert?: ServiceUpsertWithoutJwtTokensInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutJwtTokensInput, ServiceUpdateWithoutJwtTokensInput>, ServiceUncheckedUpdateWithoutJwtTokensInput>
  }

  export type PlatformCreateNestedOneWithoutServiceSubscriptionsInput = {
    create?: XOR<PlatformCreateWithoutServiceSubscriptionsInput, PlatformUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutServiceSubscriptionsInput
    connect?: PlatformWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutServiceSubscriptionsInput = {
    create?: XOR<ServiceCreateWithoutServiceSubscriptionsInput, ServiceUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSubscriptionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutServiceSubscriptionsInput = {
    create?: XOR<ProviderCreateWithoutServiceSubscriptionsInput, ProviderUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServiceSubscriptionsInput
    connect?: ProviderWhereUniqueInput
  }

  export type PlatformUpdateOneRequiredWithoutServiceSubscriptionsNestedInput = {
    create?: XOR<PlatformCreateWithoutServiceSubscriptionsInput, PlatformUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutServiceSubscriptionsInput
    upsert?: PlatformUpsertWithoutServiceSubscriptionsInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutServiceSubscriptionsInput, PlatformUpdateWithoutServiceSubscriptionsInput>, PlatformUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type ServiceUpdateOneRequiredWithoutServiceSubscriptionsNestedInput = {
    create?: XOR<ServiceCreateWithoutServiceSubscriptionsInput, ServiceUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServiceSubscriptionsInput
    upsert?: ServiceUpsertWithoutServiceSubscriptionsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServiceSubscriptionsInput, ServiceUpdateWithoutServiceSubscriptionsInput>, ServiceUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type ProviderUpdateOneRequiredWithoutServiceSubscriptionsNestedInput = {
    create?: XOR<ProviderCreateWithoutServiceSubscriptionsInput, ProviderUncheckedCreateWithoutServiceSubscriptionsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServiceSubscriptionsInput
    upsert?: ProviderUpsertWithoutServiceSubscriptionsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutServiceSubscriptionsInput, ProviderUpdateWithoutServiceSubscriptionsInput>, ProviderUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type PlatformAccessTokenCreateserviceIdsInput = {
    set: string[]
  }

  export type PlatformCreateNestedOneWithoutPlatformAccessTokensInput = {
    create?: XOR<PlatformCreateWithoutPlatformAccessTokensInput, PlatformUncheckedCreateWithoutPlatformAccessTokensInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformAccessTokensInput
    connect?: PlatformWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutPlatformAccessTokensInput = {
    create?: XOR<ProviderCreateWithoutPlatformAccessTokensInput, ProviderUncheckedCreateWithoutPlatformAccessTokensInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPlatformAccessTokensInput
    connect?: ProviderWhereUniqueInput
  }

  export type PlatformAccessTokenUpdateserviceIdsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type PlatformUpdateOneRequiredWithoutPlatformAccessTokensNestedInput = {
    create?: XOR<PlatformCreateWithoutPlatformAccessTokensInput, PlatformUncheckedCreateWithoutPlatformAccessTokensInput>
    connectOrCreate?: PlatformCreateOrConnectWithoutPlatformAccessTokensInput
    upsert?: PlatformUpsertWithoutPlatformAccessTokensInput
    connect?: PlatformWhereUniqueInput
    update?: XOR<XOR<PlatformUpdateToOneWithWhereWithoutPlatformAccessTokensInput, PlatformUpdateWithoutPlatformAccessTokensInput>, PlatformUncheckedUpdateWithoutPlatformAccessTokensInput>
  }

  export type ProviderUpdateOneRequiredWithoutPlatformAccessTokensNestedInput = {
    create?: XOR<ProviderCreateWithoutPlatformAccessTokensInput, ProviderUncheckedCreateWithoutPlatformAccessTokensInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutPlatformAccessTokensInput
    upsert?: ProviderUpsertWithoutPlatformAccessTokensInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutPlatformAccessTokensInput, ProviderUpdateWithoutPlatformAccessTokensInput>, ProviderUncheckedUpdateWithoutPlatformAccessTokensInput>
  }

  export type ContractCreateNestedOneWithoutServicePermissionsInput = {
    create?: XOR<ContractCreateWithoutServicePermissionsInput, ContractUncheckedCreateWithoutServicePermissionsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutServicePermissionsInput
    connect?: ContractWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutServicePermissionsInput = {
    create?: XOR<ServiceCreateWithoutServicePermissionsInput, ServiceUncheckedCreateWithoutServicePermissionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServicePermissionsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutServicePermissionInput = {
    create?: XOR<ProviderCreateWithoutServicePermissionInput, ProviderUncheckedCreateWithoutServicePermissionInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicePermissionInput
    connect?: ProviderWhereUniqueInput
  }

  export type ContractUpdateOneRequiredWithoutServicePermissionsNestedInput = {
    create?: XOR<ContractCreateWithoutServicePermissionsInput, ContractUncheckedCreateWithoutServicePermissionsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutServicePermissionsInput
    upsert?: ContractUpsertWithoutServicePermissionsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutServicePermissionsInput, ContractUpdateWithoutServicePermissionsInput>, ContractUncheckedUpdateWithoutServicePermissionsInput>
  }

  export type ServiceUpdateOneRequiredWithoutServicePermissionsNestedInput = {
    create?: XOR<ServiceCreateWithoutServicePermissionsInput, ServiceUncheckedCreateWithoutServicePermissionsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutServicePermissionsInput
    upsert?: ServiceUpsertWithoutServicePermissionsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutServicePermissionsInput, ServiceUpdateWithoutServicePermissionsInput>, ServiceUncheckedUpdateWithoutServicePermissionsInput>
  }

  export type ProviderUpdateOneRequiredWithoutServicePermissionNestedInput = {
    create?: XOR<ProviderCreateWithoutServicePermissionInput, ProviderUncheckedCreateWithoutServicePermissionInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutServicePermissionInput
    upsert?: ProviderUpsertWithoutServicePermissionInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutServicePermissionInput, ProviderUpdateWithoutServicePermissionInput>, ProviderUncheckedUpdateWithoutServicePermissionInput>
  }

  export type ContractCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<ContractCreateWithoutAccessLogsInput, ContractUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAccessLogsInput
    connect?: ContractWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<ServiceCreateWithoutAccessLogsInput, ServiceUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAccessLogsInput
    connect?: ServiceWhereUniqueInput
  }

  export type ProviderCreateNestedOneWithoutAccessLogsInput = {
    create?: XOR<ProviderCreateWithoutAccessLogsInput, ProviderUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAccessLogsInput
    connect?: ProviderWhereUniqueInput
  }

  export type ContractUpdateOneWithoutAccessLogsNestedInput = {
    create?: XOR<ContractCreateWithoutAccessLogsInput, ContractUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutAccessLogsInput
    upsert?: ContractUpsertWithoutAccessLogsInput
    disconnect?: ContractWhereInput | boolean
    delete?: ContractWhereInput | boolean
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutAccessLogsInput, ContractUpdateWithoutAccessLogsInput>, ContractUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ServiceUpdateOneRequiredWithoutAccessLogsNestedInput = {
    create?: XOR<ServiceCreateWithoutAccessLogsInput, ServiceUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutAccessLogsInput
    upsert?: ServiceUpsertWithoutAccessLogsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutAccessLogsInput, ServiceUpdateWithoutAccessLogsInput>, ServiceUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ProviderUpdateOneRequiredWithoutAccessLogsNestedInput = {
    create?: XOR<ProviderCreateWithoutAccessLogsInput, ProviderUncheckedCreateWithoutAccessLogsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutAccessLogsInput
    upsert?: ProviderUpsertWithoutAccessLogsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutAccessLogsInput, ProviderUpdateWithoutAccessLogsInput>, ProviderUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ContractPermissionCreateNestedOneWithoutUsageQuotaInput = {
    create?: XOR<ContractPermissionCreateWithoutUsageQuotaInput, ContractPermissionUncheckedCreateWithoutUsageQuotaInput>
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutUsageQuotaInput
    connect?: ContractPermissionWhereUniqueInput
  }

  export type ContractPermissionUpdateOneRequiredWithoutUsageQuotaNestedInput = {
    create?: XOR<ContractPermissionCreateWithoutUsageQuotaInput, ContractPermissionUncheckedCreateWithoutUsageQuotaInput>
    connectOrCreate?: ContractPermissionCreateOrConnectWithoutUsageQuotaInput
    upsert?: ContractPermissionUpsertWithoutUsageQuotaInput
    connect?: ContractPermissionWhereUniqueInput
    update?: XOR<XOR<ContractPermissionUpdateToOneWithWhereWithoutUsageQuotaInput, ContractPermissionUpdateWithoutUsageQuotaInput>, ContractPermissionUncheckedUpdateWithoutUsageQuotaInput>
  }

  export type ProviderCreateNestedOneWithoutComplianceAuditsInput = {
    create?: XOR<ProviderCreateWithoutComplianceAuditsInput, ProviderUncheckedCreateWithoutComplianceAuditsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutComplianceAuditsInput
    connect?: ProviderWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutComplianceAuditsInput = {
    create?: XOR<ServiceCreateWithoutComplianceAuditsInput, ServiceUncheckedCreateWithoutComplianceAuditsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutComplianceAuditsInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumComplianceFrameworkFieldUpdateOperationsInput = {
    set?: $Enums.ComplianceFramework
  }

  export type ProviderUpdateOneRequiredWithoutComplianceAuditsNestedInput = {
    create?: XOR<ProviderCreateWithoutComplianceAuditsInput, ProviderUncheckedCreateWithoutComplianceAuditsInput>
    connectOrCreate?: ProviderCreateOrConnectWithoutComplianceAuditsInput
    upsert?: ProviderUpsertWithoutComplianceAuditsInput
    connect?: ProviderWhereUniqueInput
    update?: XOR<XOR<ProviderUpdateToOneWithWhereWithoutComplianceAuditsInput, ProviderUpdateWithoutComplianceAuditsInput>, ProviderUncheckedUpdateWithoutComplianceAuditsInput>
  }

  export type ServiceUpdateOneWithoutComplianceAuditsNestedInput = {
    create?: XOR<ServiceCreateWithoutComplianceAuditsInput, ServiceUncheckedCreateWithoutComplianceAuditsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutComplianceAuditsInput
    upsert?: ServiceUpsertWithoutComplianceAuditsInput
    disconnect?: ServiceWhereInput | boolean
    delete?: ServiceWhereInput | boolean
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutComplianceAuditsInput, ServiceUpdateWithoutComplianceAuditsInput>, ServiceUncheckedUpdateWithoutComplianceAuditsInput>
  }

  export type ContractCreateNestedOneWithoutZkProofVerificationsInput = {
    create?: XOR<ContractCreateWithoutZkProofVerificationsInput, ContractUncheckedCreateWithoutZkProofVerificationsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutZkProofVerificationsInput
    connect?: ContractWhereUniqueInput
  }

  export type ServiceCreateNestedOneWithoutZkProofVerificationsInput = {
    create?: XOR<ServiceCreateWithoutZkProofVerificationsInput, ServiceUncheckedCreateWithoutZkProofVerificationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutZkProofVerificationsInput
    connect?: ServiceWhereUniqueInput
  }

  export type EnumZKProofTypeFieldUpdateOperationsInput = {
    set?: $Enums.ZKProofType
  }

  export type ContractUpdateOneRequiredWithoutZkProofVerificationsNestedInput = {
    create?: XOR<ContractCreateWithoutZkProofVerificationsInput, ContractUncheckedCreateWithoutZkProofVerificationsInput>
    connectOrCreate?: ContractCreateOrConnectWithoutZkProofVerificationsInput
    upsert?: ContractUpsertWithoutZkProofVerificationsInput
    connect?: ContractWhereUniqueInput
    update?: XOR<XOR<ContractUpdateToOneWithWhereWithoutZkProofVerificationsInput, ContractUpdateWithoutZkProofVerificationsInput>, ContractUncheckedUpdateWithoutZkProofVerificationsInput>
  }

  export type ServiceUpdateOneRequiredWithoutZkProofVerificationsNestedInput = {
    create?: XOR<ServiceCreateWithoutZkProofVerificationsInput, ServiceUncheckedCreateWithoutZkProofVerificationsInput>
    connectOrCreate?: ServiceCreateOrConnectWithoutZkProofVerificationsInput
    upsert?: ServiceUpsertWithoutZkProofVerificationsInput
    connect?: ServiceWhereUniqueInput
    update?: XOR<XOR<ServiceUpdateToOneWithWhereWithoutZkProofVerificationsInput, ServiceUpdateWithoutZkProofVerificationsInput>, ServiceUncheckedUpdateWithoutZkProofVerificationsInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeFilter<$PrismaModel> | $Enums.ServiceType
  }

  export type NestedEnumRWATypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RWAType | EnumRWATypeFieldRefInput<$PrismaModel>
    in?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRWATypeFilter<$PrismaModel> | $Enums.RWAType
  }

  export type NestedEnumVerificationLayerFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationLayer | EnumVerificationLayerFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationLayerFilter<$PrismaModel> | $Enums.VerificationLayer
  }

  export type NestedEnumInteractionLayerFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionLayer | EnumInteractionLayerFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionLayerFilter<$PrismaModel> | $Enums.InteractionLayer
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumServiceVerificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceVerificationType | EnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceVerificationTypeFilter<$PrismaModel> | $Enums.ServiceVerificationType
  }

  export type NestedEnumAuthMethodFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthMethodFilter<$PrismaModel> | $Enums.AuthMethod
  }

  export type NestedEnumPrivacyLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PrivacyLevel | EnumPrivacyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyLevelFilter<$PrismaModel> | $Enums.PrivacyLevel
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceType | EnumServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceType[] | ListEnumServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumRWATypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RWAType | EnumRWATypeFieldRefInput<$PrismaModel>
    in?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RWAType[] | ListEnumRWATypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRWATypeWithAggregatesFilter<$PrismaModel> | $Enums.RWAType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRWATypeFilter<$PrismaModel>
    _max?: NestedEnumRWATypeFilter<$PrismaModel>
  }

  export type NestedEnumVerificationLayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.VerificationLayer | EnumVerificationLayerFieldRefInput<$PrismaModel>
    in?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.VerificationLayer[] | ListEnumVerificationLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumVerificationLayerWithAggregatesFilter<$PrismaModel> | $Enums.VerificationLayer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumVerificationLayerFilter<$PrismaModel>
    _max?: NestedEnumVerificationLayerFilter<$PrismaModel>
  }

  export type NestedEnumInteractionLayerWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InteractionLayer | EnumInteractionLayerFieldRefInput<$PrismaModel>
    in?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    notIn?: $Enums.InteractionLayer[] | ListEnumInteractionLayerFieldRefInput<$PrismaModel>
    not?: NestedEnumInteractionLayerWithAggregatesFilter<$PrismaModel> | $Enums.InteractionLayer
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInteractionLayerFilter<$PrismaModel>
    _max?: NestedEnumInteractionLayerFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumServiceVerificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceVerificationType | EnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceVerificationType[] | ListEnumServiceVerificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceVerificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.ServiceVerificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceVerificationTypeFilter<$PrismaModel>
    _max?: NestedEnumServiceVerificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AuthMethod | EnumAuthMethodFieldRefInput<$PrismaModel>
    in?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    notIn?: $Enums.AuthMethod[] | ListEnumAuthMethodFieldRefInput<$PrismaModel>
    not?: NestedEnumAuthMethodWithAggregatesFilter<$PrismaModel> | $Enums.AuthMethod
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAuthMethodFilter<$PrismaModel>
    _max?: NestedEnumAuthMethodFilter<$PrismaModel>
  }

  export type NestedEnumPrivacyLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PrivacyLevel | EnumPrivacyLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PrivacyLevel[] | ListEnumPrivacyLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPrivacyLevelWithAggregatesFilter<$PrismaModel> | $Enums.PrivacyLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPrivacyLevelFilter<$PrismaModel>
    _max?: NestedEnumPrivacyLevelFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumProofOfServiceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ProofOfServiceType | EnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProofOfServiceTypeFilter<$PrismaModel> | $Enums.ProofOfServiceType
  }

  export type NestedEnumServiceCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryFilter<$PrismaModel> | $Enums.ServiceCategory
  }

  export type NestedEnumAccessLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelFilter<$PrismaModel> | $Enums.AccessLevel
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumProofOfServiceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProofOfServiceType | EnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProofOfServiceType[] | ListEnumProofOfServiceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumProofOfServiceTypeWithAggregatesFilter<$PrismaModel> | $Enums.ProofOfServiceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProofOfServiceTypeFilter<$PrismaModel>
    _max?: NestedEnumProofOfServiceTypeFilter<$PrismaModel>
  }

  export type NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ServiceCategory | EnumServiceCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ServiceCategory[] | ListEnumServiceCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumServiceCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ServiceCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumServiceCategoryFilter<$PrismaModel>
    _max?: NestedEnumServiceCategoryFilter<$PrismaModel>
  }

  export type NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessLevel | EnumAccessLevelFieldRefInput<$PrismaModel>
    in?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessLevel[] | ListEnumAccessLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessLevelWithAggregatesFilter<$PrismaModel> | $Enums.AccessLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessLevelFilter<$PrismaModel>
    _max?: NestedEnumAccessLevelFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumPlatformTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeFilter<$PrismaModel> | $Enums.PlatformType
  }

  export type NestedEnumPermissionLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelFilter<$PrismaModel> | $Enums.PermissionLevel
  }

  export type NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PlatformType | EnumPlatformTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PlatformType[] | ListEnumPlatformTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPlatformTypeWithAggregatesFilter<$PrismaModel> | $Enums.PlatformType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPlatformTypeFilter<$PrismaModel>
    _max?: NestedEnumPlatformTypeFilter<$PrismaModel>
  }

  export type NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PermissionLevel | EnumPermissionLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PermissionLevel[] | ListEnumPermissionLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPermissionLevelWithAggregatesFilter<$PrismaModel> | $Enums.PermissionLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPermissionLevelFilter<$PrismaModel>
    _max?: NestedEnumPermissionLevelFilter<$PrismaModel>
  }

  export type NestedEnumComplianceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusFilter<$PrismaModel> | $Enums.ComplianceStatus
  }

  export type NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceStatus | EnumComplianceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceStatus[] | ListEnumComplianceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceStatusWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceStatusFilter<$PrismaModel>
    _max?: NestedEnumComplianceStatusFilter<$PrismaModel>
  }

  export type NestedEnumAccessTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeFilter<$PrismaModel> | $Enums.AccessType
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AccessType | EnumAccessTypeFieldRefInput<$PrismaModel>
    in?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.AccessType[] | ListEnumAccessTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumAccessTypeWithAggregatesFilter<$PrismaModel> | $Enums.AccessType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAccessTypeFilter<$PrismaModel>
    _max?: NestedEnumAccessTypeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumComplianceFrameworkFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceFramework | EnumComplianceFrameworkFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceFrameworkFilter<$PrismaModel> | $Enums.ComplianceFramework
  }

  export type NestedEnumComplianceFrameworkWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ComplianceFramework | EnumComplianceFrameworkFieldRefInput<$PrismaModel>
    in?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    notIn?: $Enums.ComplianceFramework[] | ListEnumComplianceFrameworkFieldRefInput<$PrismaModel>
    not?: NestedEnumComplianceFrameworkWithAggregatesFilter<$PrismaModel> | $Enums.ComplianceFramework
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumComplianceFrameworkFilter<$PrismaModel>
    _max?: NestedEnumComplianceFrameworkFilter<$PrismaModel>
  }

  export type NestedEnumZKProofTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ZKProofType | EnumZKProofTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZKProofTypeFilter<$PrismaModel> | $Enums.ZKProofType
  }

  export type NestedEnumZKProofTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ZKProofType | EnumZKProofTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ZKProofType[] | ListEnumZKProofTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumZKProofTypeWithAggregatesFilter<$PrismaModel> | $Enums.ZKProofType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumZKProofTypeFilter<$PrismaModel>
    _max?: NestedEnumZKProofTypeFilter<$PrismaModel>
  }

  export type ServiceCreateWithoutProviderInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutProviderInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceCreateManyProviderInputEnvelope = {
    data: ServiceCreateManyProviderInput | ServiceCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type PlatformAccessCreateWithoutProviderInput = {
    id?: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutPlatformAccessInput
  }

  export type PlatformAccessUncheckedCreateWithoutProviderInput = {
    id?: string
    platformId: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAccessCreateOrConnectWithoutProviderInput = {
    where: PlatformAccessWhereUniqueInput
    create: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput>
  }

  export type PlatformAccessCreateManyProviderInputEnvelope = {
    data: PlatformAccessCreateManyProviderInput | PlatformAccessCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ContractPermissionCreateWithoutProviderInput = {
    id?: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    contract: ContractCreateNestedOneWithoutContractPermissionsInput
    service: ServiceCreateNestedOneWithoutContractPermissionsInput
    usageQuota?: UsageQuotaCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionUncheckedCreateWithoutProviderInput = {
    id?: string
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    usageQuota?: UsageQuotaUncheckedCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionCreateOrConnectWithoutProviderInput = {
    where: ContractPermissionWhereUniqueInput
    create: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput>
  }

  export type ContractPermissionCreateManyProviderInputEnvelope = {
    data: ContractPermissionCreateManyProviderInput | ContractPermissionCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type JWTTokenCreateWithoutProviderInput = {
    id?: string
    token: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
    contract?: ContractCreateNestedOneWithoutJwtTokensInput
    service: ServiceCreateNestedOneWithoutJwtTokensInput
  }

  export type JWTTokenUncheckedCreateWithoutProviderInput = {
    id?: string
    token: string
    contractId?: string | null
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type JWTTokenCreateOrConnectWithoutProviderInput = {
    where: JWTTokenWhereUniqueInput
    create: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput>
  }

  export type JWTTokenCreateManyProviderInputEnvelope = {
    data: JWTTokenCreateManyProviderInput | JWTTokenCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSubscriptionCreateWithoutProviderInput = {
    id?: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    platform: PlatformCreateNestedOneWithoutServiceSubscriptionsInput
    service: ServiceCreateNestedOneWithoutServiceSubscriptionsInput
  }

  export type ServiceSubscriptionUncheckedCreateWithoutProviderInput = {
    id?: string
    platformId: string
    serviceId: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServiceSubscriptionCreateOrConnectWithoutProviderInput = {
    where: ServiceSubscriptionWhereUniqueInput
    create: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput>
  }

  export type ServiceSubscriptionCreateManyProviderInputEnvelope = {
    data: ServiceSubscriptionCreateManyProviderInput | ServiceSubscriptionCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type PlatformAccessTokenCreateWithoutProviderInput = {
    id?: string
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    platform: PlatformCreateNestedOneWithoutPlatformAccessTokensInput
  }

  export type PlatformAccessTokenUncheckedCreateWithoutProviderInput = {
    id?: string
    platformId: string
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type PlatformAccessTokenCreateOrConnectWithoutProviderInput = {
    where: PlatformAccessTokenWhereUniqueInput
    create: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput>
  }

  export type PlatformAccessTokenCreateManyProviderInputEnvelope = {
    data: PlatformAccessTokenCreateManyProviderInput | PlatformAccessTokenCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceAuditCreateWithoutProviderInput = {
    id?: string
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
    service?: ServiceCreateNestedOneWithoutComplianceAuditsInput
  }

  export type ComplianceAuditUncheckedCreateWithoutProviderInput = {
    id?: string
    serviceId?: string | null
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type ComplianceAuditCreateOrConnectWithoutProviderInput = {
    where: ComplianceAuditWhereUniqueInput
    create: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput>
  }

  export type ComplianceAuditCreateManyProviderInputEnvelope = {
    data: ComplianceAuditCreateManyProviderInput | ComplianceAuditCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type AccessLogCreateWithoutProviderInput = {
    id?: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    contract?: ContractCreateNestedOneWithoutAccessLogsInput
    service: ServiceCreateNestedOneWithoutAccessLogsInput
  }

  export type AccessLogUncheckedCreateWithoutProviderInput = {
    id?: string
    contractId?: string | null
    serviceId: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AccessLogCreateOrConnectWithoutProviderInput = {
    where: AccessLogWhereUniqueInput
    create: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput>
  }

  export type AccessLogCreateManyProviderInputEnvelope = {
    data: AccessLogCreateManyProviderInput | AccessLogCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServicePermissionCreateWithoutProviderInput = {
    id?: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutServicePermissionsInput
    service: ServiceCreateNestedOneWithoutServicePermissionsInput
  }

  export type ServicePermissionUncheckedCreateWithoutProviderInput = {
    id?: string
    contractId: string
    serviceId: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePermissionCreateOrConnectWithoutProviderInput = {
    where: ServicePermissionWhereUniqueInput
    create: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput>
  }

  export type ServicePermissionCreateManyProviderInputEnvelope = {
    data: ServicePermissionCreateManyProviderInput | ServicePermissionCreateManyProviderInput[]
    skipDuplicates?: boolean
  }

  export type ServiceUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    update: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
    create: XOR<ServiceCreateWithoutProviderInput, ServiceUncheckedCreateWithoutProviderInput>
  }

  export type ServiceUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServiceWhereUniqueInput
    data: XOR<ServiceUpdateWithoutProviderInput, ServiceUncheckedUpdateWithoutProviderInput>
  }

  export type ServiceUpdateManyWithWhereWithoutProviderInput = {
    where: ServiceScalarWhereInput
    data: XOR<ServiceUpdateManyMutationInput, ServiceUncheckedUpdateManyWithoutProviderInput>
  }

  export type ServiceScalarWhereInput = {
    AND?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    OR?: ServiceScalarWhereInput[]
    NOT?: ServiceScalarWhereInput | ServiceScalarWhereInput[]
    id?: StringFilter<"Service"> | string
    providerId?: IntFilter<"Service"> | number
    name?: StringFilter<"Service"> | string
    description?: StringNullableFilter<"Service"> | string | null
    endpoint?: StringFilter<"Service"> | string
    proofOfService?: EnumProofOfServiceTypeFilter<"Service"> | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFilter<"Service"> | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFilter<"Service"> | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFilter<"Service"> | $Enums.AccessLevel
    rateLimits?: JsonFilter<"Service">
    zkRequirements?: JsonFilter<"Service">
    complianceChecks?: JsonFilter<"Service">
    isActive?: BoolFilter<"Service"> | boolean
    createdAt?: DateTimeFilter<"Service"> | Date | string
    updatedAt?: DateTimeFilter<"Service"> | Date | string
  }

  export type PlatformAccessUpsertWithWhereUniqueWithoutProviderInput = {
    where: PlatformAccessWhereUniqueInput
    update: XOR<PlatformAccessUpdateWithoutProviderInput, PlatformAccessUncheckedUpdateWithoutProviderInput>
    create: XOR<PlatformAccessCreateWithoutProviderInput, PlatformAccessUncheckedCreateWithoutProviderInput>
  }

  export type PlatformAccessUpdateWithWhereUniqueWithoutProviderInput = {
    where: PlatformAccessWhereUniqueInput
    data: XOR<PlatformAccessUpdateWithoutProviderInput, PlatformAccessUncheckedUpdateWithoutProviderInput>
  }

  export type PlatformAccessUpdateManyWithWhereWithoutProviderInput = {
    where: PlatformAccessScalarWhereInput
    data: XOR<PlatformAccessUpdateManyMutationInput, PlatformAccessUncheckedUpdateManyWithoutProviderInput>
  }

  export type PlatformAccessScalarWhereInput = {
    AND?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
    OR?: PlatformAccessScalarWhereInput[]
    NOT?: PlatformAccessScalarWhereInput | PlatformAccessScalarWhereInput[]
    id?: StringFilter<"PlatformAccess"> | string
    providerId?: IntFilter<"PlatformAccess"> | number
    platformId?: StringFilter<"PlatformAccess"> | string
    grantedServices?: StringNullableListFilter<"PlatformAccess">
    accessType?: EnumAccessTypeFilter<"PlatformAccess"> | $Enums.AccessType
    permissions?: JsonFilter<"PlatformAccess">
    expiresAt?: DateTimeNullableFilter<"PlatformAccess"> | Date | string | null
    isActive?: BoolFilter<"PlatformAccess"> | boolean
    createdAt?: DateTimeFilter<"PlatformAccess"> | Date | string
    updatedAt?: DateTimeFilter<"PlatformAccess"> | Date | string
  }

  export type ContractPermissionUpsertWithWhereUniqueWithoutProviderInput = {
    where: ContractPermissionWhereUniqueInput
    update: XOR<ContractPermissionUpdateWithoutProviderInput, ContractPermissionUncheckedUpdateWithoutProviderInput>
    create: XOR<ContractPermissionCreateWithoutProviderInput, ContractPermissionUncheckedCreateWithoutProviderInput>
  }

  export type ContractPermissionUpdateWithWhereUniqueWithoutProviderInput = {
    where: ContractPermissionWhereUniqueInput
    data: XOR<ContractPermissionUpdateWithoutProviderInput, ContractPermissionUncheckedUpdateWithoutProviderInput>
  }

  export type ContractPermissionUpdateManyWithWhereWithoutProviderInput = {
    where: ContractPermissionScalarWhereInput
    data: XOR<ContractPermissionUpdateManyMutationInput, ContractPermissionUncheckedUpdateManyWithoutProviderInput>
  }

  export type ContractPermissionScalarWhereInput = {
    AND?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
    OR?: ContractPermissionScalarWhereInput[]
    NOT?: ContractPermissionScalarWhereInput | ContractPermissionScalarWhereInput[]
    id?: StringFilter<"ContractPermission"> | string
    providerId?: IntFilter<"ContractPermission"> | number
    contractId?: StringFilter<"ContractPermission"> | string
    serviceId?: StringFilter<"ContractPermission"> | string
    jwtToken?: StringFilter<"ContractPermission"> | string
    permissions?: JsonFilter<"ContractPermission">
    grantedAt?: DateTimeFilter<"ContractPermission"> | Date | string
    expiresAt?: DateTimeFilter<"ContractPermission"> | Date | string
    isActive?: BoolFilter<"ContractPermission"> | boolean
  }

  export type JWTTokenUpsertWithWhereUniqueWithoutProviderInput = {
    where: JWTTokenWhereUniqueInput
    update: XOR<JWTTokenUpdateWithoutProviderInput, JWTTokenUncheckedUpdateWithoutProviderInput>
    create: XOR<JWTTokenCreateWithoutProviderInput, JWTTokenUncheckedCreateWithoutProviderInput>
  }

  export type JWTTokenUpdateWithWhereUniqueWithoutProviderInput = {
    where: JWTTokenWhereUniqueInput
    data: XOR<JWTTokenUpdateWithoutProviderInput, JWTTokenUncheckedUpdateWithoutProviderInput>
  }

  export type JWTTokenUpdateManyWithWhereWithoutProviderInput = {
    where: JWTTokenScalarWhereInput
    data: XOR<JWTTokenUpdateManyMutationInput, JWTTokenUncheckedUpdateManyWithoutProviderInput>
  }

  export type JWTTokenScalarWhereInput = {
    AND?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
    OR?: JWTTokenScalarWhereInput[]
    NOT?: JWTTokenScalarWhereInput | JWTTokenScalarWhereInput[]
    id?: StringFilter<"JWTToken"> | string
    token?: StringFilter<"JWTToken"> | string
    providerId?: IntFilter<"JWTToken"> | number
    contractId?: StringNullableFilter<"JWTToken"> | string | null
    serviceId?: StringFilter<"JWTToken"> | string
    permissions?: JsonFilter<"JWTToken">
    zkProofHash?: StringNullableFilter<"JWTToken"> | string | null
    issuedAt?: DateTimeFilter<"JWTToken"> | Date | string
    expiresAt?: DateTimeFilter<"JWTToken"> | Date | string
    isRevoked?: BoolFilter<"JWTToken"> | boolean
  }

  export type ServiceSubscriptionUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServiceSubscriptionWhereUniqueInput
    update: XOR<ServiceSubscriptionUpdateWithoutProviderInput, ServiceSubscriptionUncheckedUpdateWithoutProviderInput>
    create: XOR<ServiceSubscriptionCreateWithoutProviderInput, ServiceSubscriptionUncheckedCreateWithoutProviderInput>
  }

  export type ServiceSubscriptionUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServiceSubscriptionWhereUniqueInput
    data: XOR<ServiceSubscriptionUpdateWithoutProviderInput, ServiceSubscriptionUncheckedUpdateWithoutProviderInput>
  }

  export type ServiceSubscriptionUpdateManyWithWhereWithoutProviderInput = {
    where: ServiceSubscriptionScalarWhereInput
    data: XOR<ServiceSubscriptionUpdateManyMutationInput, ServiceSubscriptionUncheckedUpdateManyWithoutProviderInput>
  }

  export type ServiceSubscriptionScalarWhereInput = {
    AND?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
    OR?: ServiceSubscriptionScalarWhereInput[]
    NOT?: ServiceSubscriptionScalarWhereInput | ServiceSubscriptionScalarWhereInput[]
    id?: StringFilter<"ServiceSubscription"> | string
    platformId?: StringFilter<"ServiceSubscription"> | string
    serviceId?: StringFilter<"ServiceSubscription"> | string
    providerId?: IntFilter<"ServiceSubscription"> | number
    accessLevel?: EnumAccessLevelFilter<"ServiceSubscription"> | $Enums.AccessLevel
    contractAccess?: JsonFilter<"ServiceSubscription">
    subscribedAt?: DateTimeFilter<"ServiceSubscription"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ServiceSubscription"> | Date | string | null
    isActive?: BoolFilter<"ServiceSubscription"> | boolean
  }

  export type PlatformAccessTokenUpsertWithWhereUniqueWithoutProviderInput = {
    where: PlatformAccessTokenWhereUniqueInput
    update: XOR<PlatformAccessTokenUpdateWithoutProviderInput, PlatformAccessTokenUncheckedUpdateWithoutProviderInput>
    create: XOR<PlatformAccessTokenCreateWithoutProviderInput, PlatformAccessTokenUncheckedCreateWithoutProviderInput>
  }

  export type PlatformAccessTokenUpdateWithWhereUniqueWithoutProviderInput = {
    where: PlatformAccessTokenWhereUniqueInput
    data: XOR<PlatformAccessTokenUpdateWithoutProviderInput, PlatformAccessTokenUncheckedUpdateWithoutProviderInput>
  }

  export type PlatformAccessTokenUpdateManyWithWhereWithoutProviderInput = {
    where: PlatformAccessTokenScalarWhereInput
    data: XOR<PlatformAccessTokenUpdateManyMutationInput, PlatformAccessTokenUncheckedUpdateManyWithoutProviderInput>
  }

  export type PlatformAccessTokenScalarWhereInput = {
    AND?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
    OR?: PlatformAccessTokenScalarWhereInput[]
    NOT?: PlatformAccessTokenScalarWhereInput | PlatformAccessTokenScalarWhereInput[]
    id?: StringFilter<"PlatformAccessToken"> | string
    platformId?: StringFilter<"PlatformAccessToken"> | string
    providerId?: IntFilter<"PlatformAccessToken"> | number
    token?: StringFilter<"PlatformAccessToken"> | string
    serviceIds?: StringNullableListFilter<"PlatformAccessToken">
    permissions?: JsonFilter<"PlatformAccessToken">
    zkProofRequired?: BoolFilter<"PlatformAccessToken"> | boolean
    issuedAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    expiresAt?: DateTimeFilter<"PlatformAccessToken"> | Date | string
    isActive?: BoolFilter<"PlatformAccessToken"> | boolean
  }

  export type ComplianceAuditUpsertWithWhereUniqueWithoutProviderInput = {
    where: ComplianceAuditWhereUniqueInput
    update: XOR<ComplianceAuditUpdateWithoutProviderInput, ComplianceAuditUncheckedUpdateWithoutProviderInput>
    create: XOR<ComplianceAuditCreateWithoutProviderInput, ComplianceAuditUncheckedCreateWithoutProviderInput>
  }

  export type ComplianceAuditUpdateWithWhereUniqueWithoutProviderInput = {
    where: ComplianceAuditWhereUniqueInput
    data: XOR<ComplianceAuditUpdateWithoutProviderInput, ComplianceAuditUncheckedUpdateWithoutProviderInput>
  }

  export type ComplianceAuditUpdateManyWithWhereWithoutProviderInput = {
    where: ComplianceAuditScalarWhereInput
    data: XOR<ComplianceAuditUpdateManyMutationInput, ComplianceAuditUncheckedUpdateManyWithoutProviderInput>
  }

  export type ComplianceAuditScalarWhereInput = {
    AND?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
    OR?: ComplianceAuditScalarWhereInput[]
    NOT?: ComplianceAuditScalarWhereInput | ComplianceAuditScalarWhereInput[]
    id?: StringFilter<"ComplianceAudit"> | string
    providerId?: IntFilter<"ComplianceAudit"> | number
    serviceId?: StringNullableFilter<"ComplianceAudit"> | string | null
    framework?: EnumComplianceFrameworkFilter<"ComplianceAudit"> | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFilter<"ComplianceAudit"> | $Enums.ComplianceStatus
    auditData?: JsonFilter<"ComplianceAudit">
    auditDate?: DateTimeFilter<"ComplianceAudit"> | Date | string
    expiresAt?: DateTimeNullableFilter<"ComplianceAudit"> | Date | string | null
  }

  export type AccessLogUpsertWithWhereUniqueWithoutProviderInput = {
    where: AccessLogWhereUniqueInput
    update: XOR<AccessLogUpdateWithoutProviderInput, AccessLogUncheckedUpdateWithoutProviderInput>
    create: XOR<AccessLogCreateWithoutProviderInput, AccessLogUncheckedCreateWithoutProviderInput>
  }

  export type AccessLogUpdateWithWhereUniqueWithoutProviderInput = {
    where: AccessLogWhereUniqueInput
    data: XOR<AccessLogUpdateWithoutProviderInput, AccessLogUncheckedUpdateWithoutProviderInput>
  }

  export type AccessLogUpdateManyWithWhereWithoutProviderInput = {
    where: AccessLogScalarWhereInput
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyWithoutProviderInput>
  }

  export type AccessLogScalarWhereInput = {
    AND?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
    OR?: AccessLogScalarWhereInput[]
    NOT?: AccessLogScalarWhereInput | AccessLogScalarWhereInput[]
    id?: StringFilter<"AccessLog"> | string
    contractId?: StringNullableFilter<"AccessLog"> | string | null
    serviceId?: StringFilter<"AccessLog"> | string
    providerId?: IntFilter<"AccessLog"> | number
    action?: StringFilter<"AccessLog"> | string
    zkProofHash?: StringNullableFilter<"AccessLog"> | string | null
    metadata?: JsonNullableFilter<"AccessLog">
    timestamp?: DateTimeFilter<"AccessLog"> | Date | string
  }

  export type ServicePermissionUpsertWithWhereUniqueWithoutProviderInput = {
    where: ServicePermissionWhereUniqueInput
    update: XOR<ServicePermissionUpdateWithoutProviderInput, ServicePermissionUncheckedUpdateWithoutProviderInput>
    create: XOR<ServicePermissionCreateWithoutProviderInput, ServicePermissionUncheckedCreateWithoutProviderInput>
  }

  export type ServicePermissionUpdateWithWhereUniqueWithoutProviderInput = {
    where: ServicePermissionWhereUniqueInput
    data: XOR<ServicePermissionUpdateWithoutProviderInput, ServicePermissionUncheckedUpdateWithoutProviderInput>
  }

  export type ServicePermissionUpdateManyWithWhereWithoutProviderInput = {
    where: ServicePermissionScalarWhereInput
    data: XOR<ServicePermissionUpdateManyMutationInput, ServicePermissionUncheckedUpdateManyWithoutProviderInput>
  }

  export type ServicePermissionScalarWhereInput = {
    AND?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
    OR?: ServicePermissionScalarWhereInput[]
    NOT?: ServicePermissionScalarWhereInput | ServicePermissionScalarWhereInput[]
    id?: StringFilter<"ServicePermission"> | string
    contractId?: StringFilter<"ServicePermission"> | string
    serviceId?: StringFilter<"ServicePermission"> | string
    providerId?: IntFilter<"ServicePermission"> | number
    accessGranted?: BoolFilter<"ServicePermission"> | boolean
    jwtToken?: StringNullableFilter<"ServicePermission"> | string | null
    grantedAt?: DateTimeFilter<"ServicePermission"> | Date | string
    updatedAt?: DateTimeFilter<"ServicePermission"> | Date | string
  }

  export type ProviderCreateWithoutServicesInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutServicesInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutServicesInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
  }

  export type ContractPermissionCreateWithoutServiceInput = {
    id?: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    provider: ProviderCreateNestedOneWithoutContractPermissionsInput
    contract: ContractCreateNestedOneWithoutContractPermissionsInput
    usageQuota?: UsageQuotaCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionUncheckedCreateWithoutServiceInput = {
    id?: string
    providerId: number
    contractId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    usageQuota?: UsageQuotaUncheckedCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionCreateOrConnectWithoutServiceInput = {
    where: ContractPermissionWhereUniqueInput
    create: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput>
  }

  export type ContractPermissionCreateManyServiceInputEnvelope = {
    data: ContractPermissionCreateManyServiceInput | ContractPermissionCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type JWTTokenCreateWithoutServiceInput = {
    id?: string
    token: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
    provider: ProviderCreateNestedOneWithoutJwtTokensInput
    contract?: ContractCreateNestedOneWithoutJwtTokensInput
  }

  export type JWTTokenUncheckedCreateWithoutServiceInput = {
    id?: string
    token: string
    providerId: number
    contractId?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type JWTTokenCreateOrConnectWithoutServiceInput = {
    where: JWTTokenWhereUniqueInput
    create: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput>
  }

  export type JWTTokenCreateManyServiceInputEnvelope = {
    data: JWTTokenCreateManyServiceInput | JWTTokenCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSubscriptionCreateWithoutServiceInput = {
    id?: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    platform: PlatformCreateNestedOneWithoutServiceSubscriptionsInput
    provider: ProviderCreateNestedOneWithoutServiceSubscriptionsInput
  }

  export type ServiceSubscriptionUncheckedCreateWithoutServiceInput = {
    id?: string
    platformId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServiceSubscriptionCreateOrConnectWithoutServiceInput = {
    where: ServiceSubscriptionWhereUniqueInput
    create: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput>
  }

  export type ServiceSubscriptionCreateManyServiceInputEnvelope = {
    data: ServiceSubscriptionCreateManyServiceInput | ServiceSubscriptionCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ServicePermissionCreateWithoutServiceInput = {
    id?: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
    contract: ContractCreateNestedOneWithoutServicePermissionsInput
    provider: ProviderCreateNestedOneWithoutServicePermissionInput
  }

  export type ServicePermissionUncheckedCreateWithoutServiceInput = {
    id?: string
    contractId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePermissionCreateOrConnectWithoutServiceInput = {
    where: ServicePermissionWhereUniqueInput
    create: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput>
  }

  export type ServicePermissionCreateManyServiceInputEnvelope = {
    data: ServicePermissionCreateManyServiceInput | ServicePermissionCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type AccessLogCreateWithoutServiceInput = {
    id?: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    contract?: ContractCreateNestedOneWithoutAccessLogsInput
    provider: ProviderCreateNestedOneWithoutAccessLogsInput
  }

  export type AccessLogUncheckedCreateWithoutServiceInput = {
    id?: string
    contractId?: string | null
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AccessLogCreateOrConnectWithoutServiceInput = {
    where: AccessLogWhereUniqueInput
    create: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput>
  }

  export type AccessLogCreateManyServiceInputEnvelope = {
    data: AccessLogCreateManyServiceInput | AccessLogCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ComplianceAuditCreateWithoutServiceInput = {
    id?: string
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
    provider: ProviderCreateNestedOneWithoutComplianceAuditsInput
  }

  export type ComplianceAuditUncheckedCreateWithoutServiceInput = {
    id?: string
    providerId: number
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type ComplianceAuditCreateOrConnectWithoutServiceInput = {
    where: ComplianceAuditWhereUniqueInput
    create: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput>
  }

  export type ComplianceAuditCreateManyServiceInputEnvelope = {
    data: ComplianceAuditCreateManyServiceInput | ComplianceAuditCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ZKProofVerificationCreateWithoutServiceInput = {
    id?: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
    contract: ContractCreateNestedOneWithoutZkProofVerificationsInput
  }

  export type ZKProofVerificationUncheckedCreateWithoutServiceInput = {
    id?: string
    contractId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ZKProofVerificationCreateOrConnectWithoutServiceInput = {
    where: ZKProofVerificationWhereUniqueInput
    create: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput>
  }

  export type ZKProofVerificationCreateManyServiceInputEnvelope = {
    data: ZKProofVerificationCreateManyServiceInput | ZKProofVerificationCreateManyServiceInput[]
    skipDuplicates?: boolean
  }

  export type ProviderUpsertWithoutServicesInput = {
    update: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
    create: XOR<ProviderCreateWithoutServicesInput, ProviderUncheckedCreateWithoutServicesInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutServicesInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutServicesInput, ProviderUncheckedUpdateWithoutServicesInput>
  }

  export type ProviderUpdateWithoutServicesInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutServicesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractPermissionUpsertWithWhereUniqueWithoutServiceInput = {
    where: ContractPermissionWhereUniqueInput
    update: XOR<ContractPermissionUpdateWithoutServiceInput, ContractPermissionUncheckedUpdateWithoutServiceInput>
    create: XOR<ContractPermissionCreateWithoutServiceInput, ContractPermissionUncheckedCreateWithoutServiceInput>
  }

  export type ContractPermissionUpdateWithWhereUniqueWithoutServiceInput = {
    where: ContractPermissionWhereUniqueInput
    data: XOR<ContractPermissionUpdateWithoutServiceInput, ContractPermissionUncheckedUpdateWithoutServiceInput>
  }

  export type ContractPermissionUpdateManyWithWhereWithoutServiceInput = {
    where: ContractPermissionScalarWhereInput
    data: XOR<ContractPermissionUpdateManyMutationInput, ContractPermissionUncheckedUpdateManyWithoutServiceInput>
  }

  export type JWTTokenUpsertWithWhereUniqueWithoutServiceInput = {
    where: JWTTokenWhereUniqueInput
    update: XOR<JWTTokenUpdateWithoutServiceInput, JWTTokenUncheckedUpdateWithoutServiceInput>
    create: XOR<JWTTokenCreateWithoutServiceInput, JWTTokenUncheckedCreateWithoutServiceInput>
  }

  export type JWTTokenUpdateWithWhereUniqueWithoutServiceInput = {
    where: JWTTokenWhereUniqueInput
    data: XOR<JWTTokenUpdateWithoutServiceInput, JWTTokenUncheckedUpdateWithoutServiceInput>
  }

  export type JWTTokenUpdateManyWithWhereWithoutServiceInput = {
    where: JWTTokenScalarWhereInput
    data: XOR<JWTTokenUpdateManyMutationInput, JWTTokenUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServiceSubscriptionUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServiceSubscriptionWhereUniqueInput
    update: XOR<ServiceSubscriptionUpdateWithoutServiceInput, ServiceSubscriptionUncheckedUpdateWithoutServiceInput>
    create: XOR<ServiceSubscriptionCreateWithoutServiceInput, ServiceSubscriptionUncheckedCreateWithoutServiceInput>
  }

  export type ServiceSubscriptionUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServiceSubscriptionWhereUniqueInput
    data: XOR<ServiceSubscriptionUpdateWithoutServiceInput, ServiceSubscriptionUncheckedUpdateWithoutServiceInput>
  }

  export type ServiceSubscriptionUpdateManyWithWhereWithoutServiceInput = {
    where: ServiceSubscriptionScalarWhereInput
    data: XOR<ServiceSubscriptionUpdateManyMutationInput, ServiceSubscriptionUncheckedUpdateManyWithoutServiceInput>
  }

  export type ServicePermissionUpsertWithWhereUniqueWithoutServiceInput = {
    where: ServicePermissionWhereUniqueInput
    update: XOR<ServicePermissionUpdateWithoutServiceInput, ServicePermissionUncheckedUpdateWithoutServiceInput>
    create: XOR<ServicePermissionCreateWithoutServiceInput, ServicePermissionUncheckedCreateWithoutServiceInput>
  }

  export type ServicePermissionUpdateWithWhereUniqueWithoutServiceInput = {
    where: ServicePermissionWhereUniqueInput
    data: XOR<ServicePermissionUpdateWithoutServiceInput, ServicePermissionUncheckedUpdateWithoutServiceInput>
  }

  export type ServicePermissionUpdateManyWithWhereWithoutServiceInput = {
    where: ServicePermissionScalarWhereInput
    data: XOR<ServicePermissionUpdateManyMutationInput, ServicePermissionUncheckedUpdateManyWithoutServiceInput>
  }

  export type AccessLogUpsertWithWhereUniqueWithoutServiceInput = {
    where: AccessLogWhereUniqueInput
    update: XOR<AccessLogUpdateWithoutServiceInput, AccessLogUncheckedUpdateWithoutServiceInput>
    create: XOR<AccessLogCreateWithoutServiceInput, AccessLogUncheckedCreateWithoutServiceInput>
  }

  export type AccessLogUpdateWithWhereUniqueWithoutServiceInput = {
    where: AccessLogWhereUniqueInput
    data: XOR<AccessLogUpdateWithoutServiceInput, AccessLogUncheckedUpdateWithoutServiceInput>
  }

  export type AccessLogUpdateManyWithWhereWithoutServiceInput = {
    where: AccessLogScalarWhereInput
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyWithoutServiceInput>
  }

  export type ComplianceAuditUpsertWithWhereUniqueWithoutServiceInput = {
    where: ComplianceAuditWhereUniqueInput
    update: XOR<ComplianceAuditUpdateWithoutServiceInput, ComplianceAuditUncheckedUpdateWithoutServiceInput>
    create: XOR<ComplianceAuditCreateWithoutServiceInput, ComplianceAuditUncheckedCreateWithoutServiceInput>
  }

  export type ComplianceAuditUpdateWithWhereUniqueWithoutServiceInput = {
    where: ComplianceAuditWhereUniqueInput
    data: XOR<ComplianceAuditUpdateWithoutServiceInput, ComplianceAuditUncheckedUpdateWithoutServiceInput>
  }

  export type ComplianceAuditUpdateManyWithWhereWithoutServiceInput = {
    where: ComplianceAuditScalarWhereInput
    data: XOR<ComplianceAuditUpdateManyMutationInput, ComplianceAuditUncheckedUpdateManyWithoutServiceInput>
  }

  export type ZKProofVerificationUpsertWithWhereUniqueWithoutServiceInput = {
    where: ZKProofVerificationWhereUniqueInput
    update: XOR<ZKProofVerificationUpdateWithoutServiceInput, ZKProofVerificationUncheckedUpdateWithoutServiceInput>
    create: XOR<ZKProofVerificationCreateWithoutServiceInput, ZKProofVerificationUncheckedCreateWithoutServiceInput>
  }

  export type ZKProofVerificationUpdateWithWhereUniqueWithoutServiceInput = {
    where: ZKProofVerificationWhereUniqueInput
    data: XOR<ZKProofVerificationUpdateWithoutServiceInput, ZKProofVerificationUncheckedUpdateWithoutServiceInput>
  }

  export type ZKProofVerificationUpdateManyWithWhereWithoutServiceInput = {
    where: ZKProofVerificationScalarWhereInput
    data: XOR<ZKProofVerificationUpdateManyMutationInput, ZKProofVerificationUncheckedUpdateManyWithoutServiceInput>
  }

  export type ZKProofVerificationScalarWhereInput = {
    AND?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
    OR?: ZKProofVerificationScalarWhereInput[]
    NOT?: ZKProofVerificationScalarWhereInput | ZKProofVerificationScalarWhereInput[]
    id?: StringFilter<"ZKProofVerification"> | string
    contractId?: StringFilter<"ZKProofVerification"> | string
    serviceId?: StringFilter<"ZKProofVerification"> | string
    proofType?: EnumZKProofTypeFilter<"ZKProofVerification"> | $Enums.ZKProofType
    proofHash?: StringFilter<"ZKProofVerification"> | string
    publicInputs?: JsonFilter<"ZKProofVerification">
    isValid?: BoolFilter<"ZKProofVerification"> | boolean
    verifiedAt?: DateTimeFilter<"ZKProofVerification"> | Date | string
  }

  export type ContractCreateWithoutPlatformInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutPlatformInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutPlatformInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput>
  }

  export type ContractCreateManyPlatformInputEnvelope = {
    data: ContractCreateManyPlatformInput | ContractCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type ServiceSubscriptionCreateWithoutPlatformInput = {
    id?: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
    service: ServiceCreateNestedOneWithoutServiceSubscriptionsInput
    provider: ProviderCreateNestedOneWithoutServiceSubscriptionsInput
  }

  export type ServiceSubscriptionUncheckedCreateWithoutPlatformInput = {
    id?: string
    serviceId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServiceSubscriptionCreateOrConnectWithoutPlatformInput = {
    where: ServiceSubscriptionWhereUniqueInput
    create: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput>
  }

  export type ServiceSubscriptionCreateManyPlatformInputEnvelope = {
    data: ServiceSubscriptionCreateManyPlatformInput | ServiceSubscriptionCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type PlatformAccessTokenCreateWithoutPlatformInput = {
    id?: string
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    provider: ProviderCreateNestedOneWithoutPlatformAccessTokensInput
  }

  export type PlatformAccessTokenUncheckedCreateWithoutPlatformInput = {
    id?: string
    providerId: number
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type PlatformAccessTokenCreateOrConnectWithoutPlatformInput = {
    where: PlatformAccessTokenWhereUniqueInput
    create: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput>
  }

  export type PlatformAccessTokenCreateManyPlatformInputEnvelope = {
    data: PlatformAccessTokenCreateManyPlatformInput | PlatformAccessTokenCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type PlatformAccessCreateWithoutPlatformInput = {
    id?: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutPlatformAccessInput
  }

  export type PlatformAccessUncheckedCreateWithoutPlatformInput = {
    id?: string
    providerId: number
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAccessCreateOrConnectWithoutPlatformInput = {
    where: PlatformAccessWhereUniqueInput
    create: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput>
  }

  export type PlatformAccessCreateManyPlatformInputEnvelope = {
    data: PlatformAccessCreateManyPlatformInput | PlatformAccessCreateManyPlatformInput[]
    skipDuplicates?: boolean
  }

  export type ContractUpsertWithWhereUniqueWithoutPlatformInput = {
    where: ContractWhereUniqueInput
    update: XOR<ContractUpdateWithoutPlatformInput, ContractUncheckedUpdateWithoutPlatformInput>
    create: XOR<ContractCreateWithoutPlatformInput, ContractUncheckedCreateWithoutPlatformInput>
  }

  export type ContractUpdateWithWhereUniqueWithoutPlatformInput = {
    where: ContractWhereUniqueInput
    data: XOR<ContractUpdateWithoutPlatformInput, ContractUncheckedUpdateWithoutPlatformInput>
  }

  export type ContractUpdateManyWithWhereWithoutPlatformInput = {
    where: ContractScalarWhereInput
    data: XOR<ContractUpdateManyMutationInput, ContractUncheckedUpdateManyWithoutPlatformInput>
  }

  export type ContractScalarWhereInput = {
    AND?: ContractScalarWhereInput | ContractScalarWhereInput[]
    OR?: ContractScalarWhereInput[]
    NOT?: ContractScalarWhereInput | ContractScalarWhereInput[]
    id?: StringFilter<"Contract"> | string
    platformId?: StringFilter<"Contract"> | string
    name?: StringFilter<"Contract"> | string
    chain?: StringFilter<"Contract"> | string
    address?: StringFilter<"Contract"> | string
    abi?: JsonFilter<"Contract">
    zkProofRequirements?: JsonFilter<"Contract">
    complianceStatus?: EnumComplianceStatusFilter<"Contract"> | $Enums.ComplianceStatus
    createdAt?: DateTimeFilter<"Contract"> | Date | string
    updatedAt?: DateTimeFilter<"Contract"> | Date | string
  }

  export type ServiceSubscriptionUpsertWithWhereUniqueWithoutPlatformInput = {
    where: ServiceSubscriptionWhereUniqueInput
    update: XOR<ServiceSubscriptionUpdateWithoutPlatformInput, ServiceSubscriptionUncheckedUpdateWithoutPlatformInput>
    create: XOR<ServiceSubscriptionCreateWithoutPlatformInput, ServiceSubscriptionUncheckedCreateWithoutPlatformInput>
  }

  export type ServiceSubscriptionUpdateWithWhereUniqueWithoutPlatformInput = {
    where: ServiceSubscriptionWhereUniqueInput
    data: XOR<ServiceSubscriptionUpdateWithoutPlatformInput, ServiceSubscriptionUncheckedUpdateWithoutPlatformInput>
  }

  export type ServiceSubscriptionUpdateManyWithWhereWithoutPlatformInput = {
    where: ServiceSubscriptionScalarWhereInput
    data: XOR<ServiceSubscriptionUpdateManyMutationInput, ServiceSubscriptionUncheckedUpdateManyWithoutPlatformInput>
  }

  export type PlatformAccessTokenUpsertWithWhereUniqueWithoutPlatformInput = {
    where: PlatformAccessTokenWhereUniqueInput
    update: XOR<PlatformAccessTokenUpdateWithoutPlatformInput, PlatformAccessTokenUncheckedUpdateWithoutPlatformInput>
    create: XOR<PlatformAccessTokenCreateWithoutPlatformInput, PlatformAccessTokenUncheckedCreateWithoutPlatformInput>
  }

  export type PlatformAccessTokenUpdateWithWhereUniqueWithoutPlatformInput = {
    where: PlatformAccessTokenWhereUniqueInput
    data: XOR<PlatformAccessTokenUpdateWithoutPlatformInput, PlatformAccessTokenUncheckedUpdateWithoutPlatformInput>
  }

  export type PlatformAccessTokenUpdateManyWithWhereWithoutPlatformInput = {
    where: PlatformAccessTokenScalarWhereInput
    data: XOR<PlatformAccessTokenUpdateManyMutationInput, PlatformAccessTokenUncheckedUpdateManyWithoutPlatformInput>
  }

  export type PlatformAccessUpsertWithWhereUniqueWithoutPlatformInput = {
    where: PlatformAccessWhereUniqueInput
    update: XOR<PlatformAccessUpdateWithoutPlatformInput, PlatformAccessUncheckedUpdateWithoutPlatformInput>
    create: XOR<PlatformAccessCreateWithoutPlatformInput, PlatformAccessUncheckedCreateWithoutPlatformInput>
  }

  export type PlatformAccessUpdateWithWhereUniqueWithoutPlatformInput = {
    where: PlatformAccessWhereUniqueInput
    data: XOR<PlatformAccessUpdateWithoutPlatformInput, PlatformAccessUncheckedUpdateWithoutPlatformInput>
  }

  export type PlatformAccessUpdateManyWithWhereWithoutPlatformInput = {
    where: PlatformAccessScalarWhereInput
    data: XOR<PlatformAccessUpdateManyMutationInput, PlatformAccessUncheckedUpdateManyWithoutPlatformInput>
  }

  export type PlatformCreateWithoutContractsInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutContractsInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutContractsInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutContractsInput, PlatformUncheckedCreateWithoutContractsInput>
  }

  export type ContractPermissionCreateWithoutContractInput = {
    id?: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    provider: ProviderCreateNestedOneWithoutContractPermissionsInput
    service: ServiceCreateNestedOneWithoutContractPermissionsInput
    usageQuota?: UsageQuotaCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionUncheckedCreateWithoutContractInput = {
    id?: string
    providerId: number
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    usageQuota?: UsageQuotaUncheckedCreateNestedOneWithoutContractPermissionInput
  }

  export type ContractPermissionCreateOrConnectWithoutContractInput = {
    where: ContractPermissionWhereUniqueInput
    create: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput>
  }

  export type ContractPermissionCreateManyContractInputEnvelope = {
    data: ContractPermissionCreateManyContractInput | ContractPermissionCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type JWTTokenCreateWithoutContractInput = {
    id?: string
    token: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
    provider: ProviderCreateNestedOneWithoutJwtTokensInput
    service: ServiceCreateNestedOneWithoutJwtTokensInput
  }

  export type JWTTokenUncheckedCreateWithoutContractInput = {
    id?: string
    token: string
    providerId: number
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type JWTTokenCreateOrConnectWithoutContractInput = {
    where: JWTTokenWhereUniqueInput
    create: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput>
  }

  export type JWTTokenCreateManyContractInputEnvelope = {
    data: JWTTokenCreateManyContractInput | JWTTokenCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ServicePermissionCreateWithoutContractInput = {
    id?: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
    service: ServiceCreateNestedOneWithoutServicePermissionsInput
    provider: ProviderCreateNestedOneWithoutServicePermissionInput
  }

  export type ServicePermissionUncheckedCreateWithoutContractInput = {
    id?: string
    serviceId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServicePermissionCreateOrConnectWithoutContractInput = {
    where: ServicePermissionWhereUniqueInput
    create: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput>
  }

  export type ServicePermissionCreateManyContractInputEnvelope = {
    data: ServicePermissionCreateManyContractInput | ServicePermissionCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type AccessLogCreateWithoutContractInput = {
    id?: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
    service: ServiceCreateNestedOneWithoutAccessLogsInput
    provider: ProviderCreateNestedOneWithoutAccessLogsInput
  }

  export type AccessLogUncheckedCreateWithoutContractInput = {
    id?: string
    serviceId: string
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type AccessLogCreateOrConnectWithoutContractInput = {
    where: AccessLogWhereUniqueInput
    create: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput>
  }

  export type AccessLogCreateManyContractInputEnvelope = {
    data: AccessLogCreateManyContractInput | AccessLogCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type ZKProofVerificationCreateWithoutContractInput = {
    id?: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
    service: ServiceCreateNestedOneWithoutZkProofVerificationsInput
  }

  export type ZKProofVerificationUncheckedCreateWithoutContractInput = {
    id?: string
    serviceId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ZKProofVerificationCreateOrConnectWithoutContractInput = {
    where: ZKProofVerificationWhereUniqueInput
    create: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput>
  }

  export type ZKProofVerificationCreateManyContractInputEnvelope = {
    data: ZKProofVerificationCreateManyContractInput | ZKProofVerificationCreateManyContractInput[]
    skipDuplicates?: boolean
  }

  export type PlatformUpsertWithoutContractsInput = {
    update: XOR<PlatformUpdateWithoutContractsInput, PlatformUncheckedUpdateWithoutContractsInput>
    create: XOR<PlatformCreateWithoutContractsInput, PlatformUncheckedCreateWithoutContractsInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutContractsInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutContractsInput, PlatformUncheckedUpdateWithoutContractsInput>
  }

  export type PlatformUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutContractsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type ContractPermissionUpsertWithWhereUniqueWithoutContractInput = {
    where: ContractPermissionWhereUniqueInput
    update: XOR<ContractPermissionUpdateWithoutContractInput, ContractPermissionUncheckedUpdateWithoutContractInput>
    create: XOR<ContractPermissionCreateWithoutContractInput, ContractPermissionUncheckedCreateWithoutContractInput>
  }

  export type ContractPermissionUpdateWithWhereUniqueWithoutContractInput = {
    where: ContractPermissionWhereUniqueInput
    data: XOR<ContractPermissionUpdateWithoutContractInput, ContractPermissionUncheckedUpdateWithoutContractInput>
  }

  export type ContractPermissionUpdateManyWithWhereWithoutContractInput = {
    where: ContractPermissionScalarWhereInput
    data: XOR<ContractPermissionUpdateManyMutationInput, ContractPermissionUncheckedUpdateManyWithoutContractInput>
  }

  export type JWTTokenUpsertWithWhereUniqueWithoutContractInput = {
    where: JWTTokenWhereUniqueInput
    update: XOR<JWTTokenUpdateWithoutContractInput, JWTTokenUncheckedUpdateWithoutContractInput>
    create: XOR<JWTTokenCreateWithoutContractInput, JWTTokenUncheckedCreateWithoutContractInput>
  }

  export type JWTTokenUpdateWithWhereUniqueWithoutContractInput = {
    where: JWTTokenWhereUniqueInput
    data: XOR<JWTTokenUpdateWithoutContractInput, JWTTokenUncheckedUpdateWithoutContractInput>
  }

  export type JWTTokenUpdateManyWithWhereWithoutContractInput = {
    where: JWTTokenScalarWhereInput
    data: XOR<JWTTokenUpdateManyMutationInput, JWTTokenUncheckedUpdateManyWithoutContractInput>
  }

  export type ServicePermissionUpsertWithWhereUniqueWithoutContractInput = {
    where: ServicePermissionWhereUniqueInput
    update: XOR<ServicePermissionUpdateWithoutContractInput, ServicePermissionUncheckedUpdateWithoutContractInput>
    create: XOR<ServicePermissionCreateWithoutContractInput, ServicePermissionUncheckedCreateWithoutContractInput>
  }

  export type ServicePermissionUpdateWithWhereUniqueWithoutContractInput = {
    where: ServicePermissionWhereUniqueInput
    data: XOR<ServicePermissionUpdateWithoutContractInput, ServicePermissionUncheckedUpdateWithoutContractInput>
  }

  export type ServicePermissionUpdateManyWithWhereWithoutContractInput = {
    where: ServicePermissionScalarWhereInput
    data: XOR<ServicePermissionUpdateManyMutationInput, ServicePermissionUncheckedUpdateManyWithoutContractInput>
  }

  export type AccessLogUpsertWithWhereUniqueWithoutContractInput = {
    where: AccessLogWhereUniqueInput
    update: XOR<AccessLogUpdateWithoutContractInput, AccessLogUncheckedUpdateWithoutContractInput>
    create: XOR<AccessLogCreateWithoutContractInput, AccessLogUncheckedCreateWithoutContractInput>
  }

  export type AccessLogUpdateWithWhereUniqueWithoutContractInput = {
    where: AccessLogWhereUniqueInput
    data: XOR<AccessLogUpdateWithoutContractInput, AccessLogUncheckedUpdateWithoutContractInput>
  }

  export type AccessLogUpdateManyWithWhereWithoutContractInput = {
    where: AccessLogScalarWhereInput
    data: XOR<AccessLogUpdateManyMutationInput, AccessLogUncheckedUpdateManyWithoutContractInput>
  }

  export type ZKProofVerificationUpsertWithWhereUniqueWithoutContractInput = {
    where: ZKProofVerificationWhereUniqueInput
    update: XOR<ZKProofVerificationUpdateWithoutContractInput, ZKProofVerificationUncheckedUpdateWithoutContractInput>
    create: XOR<ZKProofVerificationCreateWithoutContractInput, ZKProofVerificationUncheckedCreateWithoutContractInput>
  }

  export type ZKProofVerificationUpdateWithWhereUniqueWithoutContractInput = {
    where: ZKProofVerificationWhereUniqueInput
    data: XOR<ZKProofVerificationUpdateWithoutContractInput, ZKProofVerificationUncheckedUpdateWithoutContractInput>
  }

  export type ZKProofVerificationUpdateManyWithWhereWithoutContractInput = {
    where: ZKProofVerificationScalarWhereInput
    data: XOR<ZKProofVerificationUpdateManyMutationInput, ZKProofVerificationUncheckedUpdateManyWithoutContractInput>
  }

  export type ProviderCreateWithoutPlatformAccessInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutPlatformAccessInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutPlatformAccessInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutPlatformAccessInput, ProviderUncheckedCreateWithoutPlatformAccessInput>
  }

  export type PlatformCreateWithoutPlatformAccessInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutPlatformAccessInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutPlatformAccessInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutPlatformAccessInput, PlatformUncheckedCreateWithoutPlatformAccessInput>
  }

  export type ProviderUpsertWithoutPlatformAccessInput = {
    update: XOR<ProviderUpdateWithoutPlatformAccessInput, ProviderUncheckedUpdateWithoutPlatformAccessInput>
    create: XOR<ProviderCreateWithoutPlatformAccessInput, ProviderUncheckedCreateWithoutPlatformAccessInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutPlatformAccessInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutPlatformAccessInput, ProviderUncheckedUpdateWithoutPlatformAccessInput>
  }

  export type ProviderUpdateWithoutPlatformAccessInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutPlatformAccessInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type PlatformUpsertWithoutPlatformAccessInput = {
    update: XOR<PlatformUpdateWithoutPlatformAccessInput, PlatformUncheckedUpdateWithoutPlatformAccessInput>
    create: XOR<PlatformCreateWithoutPlatformAccessInput, PlatformUncheckedCreateWithoutPlatformAccessInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutPlatformAccessInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutPlatformAccessInput, PlatformUncheckedUpdateWithoutPlatformAccessInput>
  }

  export type PlatformUpdateWithoutPlatformAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutPlatformAccessInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type ProviderCreateWithoutContractPermissionsInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutContractPermissionsInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutContractPermissionsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutContractPermissionsInput, ProviderUncheckedCreateWithoutContractPermissionsInput>
  }

  export type ContractCreateWithoutContractPermissionsInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutContractPermissionsInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutContractPermissionsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutContractPermissionsInput, ContractUncheckedCreateWithoutContractPermissionsInput>
  }

  export type ServiceCreateWithoutContractPermissionsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutContractPermissionsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutContractPermissionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutContractPermissionsInput, ServiceUncheckedCreateWithoutContractPermissionsInput>
  }

  export type UsageQuotaCreateWithoutContractPermissionInput = {
    id?: string
    maxRequests: number
    usedRequests?: number
    timeWindow: string
    renewalPeriod: string
    lastReset?: Date | string
    createdAt?: Date | string
  }

  export type UsageQuotaUncheckedCreateWithoutContractPermissionInput = {
    id?: string
    maxRequests: number
    usedRequests?: number
    timeWindow: string
    renewalPeriod: string
    lastReset?: Date | string
    createdAt?: Date | string
  }

  export type UsageQuotaCreateOrConnectWithoutContractPermissionInput = {
    where: UsageQuotaWhereUniqueInput
    create: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
  }

  export type ProviderUpsertWithoutContractPermissionsInput = {
    update: XOR<ProviderUpdateWithoutContractPermissionsInput, ProviderUncheckedUpdateWithoutContractPermissionsInput>
    create: XOR<ProviderCreateWithoutContractPermissionsInput, ProviderUncheckedCreateWithoutContractPermissionsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutContractPermissionsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutContractPermissionsInput, ProviderUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type ProviderUpdateWithoutContractPermissionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutContractPermissionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractUpsertWithoutContractPermissionsInput = {
    update: XOR<ContractUpdateWithoutContractPermissionsInput, ContractUncheckedUpdateWithoutContractPermissionsInput>
    create: XOR<ContractCreateWithoutContractPermissionsInput, ContractUncheckedCreateWithoutContractPermissionsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutContractPermissionsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutContractPermissionsInput, ContractUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type ContractUpdateWithoutContractPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutContractPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ServiceUpsertWithoutContractPermissionsInput = {
    update: XOR<ServiceUpdateWithoutContractPermissionsInput, ServiceUncheckedUpdateWithoutContractPermissionsInput>
    create: XOR<ServiceCreateWithoutContractPermissionsInput, ServiceUncheckedCreateWithoutContractPermissionsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutContractPermissionsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutContractPermissionsInput, ServiceUncheckedUpdateWithoutContractPermissionsInput>
  }

  export type ServiceUpdateWithoutContractPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutContractPermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type UsageQuotaUpsertWithoutContractPermissionInput = {
    update: XOR<UsageQuotaUpdateWithoutContractPermissionInput, UsageQuotaUncheckedUpdateWithoutContractPermissionInput>
    create: XOR<UsageQuotaCreateWithoutContractPermissionInput, UsageQuotaUncheckedCreateWithoutContractPermissionInput>
    where?: UsageQuotaWhereInput
  }

  export type UsageQuotaUpdateToOneWithWhereWithoutContractPermissionInput = {
    where?: UsageQuotaWhereInput
    data: XOR<UsageQuotaUpdateWithoutContractPermissionInput, UsageQuotaUncheckedUpdateWithoutContractPermissionInput>
  }

  export type UsageQuotaUpdateWithoutContractPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsageQuotaUncheckedUpdateWithoutContractPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    maxRequests?: IntFieldUpdateOperationsInput | number
    usedRequests?: IntFieldUpdateOperationsInput | number
    timeWindow?: StringFieldUpdateOperationsInput | string
    renewalPeriod?: StringFieldUpdateOperationsInput | string
    lastReset?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProviderCreateWithoutJwtTokensInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutJwtTokensInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutJwtTokensInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutJwtTokensInput, ProviderUncheckedCreateWithoutJwtTokensInput>
  }

  export type ContractCreateWithoutJwtTokensInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutJwtTokensInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutJwtTokensInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutJwtTokensInput, ContractUncheckedCreateWithoutJwtTokensInput>
  }

  export type ServiceCreateWithoutJwtTokensInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutJwtTokensInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutJwtTokensInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutJwtTokensInput, ServiceUncheckedCreateWithoutJwtTokensInput>
  }

  export type ProviderUpsertWithoutJwtTokensInput = {
    update: XOR<ProviderUpdateWithoutJwtTokensInput, ProviderUncheckedUpdateWithoutJwtTokensInput>
    create: XOR<ProviderCreateWithoutJwtTokensInput, ProviderUncheckedCreateWithoutJwtTokensInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutJwtTokensInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutJwtTokensInput, ProviderUncheckedUpdateWithoutJwtTokensInput>
  }

  export type ProviderUpdateWithoutJwtTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutJwtTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractUpsertWithoutJwtTokensInput = {
    update: XOR<ContractUpdateWithoutJwtTokensInput, ContractUncheckedUpdateWithoutJwtTokensInput>
    create: XOR<ContractCreateWithoutJwtTokensInput, ContractUncheckedCreateWithoutJwtTokensInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutJwtTokensInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutJwtTokensInput, ContractUncheckedUpdateWithoutJwtTokensInput>
  }

  export type ContractUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ServiceUpsertWithoutJwtTokensInput = {
    update: XOR<ServiceUpdateWithoutJwtTokensInput, ServiceUncheckedUpdateWithoutJwtTokensInput>
    create: XOR<ServiceCreateWithoutJwtTokensInput, ServiceUncheckedCreateWithoutJwtTokensInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutJwtTokensInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutJwtTokensInput, ServiceUncheckedUpdateWithoutJwtTokensInput>
  }

  export type ServiceUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutJwtTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type PlatformCreateWithoutServiceSubscriptionsInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutServiceSubscriptionsInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutPlatformInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutServiceSubscriptionsInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutServiceSubscriptionsInput, PlatformUncheckedCreateWithoutServiceSubscriptionsInput>
  }

  export type ServiceCreateWithoutServiceSubscriptionsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServiceSubscriptionsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServiceSubscriptionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServiceSubscriptionsInput, ServiceUncheckedCreateWithoutServiceSubscriptionsInput>
  }

  export type ProviderCreateWithoutServiceSubscriptionsInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutServiceSubscriptionsInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutServiceSubscriptionsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutServiceSubscriptionsInput, ProviderUncheckedCreateWithoutServiceSubscriptionsInput>
  }

  export type PlatformUpsertWithoutServiceSubscriptionsInput = {
    update: XOR<PlatformUpdateWithoutServiceSubscriptionsInput, PlatformUncheckedUpdateWithoutServiceSubscriptionsInput>
    create: XOR<PlatformCreateWithoutServiceSubscriptionsInput, PlatformUncheckedCreateWithoutServiceSubscriptionsInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutServiceSubscriptionsInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutServiceSubscriptionsInput, PlatformUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type PlatformUpdateWithoutServiceSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutServiceSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type ServiceUpsertWithoutServiceSubscriptionsInput = {
    update: XOR<ServiceUpdateWithoutServiceSubscriptionsInput, ServiceUncheckedUpdateWithoutServiceSubscriptionsInput>
    create: XOR<ServiceCreateWithoutServiceSubscriptionsInput, ServiceUncheckedCreateWithoutServiceSubscriptionsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServiceSubscriptionsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServiceSubscriptionsInput, ServiceUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type ServiceUpdateWithoutServiceSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServiceSubscriptionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProviderUpsertWithoutServiceSubscriptionsInput = {
    update: XOR<ProviderUpdateWithoutServiceSubscriptionsInput, ProviderUncheckedUpdateWithoutServiceSubscriptionsInput>
    create: XOR<ProviderCreateWithoutServiceSubscriptionsInput, ProviderUncheckedCreateWithoutServiceSubscriptionsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutServiceSubscriptionsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutServiceSubscriptionsInput, ProviderUncheckedUpdateWithoutServiceSubscriptionsInput>
  }

  export type ProviderUpdateWithoutServiceSubscriptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutServiceSubscriptionsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type PlatformCreateWithoutPlatformAccessTokensInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutPlatformInput
  }

  export type PlatformUncheckedCreateWithoutPlatformAccessTokensInput = {
    id?: string
    name: string
    platformType: $Enums.PlatformType
    email: string
    permissionLevel: $Enums.PermissionLevel
    zkCapabilities: JsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    contracts?: ContractUncheckedCreateNestedManyWithoutPlatformInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutPlatformInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutPlatformInput
  }

  export type PlatformCreateOrConnectWithoutPlatformAccessTokensInput = {
    where: PlatformWhereUniqueInput
    create: XOR<PlatformCreateWithoutPlatformAccessTokensInput, PlatformUncheckedCreateWithoutPlatformAccessTokensInput>
  }

  export type ProviderCreateWithoutPlatformAccessTokensInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutPlatformAccessTokensInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutPlatformAccessTokensInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutPlatformAccessTokensInput, ProviderUncheckedCreateWithoutPlatformAccessTokensInput>
  }

  export type PlatformUpsertWithoutPlatformAccessTokensInput = {
    update: XOR<PlatformUpdateWithoutPlatformAccessTokensInput, PlatformUncheckedUpdateWithoutPlatformAccessTokensInput>
    create: XOR<PlatformCreateWithoutPlatformAccessTokensInput, PlatformUncheckedCreateWithoutPlatformAccessTokensInput>
    where?: PlatformWhereInput
  }

  export type PlatformUpdateToOneWithWhereWithoutPlatformAccessTokensInput = {
    where?: PlatformWhereInput
    data: XOR<PlatformUpdateWithoutPlatformAccessTokensInput, PlatformUncheckedUpdateWithoutPlatformAccessTokensInput>
  }

  export type PlatformUpdateWithoutPlatformAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutPlatformNestedInput
  }

  export type PlatformUncheckedUpdateWithoutPlatformAccessTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    platformType?: EnumPlatformTypeFieldUpdateOperationsInput | $Enums.PlatformType
    email?: StringFieldUpdateOperationsInput | string
    permissionLevel?: EnumPermissionLevelFieldUpdateOperationsInput | $Enums.PermissionLevel
    zkCapabilities?: JsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contracts?: ContractUncheckedUpdateManyWithoutPlatformNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutPlatformNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutPlatformNestedInput
  }

  export type ProviderUpsertWithoutPlatformAccessTokensInput = {
    update: XOR<ProviderUpdateWithoutPlatformAccessTokensInput, ProviderUncheckedUpdateWithoutPlatformAccessTokensInput>
    create: XOR<ProviderCreateWithoutPlatformAccessTokensInput, ProviderUncheckedCreateWithoutPlatformAccessTokensInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutPlatformAccessTokensInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutPlatformAccessTokensInput, ProviderUncheckedUpdateWithoutPlatformAccessTokensInput>
  }

  export type ProviderUpdateWithoutPlatformAccessTokensInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutPlatformAccessTokensInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractCreateWithoutServicePermissionsInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutServicePermissionsInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutServicePermissionsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutServicePermissionsInput, ContractUncheckedCreateWithoutServicePermissionsInput>
  }

  export type ServiceCreateWithoutServicePermissionsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutServicePermissionsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutServicePermissionsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutServicePermissionsInput, ServiceUncheckedCreateWithoutServicePermissionsInput>
  }

  export type ProviderCreateWithoutServicePermissionInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutServicePermissionInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutServicePermissionInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutServicePermissionInput, ProviderUncheckedCreateWithoutServicePermissionInput>
  }

  export type ContractUpsertWithoutServicePermissionsInput = {
    update: XOR<ContractUpdateWithoutServicePermissionsInput, ContractUncheckedUpdateWithoutServicePermissionsInput>
    create: XOR<ContractCreateWithoutServicePermissionsInput, ContractUncheckedCreateWithoutServicePermissionsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutServicePermissionsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutServicePermissionsInput, ContractUncheckedUpdateWithoutServicePermissionsInput>
  }

  export type ContractUpdateWithoutServicePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutServicePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ServiceUpsertWithoutServicePermissionsInput = {
    update: XOR<ServiceUpdateWithoutServicePermissionsInput, ServiceUncheckedUpdateWithoutServicePermissionsInput>
    create: XOR<ServiceCreateWithoutServicePermissionsInput, ServiceUncheckedCreateWithoutServicePermissionsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutServicePermissionsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutServicePermissionsInput, ServiceUncheckedUpdateWithoutServicePermissionsInput>
  }

  export type ServiceUpdateWithoutServicePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutServicePermissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProviderUpsertWithoutServicePermissionInput = {
    update: XOR<ProviderUpdateWithoutServicePermissionInput, ProviderUncheckedUpdateWithoutServicePermissionInput>
    create: XOR<ProviderCreateWithoutServicePermissionInput, ProviderUncheckedCreateWithoutServicePermissionInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutServicePermissionInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutServicePermissionInput, ProviderUncheckedUpdateWithoutServicePermissionInput>
  }

  export type ProviderUpdateWithoutServicePermissionInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutServicePermissionInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractCreateWithoutAccessLogsInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutAccessLogsInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutAccessLogsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutAccessLogsInput, ContractUncheckedCreateWithoutAccessLogsInput>
  }

  export type ServiceCreateWithoutAccessLogsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutAccessLogsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutAccessLogsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutAccessLogsInput, ServiceUncheckedCreateWithoutAccessLogsInput>
  }

  export type ProviderCreateWithoutAccessLogsInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutAccessLogsInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutAccessLogsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutAccessLogsInput, ProviderUncheckedCreateWithoutAccessLogsInput>
  }

  export type ContractUpsertWithoutAccessLogsInput = {
    update: XOR<ContractUpdateWithoutAccessLogsInput, ContractUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<ContractCreateWithoutAccessLogsInput, ContractUncheckedCreateWithoutAccessLogsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutAccessLogsInput, ContractUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ContractUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ServiceUpsertWithoutAccessLogsInput = {
    update: XOR<ServiceUpdateWithoutAccessLogsInput, ServiceUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<ServiceCreateWithoutAccessLogsInput, ServiceUncheckedCreateWithoutAccessLogsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutAccessLogsInput, ServiceUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ServiceUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutAccessLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ProviderUpsertWithoutAccessLogsInput = {
    update: XOR<ProviderUpdateWithoutAccessLogsInput, ProviderUncheckedUpdateWithoutAccessLogsInput>
    create: XOR<ProviderCreateWithoutAccessLogsInput, ProviderUncheckedCreateWithoutAccessLogsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutAccessLogsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutAccessLogsInput, ProviderUncheckedUpdateWithoutAccessLogsInput>
  }

  export type ProviderUpdateWithoutAccessLogsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutAccessLogsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ContractPermissionCreateWithoutUsageQuotaInput = {
    id?: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
    provider: ProviderCreateNestedOneWithoutContractPermissionsInput
    contract: ContractCreateNestedOneWithoutContractPermissionsInput
    service: ServiceCreateNestedOneWithoutContractPermissionsInput
  }

  export type ContractPermissionUncheckedCreateWithoutUsageQuotaInput = {
    id?: string
    providerId: number
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type ContractPermissionCreateOrConnectWithoutUsageQuotaInput = {
    where: ContractPermissionWhereUniqueInput
    create: XOR<ContractPermissionCreateWithoutUsageQuotaInput, ContractPermissionUncheckedCreateWithoutUsageQuotaInput>
  }

  export type ContractPermissionUpsertWithoutUsageQuotaInput = {
    update: XOR<ContractPermissionUpdateWithoutUsageQuotaInput, ContractPermissionUncheckedUpdateWithoutUsageQuotaInput>
    create: XOR<ContractPermissionCreateWithoutUsageQuotaInput, ContractPermissionUncheckedCreateWithoutUsageQuotaInput>
    where?: ContractPermissionWhereInput
  }

  export type ContractPermissionUpdateToOneWithWhereWithoutUsageQuotaInput = {
    where?: ContractPermissionWhereInput
    data: XOR<ContractPermissionUpdateWithoutUsageQuotaInput, ContractPermissionUncheckedUpdateWithoutUsageQuotaInput>
  }

  export type ContractPermissionUpdateWithoutUsageQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutContractPermissionsNestedInput
    contract?: ContractUpdateOneRequiredWithoutContractPermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutContractPermissionsNestedInput
  }

  export type ContractPermissionUncheckedUpdateWithoutUsageQuotaInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ProviderCreateWithoutComplianceAuditsInput = {
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionCreateNestedManyWithoutProviderInput
  }

  export type ProviderUncheckedCreateWithoutComplianceAuditsInput = {
    id?: number
    name: string
    serviceType: $Enums.ServiceType
    email: string
    rwaType: $Enums.RWAType
    verificationLayer: $Enums.VerificationLayer
    interactionLayer: $Enums.InteractionLayer
    logo?: string | null
    coverImage?: string | null
    serviceVerificationType: $Enums.ServiceVerificationType
    chains?: ProviderCreatechainsInput | string[]
    interopProtocols?: ProviderCreateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee: JsonNullValueInput | InputJsonValue
    authMethod: $Enums.AuthMethod
    jwtSettings: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderCreatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel: $Enums.PrivacyLevel
    complianceFramework?: ProviderCreatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: Date | string
    updatedAt?: Date | string
    services?: ServiceUncheckedCreateNestedManyWithoutProviderInput
    platformAccess?: PlatformAccessUncheckedCreateNestedManyWithoutProviderInput
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutProviderInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutProviderInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutProviderInput
    platformAccessTokens?: PlatformAccessTokenUncheckedCreateNestedManyWithoutProviderInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutProviderInput
    ServicePermission?: ServicePermissionUncheckedCreateNestedManyWithoutProviderInput
  }

  export type ProviderCreateOrConnectWithoutComplianceAuditsInput = {
    where: ProviderWhereUniqueInput
    create: XOR<ProviderCreateWithoutComplianceAuditsInput, ProviderUncheckedCreateWithoutComplianceAuditsInput>
  }

  export type ServiceCreateWithoutComplianceAuditsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutComplianceAuditsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    zkProofVerifications?: ZKProofVerificationUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutComplianceAuditsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutComplianceAuditsInput, ServiceUncheckedCreateWithoutComplianceAuditsInput>
  }

  export type ProviderUpsertWithoutComplianceAuditsInput = {
    update: XOR<ProviderUpdateWithoutComplianceAuditsInput, ProviderUncheckedUpdateWithoutComplianceAuditsInput>
    create: XOR<ProviderCreateWithoutComplianceAuditsInput, ProviderUncheckedCreateWithoutComplianceAuditsInput>
    where?: ProviderWhereInput
  }

  export type ProviderUpdateToOneWithWhereWithoutComplianceAuditsInput = {
    where?: ProviderWhereInput
    data: XOR<ProviderUpdateWithoutComplianceAuditsInput, ProviderUncheckedUpdateWithoutComplianceAuditsInput>
  }

  export type ProviderUpdateWithoutComplianceAuditsInput = {
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUpdateManyWithoutProviderNestedInput
  }

  export type ProviderUncheckedUpdateWithoutComplianceAuditsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    serviceType?: EnumServiceTypeFieldUpdateOperationsInput | $Enums.ServiceType
    email?: StringFieldUpdateOperationsInput | string
    rwaType?: EnumRWATypeFieldUpdateOperationsInput | $Enums.RWAType
    verificationLayer?: EnumVerificationLayerFieldUpdateOperationsInput | $Enums.VerificationLayer
    interactionLayer?: EnumInteractionLayerFieldUpdateOperationsInput | $Enums.InteractionLayer
    logo?: NullableStringFieldUpdateOperationsInput | string | null
    coverImage?: NullableStringFieldUpdateOperationsInput | string | null
    serviceVerificationType?: EnumServiceVerificationTypeFieldUpdateOperationsInput | $Enums.ServiceVerificationType
    chains?: ProviderUpdatechainsInput | string[]
    interopProtocols?: ProviderUpdateinteropProtocolsInput | $Enums.InteropProtocol[]
    serviceFee?: JsonNullValueInput | InputJsonValue
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    jwtSettings?: JsonNullValueInput | InputJsonValue
    zkProofSupport?: ProviderUpdatezkProofSupportInput | $Enums.ZKProofType[]
    privacyLevel?: EnumPrivacyLevelFieldUpdateOperationsInput | $Enums.PrivacyLevel
    complianceFramework?: ProviderUpdatecomplianceFrameworkInput | $Enums.ComplianceFramework[]
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    services?: ServiceUncheckedUpdateManyWithoutProviderNestedInput
    platformAccess?: PlatformAccessUncheckedUpdateManyWithoutProviderNestedInput
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutProviderNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutProviderNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutProviderNestedInput
    platformAccessTokens?: PlatformAccessTokenUncheckedUpdateManyWithoutProviderNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutProviderNestedInput
    ServicePermission?: ServicePermissionUncheckedUpdateManyWithoutProviderNestedInput
  }

  export type ServiceUpsertWithoutComplianceAuditsInput = {
    update: XOR<ServiceUpdateWithoutComplianceAuditsInput, ServiceUncheckedUpdateWithoutComplianceAuditsInput>
    create: XOR<ServiceCreateWithoutComplianceAuditsInput, ServiceUncheckedCreateWithoutComplianceAuditsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutComplianceAuditsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutComplianceAuditsInput, ServiceUncheckedUpdateWithoutComplianceAuditsInput>
  }

  export type ServiceUpdateWithoutComplianceAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutComplianceAuditsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ContractCreateWithoutZkProofVerificationsInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    platform: PlatformCreateNestedOneWithoutContractsInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogCreateNestedManyWithoutContractInput
  }

  export type ContractUncheckedCreateWithoutZkProofVerificationsInput = {
    id?: string
    platformId: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutContractInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutContractInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutContractInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutContractInput
  }

  export type ContractCreateOrConnectWithoutZkProofVerificationsInput = {
    where: ContractWhereUniqueInput
    create: XOR<ContractCreateWithoutZkProofVerificationsInput, ContractUncheckedCreateWithoutZkProofVerificationsInput>
  }

  export type ServiceCreateWithoutZkProofVerificationsInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    provider: ProviderCreateNestedOneWithoutServicesInput
    contractPermissions?: ContractPermissionCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditCreateNestedManyWithoutServiceInput
  }

  export type ServiceUncheckedCreateWithoutZkProofVerificationsInput = {
    id?: string
    providerId: number
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    contractPermissions?: ContractPermissionUncheckedCreateNestedManyWithoutServiceInput
    jwtTokens?: JWTTokenUncheckedCreateNestedManyWithoutServiceInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedCreateNestedManyWithoutServiceInput
    servicePermissions?: ServicePermissionUncheckedCreateNestedManyWithoutServiceInput
    accessLogs?: AccessLogUncheckedCreateNestedManyWithoutServiceInput
    complianceAudits?: ComplianceAuditUncheckedCreateNestedManyWithoutServiceInput
  }

  export type ServiceCreateOrConnectWithoutZkProofVerificationsInput = {
    where: ServiceWhereUniqueInput
    create: XOR<ServiceCreateWithoutZkProofVerificationsInput, ServiceUncheckedCreateWithoutZkProofVerificationsInput>
  }

  export type ContractUpsertWithoutZkProofVerificationsInput = {
    update: XOR<ContractUpdateWithoutZkProofVerificationsInput, ContractUncheckedUpdateWithoutZkProofVerificationsInput>
    create: XOR<ContractCreateWithoutZkProofVerificationsInput, ContractUncheckedCreateWithoutZkProofVerificationsInput>
    where?: ContractWhereInput
  }

  export type ContractUpdateToOneWithWhereWithoutZkProofVerificationsInput = {
    where?: ContractWhereInput
    data: XOR<ContractUpdateWithoutZkProofVerificationsInput, ContractUncheckedUpdateWithoutZkProofVerificationsInput>
  }

  export type ContractUpdateWithoutZkProofVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutContractsNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutZkProofVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ServiceUpsertWithoutZkProofVerificationsInput = {
    update: XOR<ServiceUpdateWithoutZkProofVerificationsInput, ServiceUncheckedUpdateWithoutZkProofVerificationsInput>
    create: XOR<ServiceCreateWithoutZkProofVerificationsInput, ServiceUncheckedCreateWithoutZkProofVerificationsInput>
    where?: ServiceWhereInput
  }

  export type ServiceUpdateToOneWithWhereWithoutZkProofVerificationsInput = {
    where?: ServiceWhereInput
    data: XOR<ServiceUpdateWithoutZkProofVerificationsInput, ServiceUncheckedUpdateWithoutZkProofVerificationsInput>
  }

  export type ServiceUpdateWithoutZkProofVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutServicesNestedInput
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutZkProofVerificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceCreateManyProviderInput = {
    id?: string
    name: string
    description?: string | null
    endpoint: string
    proofOfService: $Enums.ProofOfServiceType
    serviceCategory: $Enums.ServiceCategory
    authMethod: $Enums.AuthMethod
    accessLevel: $Enums.AccessLevel
    rateLimits: JsonNullValueInput | InputJsonValue
    zkRequirements: JsonNullValueInput | InputJsonValue
    complianceChecks: JsonNullValueInput | InputJsonValue
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PlatformAccessCreateManyProviderInput = {
    id?: string
    platformId: string
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractPermissionCreateManyProviderInput = {
    id?: string
    contractId: string
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type JWTTokenCreateManyProviderInput = {
    id?: string
    token: string
    contractId?: string | null
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type ServiceSubscriptionCreateManyProviderInput = {
    id?: string
    platformId: string
    serviceId: string
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type PlatformAccessTokenCreateManyProviderInput = {
    id?: string
    platformId: string
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type ComplianceAuditCreateManyProviderInput = {
    id?: string
    serviceId?: string | null
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type AccessLogCreateManyProviderInput = {
    id?: string
    contractId?: string | null
    serviceId: string
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ServicePermissionCreateManyProviderInput = {
    id?: string
    contractId: string
    serviceId: string
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutServiceNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutServiceNestedInput
    serviceSubscriptions?: ServiceSubscriptionUncheckedUpdateManyWithoutServiceNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutServiceNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutServiceNestedInput
    complianceAudits?: ComplianceAuditUncheckedUpdateManyWithoutServiceNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutServiceNestedInput
  }

  export type ServiceUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: StringFieldUpdateOperationsInput | string
    proofOfService?: EnumProofOfServiceTypeFieldUpdateOperationsInput | $Enums.ProofOfServiceType
    serviceCategory?: EnumServiceCategoryFieldUpdateOperationsInput | $Enums.ServiceCategory
    authMethod?: EnumAuthMethodFieldUpdateOperationsInput | $Enums.AuthMethod
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    rateLimits?: JsonNullValueInput | InputJsonValue
    zkRequirements?: JsonNullValueInput | InputJsonValue
    complianceChecks?: JsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    platform?: PlatformUpdateOneRequiredWithoutPlatformAccessNestedInput
  }

  export type PlatformAccessUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractPermissionUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    contract?: ContractUpdateOneRequiredWithoutContractPermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutContractPermissionsNestedInput
    usageQuota?: UsageQuotaUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageQuota?: UsageQuotaUncheckedUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    contract?: ContractUpdateOneWithoutJwtTokensNestedInput
    service?: ServiceUpdateOneRequiredWithoutJwtTokensNestedInput
  }

  export type JWTTokenUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    platform?: PlatformUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
  }

  export type ServiceSubscriptionUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    platform?: PlatformUpdateOneRequiredWithoutPlatformAccessTokensNestedInput
  }

  export type PlatformAccessTokenUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ComplianceAuditUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    service?: ServiceUpdateOneWithoutComplianceAuditsNestedInput
  }

  export type ComplianceAuditUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComplianceAuditUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: NullableStringFieldUpdateOperationsInput | string | null
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type AccessLogUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutAccessLogsNestedInput
    service?: ServiceUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type AccessLogUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    serviceId?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutServicePermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutServicePermissionsNestedInput
  }

  export type ServicePermissionUncheckedUpdateWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionUncheckedUpdateManyWithoutProviderInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractPermissionCreateManyServiceInput = {
    id?: string
    providerId: number
    contractId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type JWTTokenCreateManyServiceInput = {
    id?: string
    token: string
    providerId: number
    contractId?: string | null
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type ServiceSubscriptionCreateManyServiceInput = {
    id?: string
    platformId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type ServicePermissionCreateManyServiceInput = {
    id?: string
    contractId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessLogCreateManyServiceInput = {
    id?: string
    contractId?: string | null
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ComplianceAuditCreateManyServiceInput = {
    id?: string
    providerId: number
    framework: $Enums.ComplianceFramework
    status: $Enums.ComplianceStatus
    auditData: JsonNullValueInput | InputJsonValue
    auditDate?: Date | string
    expiresAt?: Date | string | null
  }

  export type ZKProofVerificationCreateManyServiceInput = {
    id?: string
    contractId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ContractPermissionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutContractPermissionsNestedInput
    contract?: ContractUpdateOneRequiredWithoutContractPermissionsNestedInput
    usageQuota?: UsageQuotaUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageQuota?: UsageQuotaUncheckedUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutJwtTokensNestedInput
    contract?: ContractUpdateOneWithoutJwtTokensNestedInput
  }

  export type JWTTokenUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    platform?: PlatformUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
  }

  export type ServiceSubscriptionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    platformId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicePermissionUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutServicePermissionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServicePermissionNestedInput
  }

  export type ServicePermissionUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneWithoutAccessLogsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type AccessLogUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: NullableStringFieldUpdateOperationsInput | string | null
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplianceAuditUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    provider?: ProviderUpdateOneRequiredWithoutComplianceAuditsNestedInput
  }

  export type ComplianceAuditUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ComplianceAuditUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    framework?: EnumComplianceFrameworkFieldUpdateOperationsInput | $Enums.ComplianceFramework
    status?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    auditData?: JsonNullValueInput | InputJsonValue
    auditDate?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ZKProofVerificationUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contract?: ContractUpdateOneRequiredWithoutZkProofVerificationsNestedInput
  }

  export type ZKProofVerificationUncheckedUpdateWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZKProofVerificationUncheckedUpdateManyWithoutServiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    contractId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractCreateManyPlatformInput = {
    id?: string
    name: string
    chain: string
    address: string
    abi: JsonNullValueInput | InputJsonValue
    zkProofRequirements: JsonNullValueInput | InputJsonValue
    complianceStatus: $Enums.ComplianceStatus
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ServiceSubscriptionCreateManyPlatformInput = {
    id?: string
    serviceId: string
    providerId: number
    accessLevel: $Enums.AccessLevel
    contractAccess: JsonNullValueInput | InputJsonValue
    subscribedAt?: Date | string
    expiresAt?: Date | string | null
    isActive?: boolean
  }

  export type PlatformAccessTokenCreateManyPlatformInput = {
    id?: string
    providerId: number
    token: string
    serviceIds?: PlatformAccessTokenCreateserviceIdsInput | string[]
    permissions: JsonNullValueInput | InputJsonValue
    zkProofRequired?: boolean
    issuedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type PlatformAccessCreateManyPlatformInput = {
    id?: string
    providerId: number
    grantedServices?: PlatformAccessCreategrantedServicesInput | string[]
    accessType: $Enums.AccessType
    permissions: JsonNullValueInput | InputJsonValue
    expiresAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ContractUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    contractPermissions?: ContractPermissionUncheckedUpdateManyWithoutContractNestedInput
    jwtTokens?: JWTTokenUncheckedUpdateManyWithoutContractNestedInput
    servicePermissions?: ServicePermissionUncheckedUpdateManyWithoutContractNestedInput
    accessLogs?: AccessLogUncheckedUpdateManyWithoutContractNestedInput
    zkProofVerifications?: ZKProofVerificationUncheckedUpdateManyWithoutContractNestedInput
  }

  export type ContractUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    chain?: StringFieldUpdateOperationsInput | string
    address?: StringFieldUpdateOperationsInput | string
    abi?: JsonNullValueInput | InputJsonValue
    zkProofRequirements?: JsonNullValueInput | InputJsonValue
    complianceStatus?: EnumComplianceStatusFieldUpdateOperationsInput | $Enums.ComplianceStatus
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServiceSubscriptionUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    service?: ServiceUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServiceSubscriptionsNestedInput
  }

  export type ServiceSubscriptionUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServiceSubscriptionUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessLevel?: EnumAccessLevelFieldUpdateOperationsInput | $Enums.AccessLevel
    contractAccess?: JsonNullValueInput | InputJsonValue
    subscribedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutPlatformAccessTokensNestedInput
  }

  export type PlatformAccessTokenUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessTokenUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    token?: StringFieldUpdateOperationsInput | string
    serviceIds?: PlatformAccessTokenUpdateserviceIdsInput | string[]
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofRequired?: BoolFieldUpdateOperationsInput | boolean
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PlatformAccessUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    provider?: ProviderUpdateOneRequiredWithoutPlatformAccessNestedInput
  }

  export type PlatformAccessUncheckedUpdateWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PlatformAccessUncheckedUpdateManyWithoutPlatformInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    grantedServices?: PlatformAccessUpdategrantedServicesInput | string[]
    accessType?: EnumAccessTypeFieldUpdateOperationsInput | $Enums.AccessType
    permissions?: JsonNullValueInput | InputJsonValue
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ContractPermissionCreateManyContractInput = {
    id?: string
    providerId: number
    serviceId: string
    jwtToken: string
    permissions: JsonNullValueInput | InputJsonValue
    grantedAt?: Date | string
    expiresAt: Date | string
    isActive?: boolean
  }

  export type JWTTokenCreateManyContractInput = {
    id?: string
    token: string
    providerId: number
    serviceId: string
    permissions: JsonNullValueInput | InputJsonValue
    zkProofHash?: string | null
    issuedAt?: Date | string
    expiresAt: Date | string
    isRevoked?: boolean
  }

  export type ServicePermissionCreateManyContractInput = {
    id?: string
    serviceId: string
    providerId: number
    accessGranted?: boolean
    jwtToken?: string | null
    grantedAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccessLogCreateManyContractInput = {
    id?: string
    serviceId: string
    providerId: number
    action: string
    zkProofHash?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: Date | string
  }

  export type ZKProofVerificationCreateManyContractInput = {
    id?: string
    serviceId: string
    proofType: $Enums.ZKProofType
    proofHash: string
    publicInputs: JsonNullValueInput | InputJsonValue
    isValid: boolean
    verifiedAt?: Date | string
  }

  export type ContractPermissionUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutContractPermissionsNestedInput
    service?: ServiceUpdateOneRequiredWithoutContractPermissionsNestedInput
    usageQuota?: UsageQuotaUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    usageQuota?: UsageQuotaUncheckedUpdateOneWithoutContractPermissionNestedInput
  }

  export type ContractPermissionUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: StringFieldUpdateOperationsInput | string
    jwtToken?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
    provider?: ProviderUpdateOneRequiredWithoutJwtTokensNestedInput
    service?: ServiceUpdateOneRequiredWithoutJwtTokensNestedInput
  }

  export type JWTTokenUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type JWTTokenUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    serviceId?: StringFieldUpdateOperationsInput | string
    permissions?: JsonNullValueInput | InputJsonValue
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    expiresAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRevoked?: BoolFieldUpdateOperationsInput | boolean
  }

  export type ServicePermissionUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutServicePermissionsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutServicePermissionNestedInput
  }

  export type ServicePermissionUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ServicePermissionUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    accessGranted?: BoolFieldUpdateOperationsInput | boolean
    jwtToken?: NullableStringFieldUpdateOperationsInput | string | null
    grantedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutAccessLogsNestedInput
    provider?: ProviderUpdateOneRequiredWithoutAccessLogsNestedInput
  }

  export type AccessLogUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessLogUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    providerId?: IntFieldUpdateOperationsInput | number
    action?: StringFieldUpdateOperationsInput | string
    zkProofHash?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZKProofVerificationUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    service?: ServiceUpdateOneRequiredWithoutZkProofVerificationsNestedInput
  }

  export type ZKProofVerificationUncheckedUpdateWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ZKProofVerificationUncheckedUpdateManyWithoutContractInput = {
    id?: StringFieldUpdateOperationsInput | string
    serviceId?: StringFieldUpdateOperationsInput | string
    proofType?: EnumZKProofTypeFieldUpdateOperationsInput | $Enums.ZKProofType
    proofHash?: StringFieldUpdateOperationsInput | string
    publicInputs?: JsonNullValueInput | InputJsonValue
    isValid?: BoolFieldUpdateOperationsInput | boolean
    verifiedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}